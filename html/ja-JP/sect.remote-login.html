<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. リモートログイン</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="システム起動, 初期化スクリプト, SSH, Telnet, 権限, パーミッション, 管理, Inetd, Cron, バックアップ, ホットプラグ, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="unix-services.html"
        title="第9章 Unix サービス" /><link
        rel="prev"
        href="unix-services.html"
        title="第9章 Unix サービス" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. 権限の管理" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ja-JP/sect.remote-login.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.remote-login"></a>9.2. リモートログイン</h2></div></div></div><div
          class="para">
			管理者にとってコンピュータにリモートから接続できることは不可欠な要素です。専用の部屋に閉じ込められているサーバに、キーボードとモニタが常設されていることはめったにありません - しかしサーバはネットワークに繋がっています。
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>BACK TO BASICS</em></span> クライアント、サーバ</strong></p></div></div></div><a
            id="idm140296563578192"
            class="indexterm"></a><a
            id="idm140296563576784"
            class="indexterm"></a><div
            class="para">
			複数のプロセスが互いに通信しているシステムはよく「クライアント/サーバ」に例えられます。サーバはクライアントからの要求に応じて、その要求を実行するプログラムです。操作を制御するのがクライアントで、サーバは制御の主導権を握りません。
		</div></div><a
          id="idm140296563574400"
          class="indexterm"></a><a
          id="idm140296563572992"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ssh"></a>9.2.1. 安全なリモートログイン: SSH</h3></div></div></div><a
            id="idm140296563571040"
            class="indexterm"></a><a
            id="idm140296563570080"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>SSH</em></span> (Secure SHell) プロトコルは安全性と信頼性を念頭に置いて設計されました。SSH を使う接続は安全です: 通信相手は認証され、交換されるデータはすべて暗号化されます。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> Telnet と RSH は時代遅れです</strong></p></div></div></div><a
              id="idm140296563566864"
              class="indexterm"></a><a
              id="idm140296563565744"
              class="indexterm"></a><div
              class="para">
				SSH 以前、<span
                class="emphasis"><em>Telnet</em></span> と <span
                class="emphasis"><em>RSH</em></span> がリモートからログインするために使われる主なツールでした。両者は今や大幅に時代遅れです。両者がまだ Debian から配布されているとしても、もはやそれを使うべきではありません。
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULARY</em></span> 認証、暗号化</strong></p></div></div></div><div
              class="para">
				サーバ上でクライアントが活動を行ったり始めることを許可する必要がある場合、安全性が重要です。必ずクライアントの本人確認を必要とします; これが認証です。通常、本人確認はパスワードを使って行います。パスワードは人目に触れさせてはいけません。さもなくば、他のクライアントがパスワードを取得できてしまいます。これが暗号化の目的です。暗号化は符号化の形をしています。暗号化することで、2 つのシステムが公衆回線を使って秘密の情報を他人に読まれないように保護した状態でやり取りすることが可能になります。
			</div><div
              class="para">
				認証と暗号化はしばしば一緒に言及されます。なぜなら両者は同時に使われることが多く、よく似たの数学的概念を基に実行されることが多いからです。
			</div></div><div
            class="para">
				さらに SSH は 2 種類のファイル転送サービスを提供します。<code
              class="command">scp</code> は <code
              class="command">cp</code> のように使えるコマンドラインツールです。ただし、他のマシンへのパスを表記するには、パスの前にそのマシンの名前とコロンを付ける点が異なります。
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp file machine:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> は対話的コマンドで <code
              class="command">ftp</code> に似ています。<code
              class="command">sftp</code> は単一のセッションの中で、複数のファイルを転送したり、リモートのファイルを操作 (削除、リネーム、パーミッション変更など) することが可能です。
			</div><a
            id="idm140296563554976"
            class="indexterm"></a><a
            id="idm140296563553856"
            class="indexterm"></a><div
            class="para">
				Debian は OpenSSH を使います。OpenSSH は SSH のフリー版で <code
              class="command">OpenBSD</code> (BSD カーネルに基づき、安全性を重要視するフリーオペレーティングシステム) によって保守されており、フィンランドの SSH Communications Security Corp 社が開発した元祖 SSH ソフトウェアのフォークです。SSH Communications Security Corp 社は当初 SSH をフリーソフトウェアとして開発していましたが、結局プロプライエタリライセンスで開発を続けることを決定しました。そして OpenBSD プロジェクトが SSH のフリー版として保守するために OpenSSH を作成しました。
			</div><a
            id="idm140296563551216"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">フォーク</em></span></strong></p></div></div></div><a
              id="idm140296563548816"
              class="indexterm"></a><div
              class="para">
				ソフトウェアの分野で「フォーク」とは、既存のプロジェクトのクローンとして始まった新しいプロジェクトを意味しており、既存のプロジェクトの対抗馬です。通常、両方のソフトウェアは新しい開発という観点ですぐに別のものになっていきます。フォークは開発チーム内の意見の不一致によって起こることが多いです。
			</div><div
              class="para">
				プロジェクトをフォークするという選択肢は、フリーソフトウェアの本質そのものから生じた、直接的な結果です; フリーソフトウェアとしてのプロジェクトの存続を可能にするための (たとえばライセンスが変更された場合などの) フォークは健全な出来事です。技術的および個人的な意見の不一致によって起こるフォークは通常人的資源の無駄です; 別の解決策が望まれます。以前にフォークした 2 つのプロジェクトの合併は未だ前例がありません。
			</div></div><div
            class="para">
				OpenSSH は 2 つのパッケージに分解されています: クライアント部分は <span
              class="pkg pkg">openssh-client</span> パッケージ、サーバ部分は <span
              class="pkg pkg">openssh-server</span> パッケージです。<span
              class="pkg pkg">ssh</span> メタパッケージは両方のパッケージに依存し、両方のインストールが簡単に (<code
              class="command">apt-get install ssh</code>) なります。
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. 鍵認証方式</h4></div></div></div><div
              class="para">
					リモートサーバはユーザを認証するために SSH でログインする人に対して毎回パスワードを尋ねます。これは、接続を自動化したい場合や SSH 経由で頻繁に接続を行うツールを使う場合に問題です。このため、SSH は鍵認証システムを提供しています。
				</div><div
              class="para">
					ユーザはクライアントマシンで <code
                class="command">ssh-keygen -t rsa</code> を使って鍵ペアを生成します; 公開鍵は <code
                class="filename">~/.ssh/id_rsa.pub</code> に保存され、一方で対応する秘密鍵は <code
                class="filename">~/.ssh/id_rsa</code> に保存されます。その後ユーザは <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> を使って、自分の公開鍵をサーバの <code
                class="filename">~/.ssh/authorized_keys</code> ファイルに追加します。秘密鍵を生成した際に「パスフレーズ」で保護しなかった場合、公開鍵を登録したサーバに対する以降すべてのログインでパスワードは不要です。そうでなければ、秘密鍵を使う際は毎回パスフレーズを入力して復号化しなければいけません。幸いなことに、<code
                class="command">ssh-agent</code> を使えば秘密鍵がメモリ内に保存され、パスワードを日常的に再入力しなくても良くなります。これを実現するには、セッションが既に機能する<code
                class="command">ssh-agent</code> のインスタンスに関連付けられている条件下で、単純に (作業セッション毎に 1 回) <code
                class="command">ssh-add</code> を使ってください。Debian はグラフィカルセッションではデフォルトでこれを有効化しますが、<code
                class="filename">/etc/X11/Xsession.options</code> を変更すれば無効化することも可能です。コンソールセッションでは、<code
                class="command">eval $(ssh-agent)</code> を使って手作業で開始できます。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SECURITY</em></span> 秘密鍵の保護</strong></p></div></div></div><div
                class="para">
					秘密鍵を持つものは誰でも、対応する公開鍵を登録したアカウントにログインすることが可能です。このため、秘密鍵の利用は「パスフレーズ」で保護されています。秘密鍵ファイル (たとえば <code
                  class="filename">~/.ssh/id_rsa</code>) のコピーを不正に入手した人が秘密鍵を使うためには、パスフレーズを知らなければいけません。しかしながら、この追加的な保護は堅固ではありません。秘密鍵ファイルが不正に使われていると感じた場合、その秘密鍵に対応する公開鍵をインストールしたコンピュータでその公開鍵を使わないで (<code
                  class="filename">authorized_keys</code> ファイルから公開鍵を削除して)、新しく生成した鍵で公開鍵を置き換えるのが最良です。
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Debian <span
                          class="distribution distribution">Etch</span> における OpenSSL の脆弱性</strong></p></div></div></div><div
                class="para">
					当初 Debian <span
                  class="distribution distribution">Etch</span> から配布されていた OpenSSL ライブラリは乱数発生器 (RNG) に深刻な問題がありました。具体的には、Debian メンテナによって、メモリテストツール <code
                  class="command">valgrind</code> で OpenSSL ライブラリを使うアプリケーションを解析した際に警告を出さなくなるような、変更が行われました。不幸なことに、この変更により RNG はエントロピーのソースを 1 つしか使わなくなりました。ここで使われたエントロピーソースはプロセス番号 (PID) に相当するもので、PID の取りうる値は 32,000 程度しかないため PID をソースとして用いても十分な乱数度は得られません。<div
                  class="url">→ <a
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					具体的に言えば、OpenSSL を使って鍵を生成した場合、生成された鍵は常に数十万 (32,000 かける鍵長種数) の既知の範囲内に有る鍵の内の 1 つになります。この脆弱性は、たとえば OpenVPN など数多くのアプリケーションが使う SSH 鍵、SSL 鍵、X.509 証明書に、影響を与えました。クラッカーは、鍵を全種類試すだけで、不正にアクセスすることが可能でした。この問題の影響を減らす目的で、SSH デーモンは <span
                  class="pkg pkg">openssh-blacklist</span> と <span
                  class="pkg pkg">openssh-blacklist-extra</span> パッケージにリストされている問題の有る鍵を拒否するように変更されました。更に、<code
                  class="command">ssh-vulnkey</code> コマンドを使えば、システム内からこの脆弱性の影響を受けているかもしれない鍵を識別することが可能です。
				</div><div
                class="para">
					この出来事をいっそう詳しく調べると、これは OpenSSL プロジェクト内と Debian パッケージメンテナ双方にあった多数の (小さな) 問題の結果であるということが、明らかになります。OpenSSL のように広く使われるライブラリは - 修正せずとも - <code
                  class="command">valgrind</code> でテストした時に警告を出すべきではありません。更に、コード (特に RNG と同様に慎重な箇所) はこのような誤解を避ける目的で詳しい注釈を付けられるべきです。Debian 側について言えば、メンテナは OpenSSL 開発者から修正に対する検証を受けることを望んでいながら、修正の検証に必要なパッチを OpenSSL 開発者に提供することもせずに自分の修正について簡単に説明しただけで、Debian 内における自分の役割を口にすることもしませんでした。最終的に、メンテナンス上の選択は最適なものではありませんでした: 元のコードに対して行った修正は文書中で明らかにされず; すべての修正は Subversion リポジトリに効果的に保存されていましたが、最終的にすべての修正はソースパッケージの作成中に 1 つのパッチにまとめられました。
				</div><div
                class="para">
					このような状況下で、これと同様の出来事が繰り返されることを避けるための適切な矯正措置を見つけるのは難しいです。ここで覚えておくべき教訓は、Debian が上流開発ソフトウェアに対して導入したすべての変更は、正当化され、文書化され、可能であれば上流プロジェクトに提出され、広く公開されなければいけない、ということです。この視点から、新しいソースパッケージフォーマット (「3.0 (quilt)」) と Debian パッチ追跡システムが開発されました。<div
                  class="url">→ <a
                    href="http://patch-tracker.debian.org">http://patch-tracker.debian.org</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-x11"></a>9.2.1.2. リモートの X11 アプリケーションを使う</h4></div></div></div><div
              class="para">
					SSH プロトコルを使うと、グラフィカルデータ (「X11」セッション、Unix で最も広く使われているグラフィカルシステム) を転送することが可能です; そして、サーバはこれらのデータ専用の経路を開いたままにします。具体的に言うと、リモートで実行されたグラフィカルプログラムはローカル画面の X.org サーバ上に表示され、すべてのセッション (入力と表示) は安全です。この機能により、リモートアプリケーションがローカルシステムに干渉することになるため、この機能はデフォルトで無効化されています。この機能を有効化するには、サーバ設定ファイル (<code
                class="filename">/etc/ssh/sshd_config</code>) で <code
                class="literal">X11Forwarding yes</code> と指定してください。最後に、ユーザは <code
                class="command">ssh</code> コマンドラインに <code
                class="literal">-X</code> オプションを追加して、転送を要求しなければいけません。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. ポート転送を使った暗号化トンネルの作成</h4></div></div></div><a
              id="idm140296563513968"
              class="indexterm"></a><div
              class="para">
					<code
                class="literal">-R</code> と <code
                class="literal">-L</code> オプションを使うと、<code
                class="command">ssh</code> が 2 台のマシン間で「暗号化トンネル」を作成することが可能です。ローカル TCP ポート (傍注<a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>BACK TO BASICS</em></span> TCP/UDP</a>参照) をリモートのマシンに安全に転送したりその逆も可能です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> トンネル</strong></p></div></div></div><a
                id="idm140296563509408"
                class="indexterm"></a><a
                id="idm140296563507968"
                class="indexterm"></a><div
                class="para">
					インターネットとインターネットに接続されているほとんどの LAN はパケットモードで動作しており、接続モードで動作していません。これは、一方のコンピュータから他方のコンピュータに向かって送信されたパケットは、宛先への経路を見つけるために複数の中間ルータで止められることを意味しています。とは言っても、接続モードを模倣することも可能です。接続モードではストリームを普通の IP パケットの中にカプセル化します。これらのパケットは通常の経路を通過しますが、ストリームの宛先を変わりません。我々はこれを道路のトンネルにかけて「トンネル」と読んでいます。トンネルでは車両が入り口 (入力) から出口 (出力) まで交差点に遭遇することなくまっすぐ進むのに対し、見かけ上の経路は交差点や方向の変化を伴います。
				</div><div
                class="para">
					トンネルに暗号化機能を追加することが可能です: トンネルの中を流れるストリームは外から認識できませんが、トンネルの出口で復号化された形で返されます。
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 intermediary</code> は <em
                class="replaceable">intermediary</em> ホストと SSH セッションを確立し、ローカルの <code
                class="command">ssh</code> がローカルのポート 8000 番をリッスンします (<a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">図9.3「SSH を使ったローカルポートの転送」</a>参照)。 <em
                class="replaceable">intermediary</em> の <code
                class="command">ssh</code> は、ローカルのポート 8000 番を経由して接続が開始されたら、<em
                class="replaceable">intermediary</em> コンピュータから <em
                class="replaceable">server</em> のポート 25 番に接続し、ローカルから <em
                class="replaceable">server</em> への接続を中継します。
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:server:25 intermediary</code> は <em
                class="replaceable">intermediary</em> コンピュータとの SSH セッションを確立し、<em
                class="replaceable">intermediary</em> の <code
                class="command">ssh</code> が <em
                class="replaceable">intermediary</em> のポート 8000 番をリッスンします (<a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">図9.4「SSH を使ったリモートポートの転送」</a>参照)。ローカルの <code
                class="command">ssh</code> は、<em
                class="replaceable">intermediary</em> のポート 8000 番を経由して接続が開始されたら、ローカルマシンから <em
                class="replaceable">server</em> のポート 25 番に接続し、<em
                class="replaceable">intermediary</em> から <em
                class="replaceable">server</em> への接続を中継します。
				</div><div
              class="para">
					どちらの場合も <em
                class="replaceable">server</em> ホストのポート 25 番に対して、ローカルマシンと <em
                class="replaceable">intermediary</em> マシンの間に確立した SSH トンネルを通り抜けて、接続します。最初の例の場合、トンネルの入口はローカルのポート 8000 番で、データはまず<em
                class="replaceable">intermediary</em> マシンを目指し、その後に「公開」ネットワークを経由して <em
                class="replaceable">server</em> に向かいます。2 番目の例の場合、トンネルの入口と出口が逆になります; トンネルの入口は <em
                class="replaceable">intermediary</em> マシンのポート 8000 番で、出口はローカルホストにあります。出口から出たデータは <em
                class="replaceable">server</em> に向かいます。現実的な話をすると、ここで言うサーバは通常、ローカルマシンまたは <em
                class="replaceable">intermediary</em> です。このようにして SSH は端から端までの接続を保護します。
				</div><div
              class="figure"><a
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="SSH を使ったローカルポートの転送" /></div></div><p
                class="title"><strong>図9.3 SSH を使ったローカルポートの転送</strong></p></div><div
              class="figure"><a
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="SSH を使ったリモートポートの転送" /></div></div><p
                class="title"><strong>図9.4 SSH を使ったリモートポートの転送</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.remote-desktops"></a>9.2.2. リモートグラフィカルデスクトップの利用</h3></div></div></div><div
            class="para">
				VNC (Virtual Network Computing) を使うとグラフィカルデスクトップにリモートからアクセスすることが可能になります。
			</div><a
            id="idm140296563480256"
            class="indexterm"></a><a
            id="idm140296563479296"
            class="indexterm"></a><a
            id="idm140296563478368"
            class="indexterm"></a><a
            id="idm140296563476960"
            class="indexterm"></a><a
            id="idm140296563476032"
            class="indexterm"></a><div
            class="para">
				このツールは技術支援に使われることが多いです: 管理者はユーザが直面しているエラーを見ることが可能で、ユーザの側にいなくても正しい行動の仕方をユーザに示すことが可能です。
			</div><a
            id="idm140296563474304"
            class="indexterm"></a><a
            id="idm140296563472880"
            class="indexterm"></a><a
            id="idm140296563471456"
            class="indexterm"></a><div
            class="para">
				最初に、ユーザは自分のセッションの権限を共有しなければいけません。<span
              class="distribution distribution">Jessie</span> に含まれる GNOME グラフィカルデスクトップ環境の場合、設定パネル内にこれを行うオプションが含まれます (以前の Debian のバージョンではユーザが <code
              class="command">vino</code> をインストールして実行しなければいけませんでした)。KDE の場合まだ、既存のセッションを VNC を介して共有するには <code
              class="command">krfb</code> を使う必要があります。他のグラフィカルデスクトップ環境に対しては、<code
              class="command">x11vnc</code> コマンド (同名の Debian パッケージに含まれます) がその代わりになります; 明確なアイコンを使って、ユーザがこれを使えるようにすることが可能です。
			</div><a
            id="idm140296563466624"
            class="indexterm"></a><a
            id="idm140296561977360"
            class="indexterm"></a><a
            id="idm140296561975936"
            class="indexterm"></a><a
            id="idm140296561974512"
            class="indexterm"></a><div
            class="para">
				VNC がグラフィカルセッションを利用可能にしたら、管理者は VNC クライアントでセッションに接続しなければいけません。VNC クライアントとして、GNOME には <code
              class="command">vinagre</code> と <code
              class="command">remmina</code> が、KDE には <code
              class="command">krdc</code> (<span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>インターネット</strong></span> → <span
              class="guimenuitem"><strong>リモートデスクトップクライアント</strong></span>) が用意されています。コマンドラインを使う他の VNC クライアントもあります。たとえば、同名の Debian パッケージに含まれる <code
              class="command">xvnc4viewer</code> などです。一旦セッションに接続したら、管理者は、何が起きているか見て、リモートでマシンの作業を行い、ユーザにその様子を見せることが可能です。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SECURITY</em></span> VNC over SSH</strong></p></div></div></div><a
              id="idm140296561967280"
              class="indexterm"></a><div
              class="para">
				VNC で接続したいけれども、データを平文でネットワークに流したくない場合、SSH トンネルでデータをカプセル化することが可能です (<a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">「ポート転送を使った暗号化トンネルの作成」</a>参照)。知っておかなければいけない点は、VNC がデフォルトで最初の画面 (「localhost:0」と呼ばれる) にポート 5900 番、2 番目の画面に (「localhost:1」と呼ばれる) 5901 番を使うという点だけです。
			</div><div
              class="para">
				<code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">machine</em></code> コマンドは localhost インターフェースのポート 5901 番と<em
                class="replaceable">machine</em> ホストのポート 5900 番の間にトンネルを作成します。最初の「localhost」はローカルマシンのインターフェースのみをリッスンするように SSH を制限します。2 番目の「localhost」は「localhost:5901」に入ってきたネットワークトラフィックを受け取るリモートマシンのインターフェースを表します。そんな訳で、<code
                class="command">vncviewer localhost:1</code> はローカルマシンの名前を使っているにも関わらず VNC クライアントをリモートのスクリーンに接続します。
			</div><div
              class="para">
				VNC セッションを閉じたら、対応する SSH セッションを終了してトンネルを閉じることも忘れないで下さい。
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> ディスプレイマネージャ</strong></p></div></div></div><a
              id="idm140296561959776"
              class="indexterm"></a><a
              id="idm140296561958656"
              class="indexterm"></a><a
              id="idm140296561957536"
              class="indexterm"></a><a
              id="idm140296561956416"
              class="indexterm"></a><a
              id="idm140296561955296"
              class="indexterm"></a><a
              id="idm140296561953888"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>、<code
                class="command">kdm</code>、<code
                class="command">lightdm</code>、<code
                class="command">xdm</code> はディスプレイマネージャです。ディスプレイマネージャは起動直後にログイン画面をユーザに提供する目的でグラフィカルインターフェースを制御します。ユーザがログインしたら、ディスプレイマネージャはグラフィカル作業セッションを始めるために必要なプログラムを実行します。
			</div></div><div
            class="para">
				また VNC は、モバイルユーザや会社幹部のような、自分が仕事場で使っているのとよく似たリモートデスクトップにアクセスするために時々自分の家からログインする必要があるユーザにとって、都合が良いものです。そのようなサービス用の設定はより複雑です: ユーザは、最初に <span
              class="pkg pkg">vnc4server</span> パッケージをインストールし、<code
              class="literal">XDMCP Query</code> 要求を受け入れるようにディスプレイマネージャの設定を変更 (<code
              class="command">gdm3</code> の場合、<code
              class="filename">/etc/gdm3/daemon.conf</code> の「xdmcp」セクションに <code
              class="literal">Enable=true</code> を追加) し、そして最後に <code
              class="command">inetd</code> を使って VNC サーバを起動します。こうすることで、ユーザがログインを試行したらセッションが自動的に開始されるようになります。たとえば、以下の行を <code
              class="filename">/etc/inetd.conf</code> に追加します:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				入ってくる接続をディスプレイマネージャに転送することにより、認証の問題が解決されます。なぜなら、ローカルアカウントを持つユーザだけが <code
              class="command">gdm3</code> (または同等の <code
              class="command">kdm</code>、<code
              class="command">xdm</code> など) のログイン画面を突破できるからです。このやり方は (サーバの性能が十分高いなら) なんの問題もなく複数の同時ログインを許すため、完全なデスクトップをモバイルユーザに対して (またはシンクライアントとして設定された非力なデスクトップシステムに対して) 提供するという用途にも応用できます。ユーザは単純に <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code> でサーバの画面にログインするだけです。なぜなら、使われているポートは 5950 番だからです。
			</div><a
            id="idm140296561941264"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>戻る</strong>第9章 Unix サービス</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>次へ</strong>9.3. 権限の管理</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.remote-login.html">ar-MA</a></li><li><a
              href="../da-DK/sect.remote-login.html">da-DK</a></li><li><a
              href="../de-DE/sect.remote-login.html">de-DE</a></li><li><a
              href="../el-GR/sect.remote-login.html">el-GR</a></li><li><a
              href="../en-US/sect.remote-login.html">en-US</a></li><li><a
              href="../es-ES/sect.remote-login.html">es-ES</a></li><li><a
              href="../fa-IR/sect.remote-login.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.remote-login.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.remote-login.html">hr-HR</a></li><li><a
              href="../id-ID/sect.remote-login.html">id-ID</a></li><li><a
              href="../it-IT/sect.remote-login.html">it-IT</a></li><li><a
              href="../ja-JP/sect.remote-login.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.remote-login.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.remote-login.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.remote-login.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.remote-login.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.remote-login.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.remote-login.html">zh-CN</a></li></ul></div></body></html>
