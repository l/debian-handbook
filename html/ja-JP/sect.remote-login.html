<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. リモートログイン</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="システム起動, 初期化スクリプト, SSH, Telnet, 権限, パーミッション, 管理, inetd, cron, バックアップ, ホットプラグ, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="unix-services.html"
        title="第 9 章 Unix サービス" /><link
        rel="prev"
        href="unix-services.html"
        title="第 9 章 Unix サービス" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. 権限の管理" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ja-JP/sect.remote-login.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.remote-login"></a>9.2. リモートログイン</h2></div></div></div><div
          class="para">
			管理者にとってコンピュータにリモートから接続できることは不可欠な要素です。専用の部屋に閉じ込められているサーバにキーボードとモニタが常設されていることはめったにありません。しかしサーバはネットワークにつながっています。
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>BACK TO BASICS</em></span> クライアント、サーバ</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			複数のプロセスが互いに通信しているシステムはよく「クライアント/サーバ」に例えられます。サーバはクライアントからの要求に応じて、その要求を実行するプログラムです。操作を制御するのがクライアントで、サーバは制御の主導権を握りません。
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ssh"></a>9.2.1. 安全なリモートログイン、SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>SSH</em></span> (Secure SHell) プロトコルは安全性と信頼性を念頭に置いて設計されました。SSH を使う接続は安全です。つまり、通信相手は認証され、交換されるデータはすべて暗号化されます。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> Telnet と RSH は時代遅れです</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				SSH 以前、<span
                class="emphasis"><em>Telnet</em></span> と <span
                class="emphasis"><em>RSH</em></span> がリモートからログインするために使われる主なツールでした。両者は今や大幅に時代遅れです。両者がまだ Debian から配布されているとしても、もはやそれを使うべきではありません。
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULARY</em></span> 認証、暗号化</strong></p></div></div></div><div
              class="para">
				クライアントに対してサーバ上で作業を実行したり作業を自動的に開始したりすることを許可する必要がある場合、安全性が重要です。クライアントは必ず本人であることを確認されなければいけません。これが認証です。通常、本人確認はパスワードを使って行います。パスワードは人目に触れさせてはいけません。そうでなければ、他のクライアントがパスワードを取得できてしまうからです。これが暗号化の目的です。暗号化は符号化の形をしています。暗号化することで、2 つのシステムが公衆回線を使って秘密の情報を他人に読まれないように保護した状態でやり取りすることが可能になります。
			</div><div
              class="para">
				認証と暗号化はしばしば一緒に言及されます。なぜなら両者は同時に使われることが多く、よく似た数学的概念を基に実行されることが多いからです。
			</div></div><div
            class="para">
				さらに SSH は 2 種類のファイル転送サービスを提供します。<code
              class="command">scp</code> は <code
              class="command">cp</code> のように使えるコマンドラインツールです。ただし、他のマシンへのパスを表記するにはパスの前にそのマシンの名前とコロンを付ける点が <code
              class="command">cp</code> と異なります。
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp file machine:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> は対話型コマンドで <code
              class="command">ftp</code> に似ています。<code
              class="command">sftp</code> は単一のセッションの中で複数のファイルを転送したり、リモートのファイルを操作 (削除、リネーム、パーミッション変更など) したりすることが可能です。
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				Debian は OpenSSH を使います。OpenSSH は SSH のフリー版で <code
              class="command">OpenBSD</code> (BSD カーネルに基づき、安全性を重要視するフリーオペレーティングシステム) プロジェクトによってメンテナンスされており、フィンランドの SSH Communications Security Corp が開発した元祖 SSH ソフトウェアのフォークです。SSH Communications Security Corp は当初 SSH をフリーソフトウェアとして開発していましたが、結局プロプライエタリライセンスで開発を続けることを決定しました。そして OpenBSD プロジェクトが SSH のフリー版としてメンテナンスするために OpenSSH を作成しました。
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">フォーク</em></span></strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				ソフトウェアの分野で「フォーク」とは、既存のプロジェクトのクローンとして始まった新しいプロジェクトを意味しており、既存のプロジェクトの対抗馬です。通常、両方のソフトウェアは新しい開発という観点ですぐに別のものになっていきます。フォークは開発チーム内の意見の不一致によって起こることが多いです。
			</div><div
              class="para">
				プロジェクトをフォークするという選択肢はフリーソフトウェアの本質そのものから生じた直接的な結果です。フリーソフトウェアとしてのプロジェクトの存続を可能にするための (たとえばライセンスが変更された場合などの) フォークは健全な出来事です。技術的および個人的な意見の不一致によって起こるフォークは通常人的資源の無駄です。従って別の解決策が望まれます。過去にフォークした 2 つのプロジェクトの合併はいまだ前例がありません。
			</div></div><div
            class="para">
				OpenSSH は 2 つのパッケージに分割されています。すなわち、クライアント部分は <span
              class="pkg pkg">openssh-client</span> パッケージ、サーバ部分は <span
              class="pkg pkg">openssh-server</span> パッケージに分割されています。<span
              class="pkg pkg">ssh</span> メタパッケージは両方のパッケージに依存しており、これを使えば両方のインストールが簡単になります (<code
              class="command">apt install ssh</code> だけでクライアントとサーバの両方がインストールされます)。
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. 鍵認証方式</h4></div></div></div><div
              class="para">
					リモートサーバはユーザを認証するために SSH でログインする人に対して毎回パスワードを尋ねます。これは、接続を自動化したい場合や SSH 経由で頻繁に接続を行うツールを使う場合に問題です。このため、SSH は鍵認証システムを提供しています。
				</div><div
              class="para">
					ユーザはクライアントマシンで <code
                class="command">ssh-keygen -t rsa</code> を使って鍵ペアを生成します。この時公開鍵は <code
                class="filename">~/.ssh/id_rsa.pub</code> に保存され、一方で公開鍵に対応する秘密鍵は <code
                class="filename">~/.ssh/id_rsa</code> に保存されます。その後ユーザは <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> を使って、自分の公開鍵をサーバの <code
                class="filename">~/.ssh/authorized_keys</code> ファイルに追加登録します。秘密鍵を生成した際に「パスフレーズ」で保護しなかった場合、公開鍵を登録したサーバに対する以降すべてのログインでパスワードは不要です。そうでなければ、秘密鍵を使う際は毎回パスフレーズを入力して秘密鍵を復号化しなければいけません。幸いにも、<code
                class="command">ssh-agent</code> を使えば復号化された秘密鍵がメモリ内に保存され、パスワードをきちんと再入力する必要がなくなります。これを実現するには、セッションが既に機能する <code
                class="command">ssh-agent</code> のインスタンスに関連付けられている条件下で、単純に (作業セッションごとに 1 回) <code
                class="command">ssh-add</code> を使ってください。Debian はグラフィカルセッションではデフォルトで <code
                class="command">ssh-agent</code> を有効化しますが、<code
                class="filename">/etc/X11/Xsession.options</code> を変更すれば無効化することも可能です。コンソールセッションでは手作業で <code
                class="command">eval $(ssh-agent)</code> を実行することで <code
                class="command">ssh-agent</code> を開始できます。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SECURITY</em></span> 秘密鍵の保護</strong></p></div></div></div><div
                class="para">
					秘密鍵を持っていれば、誰でも対応する公開鍵を登録したアカウントにログインすることが可能です。このため、秘密鍵の利用は「パスフレーズ」で保護されています。秘密鍵ファイル (たとえば <code
                  class="filename">~/.ssh/id_rsa</code>) のコピーを不正に入手した人が秘密鍵を使うためには、パスフレーズを知らなければいけません。しかしながら、「パスフレーズ」による追加的な保護は堅固なものではありません。秘密鍵ファイルが不正に使われていると感じたなら、その秘密鍵に対応する公開鍵をインストールしたコンピュータでその公開鍵の使用を停止し (<code
                  class="filename">authorized_keys</code> ファイルから公開鍵を削除し)、新しく生成した鍵で公開鍵を置き換えるのが最良の対応策です。
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Debian <span
                          class="distribution distribution">Etch</span> における OpenSSL の脆弱性</strong></p></div></div></div><div
                class="para">
					当初 Debian <span
                  class="distribution distribution">Etch</span> から配布されていた OpenSSL ライブラリは乱数発生器 (RNG) に深刻な問題がありました。はっきり言うと、Debian メンテナによって <code
                  class="command">valgrind</code> などのメモリテストツールで OpenSSL ライブラリを使うアプリケーションを解析した際に警告を出さなくなるような変更が行われました。不幸なことに、この変更により RNG はエントロピーソースを 1 つしか使わなくなりました。ここで使われたエントロピーソースはプロセス ID (PID) に相当するもので、PID の取りうる値は 32,000 程度しかないため PID をソースとして用いたことにより十分な乱数度が得られなくなりました。<div
                  class="url">→ <a
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					具体的に言えば、OpenSSL を使って鍵を生成した場合、生成された鍵は常に数十万 (鍵長種数の 32,000 倍) の既知の範囲内にある鍵のうちの 1 つになります。この脆弱性は、たとえば OpenVPN など数多くのアプリケーションが使う SSH 鍵、SSL 鍵、X.509 証明書に影響をおよぼしました。クラッカーは全種類の鍵を試すだけで不正アクセスを実行することが可能でした。この問題の影響を減らす目的で、SSH デーモンは <span
                  class="pkg pkg">openssh-blacklist</span> と <span
                  class="pkg pkg">openssh-blacklist-extra</span> パッケージにリストされている問題のある鍵を拒否するように変更されました。さらに、<code
                  class="command">ssh-vulnkey</code> コマンドを使えば、システム内からこの脆弱性の影響を受けているかもしれない鍵を識別することが可能です。
				</div><div
                class="para">
					この出来事をいっそう詳しく調べると、これは OpenSSL プロジェクト内と Debian パッケージメンテナ双方にあった多数の (小さな) 問題の結果であるということが、明らかになります。OpenSSL のように広く使われるライブラリは (修正せずとも) <code
                  class="command">valgrind</code> でテストした時に警告を出すべきではありません。さらに、コード (特に RNG と同様に慎重に取り扱われるべき部分) はこのような誤解を避ける目的で詳しい注釈を付けられるべきです。Debian 側について言えば、メンテナは OpenSSL 開発者から修正に対する検証を受けることを望んでいながら、修正の検証に必要なパッチを OpenSSL 開発者に提供することもせずに自分の修正について簡単に説明しただけで、Debian 内における自分の役割を口にすることもしませんでした。そして最後に、メンテナンス方針が最適なものではありませんでした。具体的に言えば、元のコードに対して行った修正が文書中で明らかにされず、さらにすべての修正は Subversion リポジトリに効果的に保存されていましたが、最終的にすべての修正はソースパッケージの作成中に 1 つのパッチにまとめられていました。
				</div><div
                class="para">
					このような状況下では、これと同様の出来事が繰り返されることを避けるための適切な矯正措置を見つけるのは難しいです。ここで覚えておくべき教訓は Debian が上流開発ソフトウェアに対して導入したすべての変更は正当化され、文書化され、可能であれば上流プロジェクトに提出され、広く公開されなければいけないということです。この視点から、新しいソースパッケージフォーマット (「3.0 (quilt)」) と Debian ソースウェブサービスが開発されました。<div
                  class="url">→ <a
                    href="http://sources.debian.net">http://sources.debian.net</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-x11"></a>9.2.1.2. リモートの X11 アプリケーションを使う</h4></div></div></div><div
              class="para">
					SSH プロトコルを使うと、グラフィカルデータ (「X11」セッション、Unix で最も広く使われているグラフィカルシステム) を転送することが可能です。サーバはこれらのデータ専用の経路を開いたままにします。具体的に言うと、リモートで実行されたグラフィカルプログラムはローカル画面の X.org サーバ上に表示され、すべてのセッション (入力と表示) は保護されます。X11 転送機能によりリモートアプリケーションがローカルシステムに干渉することになるため、X11 転送機能はデフォルトで無効化されています。X11 転送機能を有効化するには、SSH サーバの設定ファイル (<code
                class="filename">/etc/ssh/sshd_config</code>) で <code
                class="literal">X11Forwarding yes</code> と指定してください。さらにユーザは <code
                class="command">ssh</code> コマンドラインに <code
                class="literal">-X</code> オプションを追加して転送を要求しなければいけません。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. ポート転送を使った暗号化トンネルの作成</h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">ssh</code> の <code
                class="literal">-R</code> と <code
                class="literal">-L</code> オプションを使うと、<code
                class="command">ssh</code> が 2 台のマシン間で「暗号化トンネル」を作成することが可能です。「暗号化トンネル」を使えば、ローカル TCP ポート (補注<a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp">「<span
                  class="emphasis"><em>BACK TO BASICS</em></span> TCP/UDP」</a>を参照してください) をリモートのマシンに安全に転送したりその逆を行うことも可能です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> トンネル</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					インターネットとインターネットに接続されているほとんどの LAN はパケットモードで動作しており、接続モードで動作していません。これは、一方のコンピュータから他方のコンピュータに向かって送信されたパケットは、宛先への経路を見つけるために複数の中間ルータで足止めされることを意味しています。とは言っても、接続モードを模倣することも可能です。接続モードではストリームを普通の IP パケットの中にカプセル化します。これらのパケットは通常の経路を通過しますが、ストリームは宛先を変えられることなく再構成されます。これは道路のトンネルにかけて「トンネル」と呼ばれています。道路のトンネルでは車両が入口 (入力) から出口 (出力) まで交差点に遭遇することなくまっすぐ進むのに対し、地上の経路を使うと車両は交差点を通過したり右折左折を繰り返しながら目的地まで進むことになります。
				</div><div
                class="para">
					トンネルに暗号化機能を追加することが可能です。すなわち、トンネルの中を流れるストリームは外から認識できませんが、トンネルの出口で復号化された形で返されます。
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 intermediary</code> を使うことで、ローカルの <code
                class="command">ssh</code> に <em
                class="replaceable">intermediary</em> との SSH セッションを確立させ、ローカルの <code
                class="command">ssh</code> にローカルのポート 8000 番をリッスンさせます (<a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">図 9.3「SSH を使ったローカルポートの転送」</a>を参照してください)。ローカルのポート 8000 番を経由して接続が開始されたら、<em
                class="replaceable">intermediary</em> の <code
                class="command">ssh</code> は <em
                class="replaceable">intermediary</em> から <em
                class="replaceable">server</em> のポート 25 番に接続し、ローカルから <em
                class="replaceable">server</em> への接続を中継します。
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:server:25 intermediary</code> を使うことで、ローカルの <code
                class="command">ssh</code> に <em
                class="replaceable">intermediary</em> との SSH セッションを確立させ、<em
                class="replaceable">intermediary</em> の <code
                class="command">ssh</code> に <em
                class="replaceable">intermediary</em> のポート 8000 番をリッスンさせます (<a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">図 9.4「SSH を使ったリモートポートの転送」</a>を参照してください)。<em
                class="replaceable">intermediary</em> のポート 8000 番を経由して接続が開始されたら、ローカルの <code
                class="command">ssh</code> はローカルから <em
                class="replaceable">server</em> のポート 25 番に接続し、<em
                class="replaceable">intermediary</em> から <em
                class="replaceable">server</em> への接続を中継します。
				</div><div
              class="para">
					どちらの場合も、ローカルと <em
                class="replaceable">intermediary</em> の間に確立した SSH トンネルを介して、<em
                class="replaceable">server</em> のポート 25 番に接続します。最初の例の場合、トンネルの入口はローカルのポート 8000 番で、データはまず <em
                class="replaceable">intermediary</em> を目指し、その後に「公開」ネットワークを経由して <em
                class="replaceable">server</em> に向かいます。2 番目の例の場合、トンネルの入口と出口が逆になります。トンネルの入口は <em
                class="replaceable">intermediary</em> のポート 8000 番で、出口はローカルにあります。出口から出たデータは <em
                class="replaceable">server</em> に向かいます。現実的な話をすると、ここで使われている <em
                class="replaceable">server</em> にはローカルまたは <em
                class="replaceable">intermediary</em> を指定することが多いです。このようにして SSH は端から端までの接続を保護します。
				</div><div
              class="figure"><a
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="SSH を使ったローカルポートの転送" /></div></div><p
                class="title"><strong>図 9.3 SSH を使ったローカルポートの転送</strong></p></div><div
              class="figure"><a
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="SSH を使ったリモートポートの転送" /></div></div><p
                class="title"><strong>図 9.4 SSH を使ったリモートポートの転送</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.remote-desktops"></a>9.2.2. リモートグラフィカルデスクトップの利用</h3></div></div></div><div
            class="para">
				VNC (Virtual Network Computing) を使うとグラフィカルデスクトップにリモートからアクセスすることが可能になります。
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				VNC は技術支援に使われることが多いです。なぜなら、管理者はユーザが直面しているエラーを見ることが可能で、ユーザの側にいなくても正しい行動の仕方をユーザに示すことが可能だからです。
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				リモートデスクトップを使うには、最初にユーザが自分のセッションを共有することを認可しなければいけません。<span
              class="distribution distribution">Jessie</span> に含まれる GNOME グラフィカルデスクトップ環境の場合、設定パネル内にこれを行うオプションが含まれています (以前の Debian のバージョンではユーザが <code
              class="command">vino</code> をインストールして実行しなければいけませんでした)。KDE の場合、既存のセッションを VNC を介して共有するには <code
              class="command">krfb</code> を使う必要があります。他のグラフィカルデスクトップ環境の場合、<code
              class="command">x11vnc</code> コマンド (同名の Debian パッケージに含まれます) を使います。さらに、管理者はわかりやすいアイコンを作ってユーザが <code
              class="command">x11vnc</code> を実行できるようにすることが可能です。
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				VNC がグラフィカルセッションを利用できるようにしたら、管理者は VNC クライアントでセッションに接続しなければいけません。VNC クライアントとして、GNOME には <code
              class="command">vinagre</code> と <code
              class="command">remmina</code> が、KDE には <code
              class="command">krdc</code> (<span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>インターネット</strong></span> → <span
              class="guimenuitem"><strong>リモートデスクトップクライアント</strong></span>) が用意されています。コマンドラインを使う他の VNC クライアントもあります。たとえば、<code
              class="command">xvnc4viewer</code> (同名の Debian パッケージに含まれます) などです。ひとたびセッションに接続したら、管理者は何が起きているか確認し、リモートでマシンの作業を行い、ユーザにその様子を見せることが可能です。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SECURITY</em></span> VNC over SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				VNC で接続したいけれども、データを平文でネットワークに流したくない場合、SSH トンネルでデータをカプセル化することが可能です (<a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">第 9.2.1.3 節「ポート転送を使った暗号化トンネルの作成」</a>を参照してください)。この時知っておかなければいけない点は、デフォルトで VNC は最初の画面 (「localhost:0」と呼ばれます) にポート 5900 番、2 番目の画面 (「localhost:1」と呼ばれます) にポート 5901 番を使うという点だけです。
			</div><div
              class="para">
				<code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">machine</em></code> コマンドを使うことで、localhost インターフェースのポート 5901 番と <em
                class="replaceable">machine</em> のポート 5900 番の間にトンネルが作られます。最初の「localhost」はローカルのインターフェースのみをリッスンするように SSH を制限します。2 番目の「localhost」は「localhost:5901」に入ってきたネットワークトラフィックを受け取るリモート側のインターフェースを表します。そんなわけで、<code
                class="command">vncviewer localhost:1</code> はローカルの名前を使っているにも関わらず VNC クライアントをリモートの画面に接続します。
			</div><div
              class="para">
				VNC セッションを閉じたら、対応する SSH セッションを終了してトンネルを閉じることも忘れないでください。
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> ディスプレイマネージャ</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>、<code
                class="command">kdm</code>、<code
                class="command">lightdm</code>、<code
                class="command">xdm</code> はディスプレイマネージャです。ディスプレイマネージャは起動直後にログイン画面をユーザに提供する目的でグラフィカルインターフェースを制御します。ユーザがログインしたら、ディスプレイマネージャはグラフィカルの作業セッションを始めるために必要なプログラムを実行します。
			</div></div><div
            class="para">
				また、モバイルユーザや会社幹部のような自分が仕事場で使っているのとよく似たリモートデスクトップにアクセスするために時々自宅からログインする必要があるユーザにとって、VNC は都合の良いものです。そのようなサービス用の設定はより複雑です。具体的に言えば、管理者は最初に <span
              class="pkg pkg">vnc4server</span> パッケージをインストールし、<code
              class="literal">XDMCP Query</code> 要求を受け入れるようにディスプレイマネージャの設定を変更し (<code
              class="command">gdm3</code> の場合、<code
              class="filename">/etc/gdm3/daemon.conf</code> の「xdmcp」セクションに <code
              class="literal">Enable=true</code> を追加し)、そして最後に <code
              class="command">inetd</code> を使って VNC サーバを起動するように設定します。こうすることで、ユーザがログインを試行したらセッションが自動的に開始されるようになります。たとえば、以下の行を <code
              class="filename">/etc/inetd.conf</code> に追加します。
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				入ってくる接続をディスプレイマネージャに転送することにより、認証の問題が解決されます。なぜなら、ローカルアカウントを持つユーザだけが <code
              class="command">gdm3</code> (または同等の <code
              class="command">kdm</code>、<code
              class="command">xdm</code> など) のログイン画面を突破できるからです。このやり方は (サーバの性能が十分高いなら) なんの問題もなく複数の同時ログインを許すため、完全なデスクトップをモバイルユーザに対して (またはシンクライアントとして設定された非力なデスクトップシステムに対して) 提供するという用途にも応用できます。ユーザは単純に <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code> でサーバの画面にログインするだけです。なぜなら、使われているポートは 5950 番だからです。
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>戻る</strong>第 9 章 Unix サービス</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>次へ</strong>9.3. 権限の管理</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.remote-login.html">ar-MA</a></li><li><a
              href="../da-DK/sect.remote-login.html">da-DK</a></li><li><a
              href="../de-DE/sect.remote-login.html">de-DE</a></li><li><a
              href="../el-GR/sect.remote-login.html">el-GR</a></li><li><a
              href="../en-US/sect.remote-login.html">en-US</a></li><li><a
              href="../es-ES/sect.remote-login.html">es-ES</a></li><li><a
              href="../fa-IR/sect.remote-login.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.remote-login.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.remote-login.html">hr-HR</a></li><li><a
              href="../id-ID/sect.remote-login.html">id-ID</a></li><li><a
              href="../it-IT/sect.remote-login.html">it-IT</a></li><li><a
              href="../ja-JP/sect.remote-login.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.remote-login.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.remote-login.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.remote-login.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.remote-login.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.remote-login.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.remote-login.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.remote-login.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.remote-login.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.remote-login.html">zh-TW</a></li></ul></div></body></html>
