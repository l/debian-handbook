<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.9. その他の設定: 時刻同期、ログ、共有アクセス…</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-ja-JP-1.0-1" /><meta
        name="keywords"
        content="設定, 地域化, ロケール, ネットワーク, 名前解決, ユーザ, グループ, アカウント, コマンドラインインタプリタ, シェル, 印刷, ブートローダ, カーネルのコンパイル" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="basic-configuration.html"
        title="第 8 章 基本設定、ネットワーク、アカウント、印刷..." /><link
        rel="prev"
        href="sect.config-bootloader.html"
        title="8.8. ブートローダの設定" /><link
        rel="next"
        href="sect.kernel-compilation.html"
        title="8.10. カーネルのコンパイル" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ja-JP/sect.config-misc.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.config-misc"></a>8.9. その他の設定: 時刻同期、ログ、共有アクセス…</h2></div></div></div><div
          class="para">
			この節にリストされている多くの要素は、GNU/Linux システムの設定のあらゆる側面を極めたいと思う人なら誰でも、知っておくと良い知識です。しかしながらここでは、各要素を簡単に紹介し、頻繁に文書を参照するだけに留めます。
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.timezone"></a>8.9.1. タイムゾーン</h3></div></div></div><a
            id="id-1.11.13.3.2"
            class="indexterm"></a><div
            class="sidebar"><a
              id="sidebar.symbolic-link"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> シンボリックリンク</strong></p></div></div></div><a
              id="id-1.11.13.3.3.2"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.3"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.4"
              class="indexterm"></a><div
              class="para">
				シンボリックリンクは他のファイルへのポインタです。シンボリックリンクにアクセスすると、シンボリックリンクの指すファイルが開かれます。シンボリックリンクを削除しても、シンボリックリンクの指すファイルは削除されません。同様に、シンボリックリンクに対してパーミッションを設定することは不可能であり、シンボリックリンクはシンボリックリンクの指すファイルと同じパーミッションを持つとみなされます。最後に、シンボリックリンクはいかなる種類のファイルを指すことも可能です。具体的に言えば、ディレクトリ、スペシャルファイル (ソケット、名前付きパイプ、デバイスファイルなど)、さらには他のシンボリックリンクでさえ指すことが可能です。
			</div><div
              class="para">
				<code
                class="command">ln -s <em
                  class="replaceable">target</em> <em
                  class="replaceable">link-name</em></code> コマンドは <em
                class="replaceable">link-name</em> と名付けられ <em
                class="replaceable">target</em> を指すシンボリックリンクを作成します。
			</div><div
              class="para">
				シンボリックリンクのリンク先が存在しない場合リンクは「壊れて」おり、壊れたシンボリックリンクにアクセスするとリンク先のファイルが存在しないことを示すエラーが返されます。別のシンボリックリンクにシンボリックリンクを張るとシンボリックリンクが「連鎖」し、リンク先がリンク元を指していた場合にはリンクの「循環」状態になります。この状態で、循環鎖に含まれるリンクの 1 つにアクセスした場合、特定のエラー (「シンボリックリンクの階層が多すぎます」) が返されます。すなわちこれは、カーネルが何回か循環鎖を巡った後にそうすることを諦めたことを意味しています。
			</div></div><div
            class="para">
				タイムゾーンは初回インストール時に設定され、<span
              class="pkg pkg">tzdata</span> パッケージを使って設定されます。タイムゾーンを変更するには、<code
              class="command">dpkg-reconfigure tzdata</code> コマンドを使ってください。このコマンドを使えば、対話的に変更したいタイムゾーンを選ぶことが可能です。タイムゾーンの設定は <code
              class="filename">/etc/timezone</code> ファイルに保存されます。さらに、<code
              class="filename">/usr/share/zoneinfo</code> ディレクトリに含まれるタイムゾーンに対応するファイルが <code
              class="filename">/etc/localtime</code> の中にコピーされます。さらに <code
              class="filename">/etc/localtime</code> には、夏時間を使う国向けに夏時間が有効な場所で日付を処理するためのルールが含まれています。
			</div><a
            id="id-1.11.13.3.5"
            class="indexterm"></a><a
            id="id-1.11.13.3.6"
            class="indexterm"></a><a
            id="id-1.11.13.3.7"
            class="indexterm"></a><a
            id="id-1.11.13.3.8"
            class="indexterm"></a><a
            id="id-1.11.13.3.9"
            class="indexterm"></a><a
            id="id-1.11.13.3.10"
            class="indexterm"></a><div
            class="para">
				一時的にタイムゾーンを変更したい場合、<code
              class="varname">TZ</code> 環境変数を使ってください。<code
              class="varname">TZ</code> 環境変数に設定した値はシステムデフォルトで設定された値よりも優先されます。
			</div><a
            id="id-1.11.13.3.12"
            class="indexterm"></a><a
            id="screen.tz"></a><pre
            class="screen">
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>date</code></strong>
<code
              class="computeroutput">2015年  2月 19日 木曜日 19:25:18 JST</code>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>TZ="Pacific/Honolulu" date</code></strong>
<code
              class="computeroutput">2015年  2月 19日 木曜日 00:25:18 HST</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTE</em></span> システムクロック、ハードウェアクロック</strong></p></div></div></div><div
              class="para">
				コンピュータには 2 種類の時間ソースがあります。コンピュータのマザーボードには「CMOS クロック」と呼ばれるハードウェアクロックがあります。ハードウェアクロックは極めて正確なものというわけではありませんし、比較的アクセスに時間がかかります。また、オペレーティングシステムカーネルにはシステムクロック (ソフトウェアクロック) があります。システムクロックは独自の方法を使って最新の状態に保たれています (タイムサーバの助けを借りているかもしれません。<a
                class="xref"
                href="sect.config-misc.html#sect.time-synchronization">第 8.9.2 節「時刻同期」</a>をご覧ください)。システムクロックを使えば、CMOS クロックにアクセスする必要がないため、さらに正確な値を得られます。しかしながら、システムクロックは揮発性メモリの中にあるため、マシンが起動する際に毎回ゼロに設定されます。それに対して、CMOS クロックは電池を持っているので、マシンを再起動や停止しても値を「残す」ことが可能です。そんなわけで、システムクロックは起動中に CMOS クロックの値を使って設定され、CMOS クロックはシャットダウンの際に更新されます (CMOS クロックが不適切に調整されていた場合、変更または訂正された場合を考慮して更新します)。
			</div><div
              class="para">
				実際のところ、このやり方には問題があります。なぜなら、CMOS クロックは単なるカウンタに過ぎず、タイムゾーンに関する情報を持たないからです。CMOS クロックの値を解釈する際には選択の余地が残されています。すなわち、システムは CMOS クロックを協定世界時 (UTC、旧 GMT) またはローカル時間のどちらで解釈するかを選ばなければいけません。両者は単純な補正定数の違いに過ぎないように見えますが、しかし実際はより複雑な違いがあります。たとえば夏時間がある場合、この補正量は定数ではありません。その結果、特に夏時間が適用される期間中には、補正量の正しさを決定する術がありません。協定世界時とタイムゾーン情報からローカル時間を再構成することは常に可能ですから、CMOS クロックを協定世界時として扱うことを推奨します。
			</div><div
              class="para">
				不幸なことに、Windows システムのデフォルト設定はこの推奨に従いません。すなわち Windows システムは CMOS クロックをローカル時間に保ち、コンピュータの起動時には夏時間中の時間変更が既に適用されているか否かを推測して時間変更を適用します。マシン上で Windows だけが動いている場合、このやり方は比較的うまく動作します。しかしコンピュータに複数のシステムがある場合 (「デュアルブート」設定や仮想マシンを通じて他のシステムを動かす場合)、時間が正確か決定する方法は存在せず、時間設定はめちゃくちゃになります。どうしてもコンピュータに Windows を残さなければいけない場合、Windows を設定して CMOS クロックを UTC に保つ (<code
                class="literal">HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</code> レジストリキーを DWORD の「1」に設定する) か、Debian システムで <code
                class="command">hwclock --localtime --set</code> を使いハードウェアクロックをローカル時間に保つ (そして春と秋に手作業で時計を確認する) かのどちらか一方を設定してください。
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.time-synchronization"></a>8.9.2. 時刻同期</h3></div></div></div><a
            id="id-1.11.13.4.2"
            class="indexterm"></a><a
            id="id-1.11.13.4.3"
            class="indexterm"></a><div
            class="para">
				時刻同期は、コンピュータ上では不必要の操作のようにも見えますが、ネットワーク上では極めて重要です。ユーザは日付と時間を変更することを許可されていないので、混乱を防ぐためには時刻情報を正確に保つことがとても重要です。さらに、ネットワーク上のすべてのコンピュータの時刻を同期させておけば、異なるマシン間でログからの情報を相互参照しやすくなります。従って、攻撃を受けた際に不正アクセスを受けた複数のマシンで時系列順に操作を再構成することが簡単になります。時刻が同期されていなかった場合、統計目的で複数のマシンからデータを集めても、意味を成しません。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> NTP</strong></p></div></div></div><a
              id="id-1.11.13.4.5.2"
              class="indexterm"></a><a
              id="id-1.11.13.4.5.3"
              class="indexterm"></a><div
              class="para">
				NTP (Network Time Protocol) を使うことで、あるマシンが他のマシンとかなり正確に時刻同期することが可能になります。ここで正確とは NTP がネットワーク上で情報を移動することで起こる遅延および予想される補正を考慮しているという意味です。
			</div><div
              class="para">
				インターネット上には数多くの NTP サーバがありますが、よく知られている NTP サーバは混んでいるかもしれません。このため、NTP サーバには <span
                class="emphasis"><em>pool.ntp.org</em></span> を使うことを推奨します。実際のところ、<span
                class="emphasis"><em>pool.ntp.org</em></span> は公開 NTP サーバとしての機能を果たすことに同意したマシン群です。さらに、国を限定したサブグループに制限することが可能です。たとえば、アメリカ合衆国は <span
                class="emphasis"><em>us.pool.ntp.org</em></span>、日本は <span
                class="emphasis"><em>jp.pool.ntp.org</em></span> などです。
			</div><div
              class="para">
				しかしながら、巨大なネットワークを管理する場合、公開サーバに同期している自前の NTP サーバを用意することを推奨します。この場合、自分のネットワークに所属する他のマシンはすべて、公開サーバの負荷を増やす代わりに、内部の NTP サーバを使うことが可能です。さらにこうすることで時刻同期の均一性が高められます。なぜなら、すべてのマシンが同じ内部 NTP サーバを使って時刻同期しますし、公開 NTP サーバに比べて内部 NTP サーバのほうがネットワーク転送にかかる時間が短いからです。
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ntp-on-workstations"></a>8.9.2.1. ワークステーション向けの設定</h4></div></div></div><div
              class="para">
					ワークステーションは (エネルギーを節約するためだけだったとしても) 日常的に再起動されますから、NTP と同期するのは起動時だけで十分です。これを行うには、<span
                class="pkg pkg">ntpdate</span> パッケージをインストールします。必要なら <code
                class="filename">/etc/default/ntpdate</code> ファイルを変更して NTP サーバを変更することも可能です。
				</div><a
              id="id-1.11.13.4.6.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.6.4"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ntp-on-servers"></a>8.9.2.2. サーバ向けの設定</h4></div></div></div><div
              class="para">
					サーバはめったに再起動されませんし、サーバのシステム時間を正確にすることはとても重要です。恒久的に正確な時間を保つためには、<span
                class="pkg pkg">ntp</span> パッケージの提供する NTP サーバをローカルにインストールするべきです。デフォルトの設定では、NTP サーバは <span
                class="emphasis"><em>pool.ntp.org</em></span> と同期し、ローカルネットワークからの要求に対して時刻を提供します。<code
                class="filename">/etc/ntp.conf</code> ファイルを編集すれば NTP サーバを設定することも可能です。最も重大な影響をおよぼす設定項目は、この NTP サーバがどの NTP サーバを参照するかです。ネットワークに多くのサーバがある場合、公開 NTP サーバと同期するのは 1 台のローカルタイムサーバだけにして、そのローカルタイムサーバを他のサーバに対する時間ソースとして使ってみると良いかもしれません。
				</div><a
              id="id-1.11.13.4.7.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.4"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.5"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> GPS モジュールと他の時刻ソース</strong></p></div></div></div><a
                id="id-1.11.13.4.7.6.2"
                class="indexterm"></a><a
                id="id-1.11.13.4.7.6.3"
                class="indexterm"></a><div
                class="para">
					時刻同期がネットワークで決定的に重要な要素の場合、GPS モジュール (GPS 衛星からの時刻を使う) または DCF-77 モジュール (ドイツのフランクフルト近郊の原子時計と時刻を同期する) をサーバに装備することも可能です。この場合、NTP サーバの設定はもう少し複雑です。そのため必ず事前に文書を調査してください。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.rotation-logs"></a>8.9.3. ログファイルの循環</h3></div></div></div><a
            id="id-1.11.13.5.2"
            class="indexterm"></a><a
            id="id-1.11.13.5.3"
            class="indexterm"></a><a
            id="id-1.11.13.5.4"
            class="indexterm"></a><a
            id="id-1.11.13.5.5"
            class="indexterm"></a><div
            class="para">
				ログファイルのサイズは素早く増加しますから、ログファイルをアーカイブに保管することが必要です。これを実現する最も一般的なやり方はアーカイブを循環させることです。つまり、ログファイルは日常的にアーカイブに保管され、最新の <em
              class="replaceable">X</em> 個のアーカイブが保存されます。<code
              class="command">logrotate</code> はログファイルの循環を担当しているプログラムであり、<code
              class="filename">/etc/logrotate.conf</code> ファイルと <code
              class="filename">/etc/logrotate.d/</code> ディレクトリ内に含まれるすべてのファイルに書かれた指示に従います。管理者が Debian の定義するログ循環ポリシーを改変したい場合、これらの設定ファイルを変更するかもしれません。<span
              class="citerefentry"><span
                class="refentrytitle">logrotate</span>(1)</span> man ページでは、これらの設定ファイルで利用できるすべてのオプションが説明されています。ログ循環で保存されるファイルの数を増加させたかったり、削除せずにアーカイブ専用の特定のディレクトリにログファイルを移動させたいと思うかもしれません。また、電子メールでログを送信してログを別の場所にアーカイブすることも可能です。
			</div><div
            class="para">
				<code
              class="command">logrotate</code> プログラムは <code
              class="command">cron</code> スケジューリングプログラム (<a
              class="xref"
              href="sect.task-scheduling-cron-atd.html">第 9.7 節「<code
                class="command">cron</code> と <code
                class="command">atd</code> を使ったスケジューリングタスク」</a>で説明されています) によって毎日実行されます。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.sharing-admin-rights"></a>8.9.4. 管理者権限の共有</h3></div></div></div><a
            id="id-1.11.13.6.2"
            class="indexterm"></a><a
            id="id-1.11.13.6.3"
            class="indexterm"></a><a
            id="id-1.11.13.6.4"
            class="indexterm"></a><div
            class="para">
				しばしば、複数の管理者が同じネットワーク上で仕事をする場合があります。root パスワードの共有は的確なやり方ではありません。root パスワードを共有することでコマンドの実行者が隠匿されるため、root 権限を乱用される危険性が生まれます。この種の問題に対する解決策が <code
              class="command">sudo</code> プログラムです。<code
              class="command">sudo</code> プログラムは特定のユーザに特別な権限で特定のコマンドを実行することを可能にします。<code
              class="command">sudo</code> の最も一般的な用途として、信頼できるユーザが root 権限でコマンドを実行できるようにするという用途があります。これを行うには、ユーザは単純に <code
              class="command">sudo <em
                class="replaceable">command</em></code> を実行し、自分のパスワードを使って認証するだけです。
			</div><div
            class="para">
				<span
              class="pkg pkg">sudo</span> パッケージがインストールされると、<code
              class="literal">sudo</code> Unix グループのメンバーは完全な root 権限を与えられます。他の権利を委譲するには、管理者は <code
              class="command">visudo</code> コマンドを用いなければいけません。<code
              class="command">visudo</code> コマンドを使うことで、管理者は <code
              class="filename">/etc/sudoers</code> 設定ファイルを変更することが可能です (繰り返しになりますが、これは <code
              class="command">vi</code> エディタまたは <code
              class="varname">EDITOR</code> 環境変数で表されるその他のエディタを実行します)。<code
              class="literal"><em
                class="replaceable">username</em> ALL=(ALL) ALL</code> のような行を追加することで、指定されたユーザは root としてコマンドを実行することが可能になります。
			</div><a
            id="id-1.11.13.6.7"
            class="indexterm"></a><a
            id="id-1.11.13.6.8"
            class="indexterm"></a><a
            id="id-1.11.13.6.9"
            class="indexterm"></a><div
            class="para">
				より洗練された設定を使うことで、特定のコマンドに必要な権限を特定のユーザに与えることも可能です。設定できる要素のすべての詳細を確認するには <span
              class="citerefentry"><span
                class="refentrytitle">sudoers</span>(5)</span> man ページをご覧ください。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.fstab-mount-points"></a>8.9.5. マウントポイントのリスト</h3></div></div></div><a
            id="id-1.11.13.7.2"
            class="indexterm"></a><a
            id="id-1.11.13.7.3"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> マウントとアンマウント</strong></p></div></div></div><div
              class="para">
				Debian などの Unix 系システムでは、ファイルはディレクトリの単一樹状階層構造でまとめられています。<code
                class="filename">/</code> ディレクトリは「ルートディレクトリ」と呼ばれています。そして、すべての追加的なディレクトリはこのルートディレクトリの中のサブディレクトリです。「マウント」とは周辺機器デバイス (通常はハードドライブ) の内容をシステムの一般的なファイルツリーに含める操作です。結果として、ユーザの個人データを保存するために別のハードドライブを使う場合、このディスクは <code
                class="filename">/home/</code> ディレクトリに「マウント」されなければいけません。ルートファイルシステムはカーネルによって起動時に常にマウントされます。そして、他のデバイスはしばしばその後に続くスタートアップシーケンス中か <code
                class="command">mount</code> コマンドを使って手作業でマウントされます。
			</div><a
              id="id-1.11.13.7.4.3"
              class="indexterm"></a><div
              class="para">
				いくつかのリムーバブルデバイスは接続時に自動的にマウントされます。特に GNOME、KDE、その他のグラフィカルデスクトップ環境を使っている場合には自動的にマウントされます。他のデバイスについてはユーザが手作業でマウントしなければいけません。同様に、アンマウント (ファイルツリーから削除) も手動で行わなければいけません。普通のユーザは通常 <code
                class="command">mount</code> や <code
                class="command">umount</code> コマンドを実行する権限を持っていません。しかしながら、<code
                class="literal">user</code> オプションを <code
                class="filename">/etc/fstab</code> ファイルに含めることで、管理者はユーザに (マウントポイント別に) これらの操作を行う権限を与えることも可能です。
			</div><div
              class="para">
				<code
                class="command">mount</code> コマンドは引数なしで使うことも可能です (すべてのマウントされたファイルシステムを表示します)。デバイスをマウントおよびアンマウントする場合はパラメータが必要です。すべてのパラメータを見るには、対応する man ページである <span
                class="citerefentry"><span
                  class="refentrytitle">mount</span>(8)</span> と <span
                class="citerefentry"><span
                  class="refentrytitle">umount</span>(8)</span> を参照してください。単純なマウントの場合、構文もまた単純です。たとえば、ext3 ファイルシステムの <code
                class="filename">/dev/sdc1</code> パーティションを <code
                class="filename">/mnt/tmp/</code> ディレクトリにマウントするには、<code
                class="command">mount -t ext3 /dev/sdc1 /mnt/tmp/</code> のように実行してください。
			</div></div><div
            class="para">
				<code
              class="filename">/etc/fstab</code> ファイルには、起動時に自動マウントされるものやリムーバブルストレージデバイス用の手作業でマウントするものを含めて、すべての考え得るマウントポイントがリストされています。それぞれのマウントポイントは空白区切りフィールドを持つ各行によって表現されます。<a
              id="id-1.11.13.7.5.2"
              class="indexterm"></a><a
              id="id-1.11.13.7.5.3"
              class="indexterm"></a>
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						ファイルシステム。このフィールドではマウント元のファイルシステムのありかを指定します。ここにはローカルデバイス (ハードドライブパーティション、CD-ROM) またはリモートファイルシステム (NFS など) を指定します。
					</div><div
                  class="para">
						このフィールドではしばしば、<code
                    class="literal">UUID=</code> を前に付けたファイルシステムの一意的な ID が使われることがあります (ID は <code
                    class="command">blkid <strong
                      class="userinput"><code>device</code></strong></code> を使えばわかります)。一意的な ID を使うことで、ディスクを取り付けたり取り外したことや異なる順番でディスクが検出されたことによりデバイスの名前が変わっても問題がなくなります。
					</div></li><li
                class="listitem"><div
                  class="para">
						マウントポイント。このフィールドではデバイス、リモートシステム、パーティションがマウントされるローカルファイルシステムの場所を指定します。
					</div></li><li
                class="listitem"><div
                  class="para">
						ファイルシステムタイプ。このフィールドではマウントされたデバイスで使われているファイルシステムを定義します。<code
                    class="literal">ext4</code>、<code
                    class="literal">ext3</code>、<code
                    class="literal">vfat</code>、<code
                    class="literal">ntfs</code>、<code
                    class="literal">btrfs</code>、<code
                    class="literal">xfs</code> などがその例です。
					</div><div
                  class="sidebar"><div
                    class="titlepage"><div><div><p
                          class="title"><strong><span
                              class="emphasis"><em>BACK TO BASICS</em></span> NFS、ネットワークファイルシステム</strong></p></div></div></div><div
                    class="para">
						NFS はネットワークファイルシステムです。Linux の下では、NFS を使ってローカルファイルシステムにリモートファイルを含めることにより、リモートファイルへの透過的なアクセスが可能になります。
					</div></div><div
                  class="para">
						既知のファイルシステムの完全なリストは <span
                    class="citerefentry"><span
                      class="refentrytitle">mount</span>(8)</span> man ページに書かれています。<code
                    class="literal">swap</code> は swap パーティション専用の特殊値です。そして <code
                    class="literal">auto</code> は <code
                    class="command">mount</code> プログラムに自動的にファイルシステムを検出させるための特殊値です (この値はディスクリーダと USB メモリで特に便利です。なぜなら、機器ごとに異なるファイルシステムを使っている可能性があるからです)。
					</div></li><li
                class="listitem"><div
                  class="para">
						オプション。ファイルシステムごとに多くのオプションがあり、これらの値は <code
                    class="command">mount</code> man ページに書かれています。最もよく使われるものを以下に挙げます。
					</div><div
                  class="itemizedlist"><ul><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">rw</code> または <code
                          class="literal">ro</code>。これはデバイスが読み書き可能状態または読み取り専用でマウントされることを意味しています。
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">noauto</code>。これは起動時の自動マウントを無効化します。
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">nofail</code>。<code
                          class="literal">nofail</code> オプションを使えば、デバイスが見つからなかった場合にも起動処理が中断されなくなります。<code
                          class="literal">nofail</code> オプションを使うデバイスは起動中に取り外されている可能性のある外付けドライブ上のデバイスだけにしてください。なぜなら、<code
                          class="command">systemd</code> は起動処理を続行する前に自動的にマウントされなければならないすべてのマウントポイントが実際にマウントされていることを確認するからです。<code
                          class="literal">nofail</code> オプションは <code
                          class="literal">x-systemd.device-timeout=5s</code> オプションと併用することが可能であるという点に注意してください。両者を併用することで、<code
                          class="command">systemd</code> は 5 秒間だけデバイスを探索し、その後起動処理を続行するようになります (<span
                          class="citerefentry"><span
                            class="refentrytitle">systemd.mount</span>(5)</span> を参照してください)。
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">user</code>。<code
                          class="literal">user</code> オプションを使うことですべてのユーザが対象のファイルシステムをマウント可能になります (<code
                          class="literal">user</code> オプションを指定しなければ、マウントおよびアンマウント操作をできるのは root ユーザだけに限られます)。
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">defaults</code>。<code
                          class="literal">defaults</code> オプションを使うとデフォルトオプション群を指定したことになります。デフォルトオプション群とは <code
                          class="literal">rw</code>、<code
                          class="literal">suid</code>、<code
                          class="literal">dev</code>、<code
                          class="literal">exec</code>、<code
                          class="literal">auto</code>、<code
                          class="literal">nouser</code>、<code
                          class="literal">async</code> です。<code
                          class="literal">defaults</code> の後に <code
                          class="literal">nosuid</code>、<code
                          class="literal">nodev</code> などを付ければ、<code
                          class="literal">suid</code>、<code
                          class="literal">dev</code> をブロックし、これらのオプションを無効化することも可能です。<code
                          class="literal">user</code> オプションを追加すればこれが再有効化されます。なぜなら <code
                          class="literal">defaults</code> は <code
                          class="literal">nouser</code> を含むからです。
							</div></li></ul></div></li><li
                class="listitem"><div
                  class="para">
						ダンプ。このフィールドにはほぼ必ず <code
                    class="literal">0</code> を設定します。<code
                    class="literal">1</code> を設定した場合、<code
                    class="command">dump</code> ツールに対してこのパーティションにはバックアップされるデータが含まれることが伝えられます。
					</div></li><li
                class="listitem"><div
                  class="para">
						パス。このフィールドは起動時にファイルシステムの完全性がチェックされるか否かと、チェックが実行される順番を意味します。<code
                    class="literal">0</code> の場合、完全性はチェックされません。ルートファイルシステムに対しては <code
                    class="literal">1</code> を設定するべきです。他の恒久的なファイルシステムに対しては <code
                    class="literal">2</code> を設定するべきです。
					</div></li></ul></div><div
            class="example"><a
              id="example.fstab"></a><p
              class="title"><strong>例 8.6 <code
                  class="filename">/etc/fstab</code> ファイルの例</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# /etc/fstab: 固定ファイルシステムの情報。
#
# &lt;ファイルシステム&gt; &lt;マウントポイント&gt; &lt;タイプ&gt; &lt;オプション&gt; &lt;ダンプ&gt; &lt;チェック順&gt;
proc            /proc           proc    defaults        0       0
# インストール中に / は /dev/sda1 にありました
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# インストール中に swap は /dev/sda5 にありました
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</pre></div></div><div
            class="para">
				この例の最後のエントリはネットワークファイルシステム (NFS) を表しています。すなわち <span
              class="emphasis"><em>arrakis</em></span> サーバの <code
              class="filename">/shared/</code> ディレクトリがローカルマシンの <code
              class="filename">/shared/</code> にマウントされます。<code
              class="filename">/etc/fstab</code> ファイルのフォーマットは <span
              class="citerefentry"><span
                class="refentrytitle">fstab</span>(5)</span> man ページに書かれています。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> 自動マウント</strong></p></div></div></div><div
              class="para">
				systemd には自動マウントポイントを管理する機能があります。自動マウントポイントとは、ユーザが対象のマウントポイントに対するアクセスを試行した時点でその要求に応じて自動的にマウントされ、そのマウントポイントに対するアクセスするプロセスがなくなれば自動的にアンマウントされるマウントポイントのことです。
			</div><div
              class="para">
				systemd の殆どの概念と同じく、自動マウントポイントは専用のユニット (<code
                class="literal">.automount</code> サフィックスをつけます) で管理されます。正確な構文については <span
                class="citerefentry"><span
                  class="refentrytitle">systemd.automount</span>(5)</span> を確認してください。
			</div><a
              id="id-1.11.13.7.9.4"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.5"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.6"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.7"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.8"
              class="indexterm"></a><div
              class="para">
				他の自動マウントユーティリティも存在します。たとえば <span
                class="pkg pkg">autofs</span> パッケージに含まれる <code
                class="command">automount</code> または <span
                class="pkg pkg">am-utils</span> パッケージに含まれる <code
                class="command">amd</code> です。
			</div><div
              class="para">
				GNOME、KDE、その他のグラフィカルデスクトップ環境は <span
                class="emphasis"><em>udisks</em></span> と協調して、リムーバブルメディアが接続されたらそれを自動的にマウントします。
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.locate-updatedb"></a>8.9.6. <code
                    class="command">locate</code> と <code
                    class="command">updatedb</code></h3></div></div></div><a
            id="id-1.11.13.8.2"
            class="indexterm"></a><a
            id="id-1.11.13.8.3"
            class="indexterm"></a><a
            id="id-1.11.13.8.4"
            class="indexterm"></a><div
            class="para">
				<code
              class="command">locate</code> コマンドを使うと、名前の一部を知っているだけのファイルの場所を見つけ出すことが可能です。結果はほぼ一瞬で返されます。なぜなら <code
              class="command">locate</code> コマンドはシステムのファイルのすべての場所を保存するデータベースを参照しているからです。さらにこのデータベースは <code
              class="command">updatedb</code> コマンドを使って毎日更新されます。<code
              class="command">locate</code> コマンドには複数の実装があり、Debian は標準的なシステム向けに <span
              class="pkg pkg">mlocate</span> を選んでいます。
			</div><div
            class="para">
				<code
              class="command">mlocate</code> は賢明なので、システムのすべてのファイルについて知っているデータベースを使っている (なぜなら、<code
              class="command">mlocate</code> の <code
              class="command">updatedb</code> 実装は root 権限で実行されるからです) にも関わらず、コマンドを実行したユーザがアクセスできるファイルだけを返します。さらなる安全性のために、管理者は <code
              class="filename">/etc/updatedb.conf</code> の中で <code
              class="varname">PRUNEDPATHS</code> を使って、いくつかのディレクトリのインデックス化を避けることが可能です。
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>戻る</strong>8.8. ブートローダの設定</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>次へ</strong>8.10. カーネルのコンパイル</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.config-misc.html">ar-MA</a></li><li><a
              href="../da-DK/sect.config-misc.html">da-DK</a></li><li><a
              href="../de-DE/sect.config-misc.html">de-DE</a></li><li><a
              href="../el-GR/sect.config-misc.html">el-GR</a></li><li><a
              href="../en-US/sect.config-misc.html">en-US</a></li><li><a
              href="../es-ES/sect.config-misc.html">es-ES</a></li><li><a
              href="../fa-IR/sect.config-misc.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.config-misc.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.config-misc.html">hr-HR</a></li><li><a
              href="../id-ID/sect.config-misc.html">id-ID</a></li><li><a
              href="../it-IT/sect.config-misc.html">it-IT</a></li><li><a
              href="../ja-JP/sect.config-misc.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.config-misc.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.config-misc.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.config-misc.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.config-misc.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.config-misc.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.config-misc.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.config-misc.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.config-misc.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.config-misc.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.config-misc.html">zh-TW</a></li></ul></div></body></html>
