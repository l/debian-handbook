<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Anmelden aus der Ferne</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-de-DE-1.0-1" /><meta
        name="keywords"
        content="Systemstart, Initialisierungsskripten, SSH, Telnet, Rechte, Berechtigungen, Überwachung, Inetd, Cron, Datensicherung, Wechsel im laufenden Betrieb, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="unix-services.html"
        title="Kapitel 9. Unix-Dienste" /><link
        rel="prev"
        href="unix-services.html"
        title="Kapitel 9. Unix-Dienste" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Berechtigungen verwalten" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/de-DE/sect.remote-login.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.remote-login"></a>9.2. Anmelden aus der Ferne</h2></div></div></div><div
          class="para">
			Es ist für einen Administrator wichtig, sich aus der Ferne mit einem Rechner verbinden zu können. Server, die in ihrem eigenen Raum eingeschlossen sind, sind selten dauerhaft mit Tastaturen und Bildschirmen ausgestattet - aber sie sind mit dem Netzwerk verbunden.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Client, Server</strong></p></div></div></div><a
            id="idm139908629263808"
            class="indexterm"></a><a
            id="idm139908629262400"
            class="indexterm"></a><div
            class="para">
			Ein System, bei dem mehrere Prozesse miteinander kommunizieren. wird häufig mit dem bildlichen Ausdruck „Client-Server“ beschrieben. Der Server ist das Programm, das Anfragen vom Client entgegen nimmt und ausführt. Der Client steuert die Vorgänge, der Server tut nichts aus eigener Initiative.
		</div></div><a
          id="idm139908629260064"
          class="indexterm"></a><a
          id="idm139908629258624"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ssh"></a>9.2.1. Sicheres Anmelden aus der Ferne: SSH</h3></div></div></div><a
            id="idm139908629256640"
            class="indexterm"></a><a
            id="idm139908629255680"
            class="indexterm"></a><div
            class="para">
				Das <span
              class="emphasis"><em>SSH</em></span>-Protokoll (Secure SHell) wurden Sicherheit und Zuverlässigkeit bereits im Entwurf berücksichtigt. Verbindungen auf der Basis von SSH sind sicher: der Partner ist authentifiziert und jeglicher Datenverkehr erfolgt verschlüsselt.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KULTUR</em></span> Telnet und RSH sind veraltet</strong></p></div></div></div><a
              id="idm139908629252448"
              class="indexterm"></a><a
              id="idm139908629251328"
              class="indexterm"></a><div
              class="para">
				Vor SSH waren <span
                class="emphasis"><em>Telnet</em></span> und <span
                class="emphasis"><em>RSH</em></span> die wesentlichen Werkzeuge um sich aus der Ferne einzuloggen. Heute sind sie weitestgehend überflüssig und sollten nicht weiter benutzt werden, auch wenn Debian sie immer noch zur Verfügung stellt.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Authentifizierung, Verschlüsselung</strong></p></div></div></div><div
              class="para">
				Wenn Sie einem Client die Fähigkeit geben müssen, auf einem Server Aktionen auszuführen oder auszulösen, ist Sicherheit wichtig. Sie müssen die Identität des Clients sicherstellen; dies heißt Authentifizierung. Die Identität besteht normalerweise aus einem Passwort, das geheimzuhalten ist, da es sonst von jedem anderen Client erlangt werden könnte. Dies ist der Zweck von Verschlüsselung, einer Art der Codierung, die es zwei Systemen ermöglicht, vertrauliche Informationen über einen öffentlichen Kanal auszutauschen, ohne dabei für andere lesbar zu sein.
			</div><div
              class="para">
				Authentifizierung und Verschlüsselung werden häufig zusammen genannt, weil beide oft gleichzeitig benutzt werden, und weil sie gewöhnlich durch ähnliche mathematische Konzepte umgesetzt werden.
			</div></div><div
            class="para">
				SSH bietet auch zwei Dateiübertragungsdienste an. <code
              class="command">scp</code> ist ein Befehlszeilenprogramm, das wie <code
              class="command">cp</code> benutzt werden kann, nur dass jedem Pfad zu einem anderen Rechner der Name dieses Rechners gefolgt von einem Doppelpunkt vorangestellt wird.
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp file machine:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> ist ein interaktiver Befehl, ähnlich wie <code
              class="command">ftp</code>. In einer einzigen Sitzung kann <code
              class="command">sftp</code> mehrere Dateien übertragen, und es ist möglich, mit ihm Dateien auf einem entfernten Rechner zu bearbeiten (löschen, umbenennen, Berechtigungen ändern usw.).
			</div><a
            id="idm139908629240912"
            class="indexterm"></a><a
            id="idm139908629239792"
            class="indexterm"></a><div
            class="para">
				Debian verwendet OpenSSH, eine freie Version von SSH, die vom <code
              class="command">OpenBSD</code>-Projekt betreut wird (einem freien Betriebssystem, das auf dem BSD-Kernel aufbaut und seinen Schwerpunkt auf Sicherheit setzt), und eine Abspaltung der ursprünglich vom finnischen Unternehmen SSH Communications Security Corp. entwickelten SSH-Software. Dieses Unternehmen entwickelte SSH ursprünglich als freie Software, entschied sich jedoch schließlich, seine Entwicklung unter einer proprietären Lizenz fortzusetzen. Das OpenBSD-Projekt schuf daraufhin OpenSSH, um eine freie Version von SSH zu bewahren.
			</div><a
            id="idm139908629237168"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">Abspaltung</em></span></strong></p></div></div></div><a
              id="idm139908629234800"
              class="indexterm"></a><div
              class="para">
				Eine „Abspaltung“ im Softwarebereich ist ein neues Vorhaben, das als Klon eines bestehenden Vorhabens beginnt und mit ihm konkurriert. Von da an entwickeln sich beide Programme, was neue Entwicklungen angeht, gewöhnlich schnell auseinander. Eine Abspaltung ist häufig die Folge von Meinungsverschiedenheiten innerhalb des Entwicklungsteams.
			</div><div
              class="para">
				Die Option, ein Vorhaben abzuspalten, ist eine direkte Folge der Eigenart freier Software; eine Abspaltung ist ein heilsamer Vorgang, wenn sie die Fortführung eines Vorhabens als freie Software ermöglicht (zum Beispiel im Falle von Lizenzänderungen). Dagegen ist eine Abspaltung, die sich aus technischen oder persönlichen Meinungsverschiedenheiten ergibt, häufig eine Verschwendung menschlicher Ressourcen; eine andere Lösung wäre vorzuziehen. Auch der Zusammenschluss zweier Vorhaben, die früher durch eine Abspaltung gegangen sind, ist nicht gänzlich unbekannt.
			</div></div><div
            class="para">
				OpenSSH ist in zwei Pakete aufgeteilt: der Client-Teil befindet sich im Paket <span
              class="pkg pkg">openssh-client</span> und der Server-Teil im Paket <span
              class="pkg pkg">openssh-server</span>. Das Metapaket <span
              class="pkg pkg">ssh</span> ist von beiden Teilen abhängig und erleichtert die Installation beider (<code
              class="command">apt-get install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Schlüsselbasierte Authentifizierung</h4></div></div></div><div
              class="para">
					Jedes Mal, wenn sich jemand über SSH anmeldet, fragt der entfernte Server nach einem Passwort zur Authentifizierung des Benutzers. Dies kann problematisch sein, wenn man eine Verbindung automatisieren möchte, oder wenn man ein Hilfsprogramm verwendet, das häufige Verbindungen über SSH benötigt. Daher bietet SSH ein schlüsselbasiertes Authentifizierungssystem.
				</div><div
              class="para">
					Der Benutzer erzeugt auf dem Client-Rechner mit dem Befehl <code
                class="command">ssh-keygen -t rsa</code> ein neues Schlüsselpaar; der öffentliche Schlüssel wird in der Datei <code
                class="filename">~/.ssh/id_rsa.pub</code> gespeichert und der dazugehörige private Schlüssel in <code
                class="filename">~/.ssh/id_rsa</code>. Der Benutzer verwendet dann den Befehl <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code>, um seinen öffentlichen Schlüssel auf dem Server zur Datei <code
                class="filename">~/.ssh/authorized_keys</code> hinzuzufügen. Falls der private Schlüssel zur Zeit seiner Erzeugung nicht mit einer „Passphrase“ geschützt wurde, funktionieren alle nachfolgenden Anmeldungen auf dem Server ohne Eingabe eines Passworts. Anderenfalls muss der private Schlüssel jedes Mal erneut unter Eingabe der Passphrase entschlüsselt werden. Glücklicherweise ermöglicht es das Programm <code
                class="command">ssh-agent</code>, private Schlüssel im Speicher zu halten, so dass das Passwort nicht ständig neu eingegeben werden muss. Hierzu verwendet man einfach (einmal pro Sitzung) den Befehl <code
                class="command">ssh-add</code>, wobei Voraussetzung ist, dass die Sitzung bereits einer funktionsfähigen Instanz von <code
                class="command">ssh-agent</code> zugeordnet ist. Debian aktiviert dieses Programm standardmäßig beim Start einer grafischen Sitzung, es kann jedoch durch eine Änderung der Datei <code
                class="filename">/etc/X11/Xsession.options</code> deaktiviert sein. In einer Konsolensitzung kann es manuell mit dem Befehl <code
                class="command">eval $(ssh-agent)</code> gestartet werden.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SICHERHEIT</em></span> Schutz des privaten Schlüssels</strong></p></div></div></div><div
                class="para">
					Wer immer im Besitz des privaten Schlüssels ist, kann sich auf dem entsprechend konfigurierten Konto anmelden. Daher ist der Zugriff auf den privaten Schlüssel durch eine „Passphrase“ geschützt. Selbst wenn jemand in den Besitz eines privaten Schlüssels gelangt (zum Beispiel die Datei <code
                  class="filename">~/.ssh/id_rsa</code>), muss er zusätzlich noch diese Phrase kennen, um ihn verwenden zu können. Dieser zusätzliche Schutz ist jedoch nicht unüberwindlich, und wenn Sie denken, dass die Sicherheit dieser Datei nicht mehr gewährleistet ist, sollten Sie diesen Schlüssel auf den Rechnern, auf denen er installiert wurde, deaktivieren (indem Sie ihn aus <code
                  class="filename">authorized_keys</code> entfernen) und durch einen neu erzeugten Schlüssel ersetzen.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KULTUR</em></span> OpenSSL-Schwachstelle in Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					Die OpenSSL-Bibliothek, die ursprünglich mit Debian <span
                  class="distribution distribution">Etch</span> bereitgestellt wurde, hatte ein gravierendes Problem in ihrem Zufallszahlengenerator (RNG). In der Tat hatte der zuständige Debian-Betreuer eine Änderung vorgenommen, damit Anwendungen, die ihn verwenden, keine Warnmeldungen mehr verursachen, wenn sie von Werkzeugen für das Memory Management wie zum Beispiel <code
                  class="command">valgrind</code> analysiert werden. Leider hatte diese Änderung auch zur Folge, dass der Zufallszahlengenerator nur eine Entropie-Quelle in Abhängigkeit von der Prozesskennung (PID) benutzte, deren 32.000 mögliche Werte keinen ausreichenden Grad an Zufälligkeit boten. <div
                  class="url">→ <a
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Insbesondere, wenn OpenSSL benutzt wurde, um einen Schlüssel zu erzeugen, wurde dieser immer aus einem Satz einiger hunderttausend Schlüssel erstellt (32.000 multipliziert mit einer kleinen Zahl von Schlüssellängen). Hiervon waren SSH-Schlüssel, SSL-Schlüssel und von zahlreichen Anwendungen, wie zum Beispiel OpenVPN, verwendete X.509-Zertifikate betroffen. Ein Eindringling brauchte nur alle Schlüssel auszuprobieren, um unberechtigten Zugriff zu erlangen. Um die Auswirkung des Problems einzuschränken, wurde der SSH-Daemon dahingehend verändert, dass er zweifelhafte Schlüssel, die in den Paketen <span
                  class="pkg pkg">openssh-blacklist</span> und <span
                  class="pkg pkg">openssh-blacklist-extra</span> aufgelistet sind, zurückweist. Darüber hinaus ermöglicht es der Befehl <code
                  class="command">ssh-vulnkey</code>, möglicherweise gefährdete Schlüssel im System zu identifizieren.
				</div><div
                class="para">
					A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <code
                  class="command">valgrind</code>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package.
				</div><div
                class="para">
					Es ist unter diesen Umständen schwierig, Korrekturmaßnahmen zu finden, die solche Vorfälle in Zukunft verhindern. Die Lehre, die hieraus gezogen werden kann, ist, dass jede Abweichung, die Debian in Ursprungssoftware einführt, begründet, dokumentiert, möglichst dem Urspungsprojekt vorgelegt und breit veröffentlicht werden muss. Unter diesem Gesichtspunkt wurden das neue Quellpaket-Format („3.0 (quilt)“) und der Debian-Patch-Tracker entwickelt. <div
                  class="url">→ <a
                    href="http://patch-tracker.debian.org">http://patch-tracker.debian.org</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-x11"></a>9.2.1.2. Entfernte X11-Anwendungen benutzen</h4></div></div></div><div
              class="para">
					Das SSH-Protokoll ermöglicht die Weiterleitung grafischer Daten („X11“-Sitzung, nach dem Namen des am weitesten verbreiteten grafischen Systems in Unix); der Server stellt hierbei einen besonderen Kanal für diese Daten bereit. Konkret bedeutet dies, dass ein aus der Ferne ausgeführtes, grafisches Programm vom X.org-Server auf dem lokalen Bildschirm dargestellt werden kann, und dass die gesamte Sitzung (Eingabe und Anzeige) abgesichert ist. Da entfernte Anwendungen durch diese Funktion das lokale System beeinträchtigen können, ist sie standardmäßig deaktiviert. Sie kann aktiviert werden, indem man in der Serverkonfigurationsdatei (<code
                class="filename">/etc/ssh/sshd_config</code>) die Option <code
                class="literal">X11Forwarding yes</code> einstellt. Schließlich muss der Benutzer diese Funktion anfordern, indem er die Option <code
                class="literal">-X</code> zur Befehlszeile <code
                class="command">ssh</code> hinzufügt.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Verschlüsselte Tunnel mit Port-Weiterleitung einrichten</h4></div></div></div><a
              id="idm139908629201168"
              class="indexterm"></a><div
              class="para">
					Die Optionen <code
                class="literal">-R</code> und <code
                class="literal">-L</code> des Befehls <code
                class="command">ssh</code> ermöglichen es, „verschlüsselte Tunnel“ zwischen zwei Rechnern zu erstellen, und so einen lokalen TCP-Port (siehe <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> TCP/UDP</a> in der Seitenleiste) sicher an einen entfernten Rechner weiterzuleiten und umgekehrt.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Tunnel</strong></p></div></div></div><a
                id="idm139908629196576"
                class="indexterm"></a><a
                id="idm139908629195136"
                class="indexterm"></a><div
                class="para">
					Das Internet und die meisten mit ihm verbundenen LANs arbeiten im Paket-Modus und nicht in einem fest geschalteten Modus. Das heißt, dass ein Paket, das von einem Rechner zu einem anderen verschickt wird, auf dem Weg zu seinem Ziel an mehreren dazwischenliegenden Routern angehalten wird. Dennoch kann man einen fest geschalteten Betrieb nachahmen, indem der Datenstrom in normale IP-Pakete eingeschlossen wird. Diese Pakete laufen über ihren üblichen Weg, jedoch wird der Datenstrom am Ziel dann unverändert rekonstruiert. Man nennt dies einen „Tunnel“ in Analogie zu einem Straßentunnel, bei dem Fahrzeuge direkt vom Eingang (Eingabe) zum Ausgang (Ausgabe) fahren, ohne auf irgendwelche Kreuzungen zu stoßen, im Gegensatz zu einem Weg an der Oberfläche, bei dem es Kreuzungen und Richtungswechsel gibt.
				</div><div
                class="para">
					Man kann bei dieser Gelegenheit den Tunnel verschlüsseln: der Datenstrom, der durch ihn hindurchläuft, ist dann von außen unkenntlich, wird aber am Tunnelausgang wieder in eine unverschlüsselte Form zurückgeführt.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 intermediary</code> eröffnet eine SSH-Sitzung mit dem Host <em
                class="replaceable">intermediary</em> und nimmt am lokalen Port 8000 Verbindungen an (siehe <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">Abbildung 9.3, „Einen lokalen Port mit SSH weiterleiten“</a>). Für jede Verbindung, die an diesem Port hergestellt wird, baut <code
                class="command">ssh</code> eine Verbindung vom Rechner <em
                class="replaceable">intermediary</em> zum Port 25 des <em
                class="replaceable">server</em> auf und verknüpft beide Verbindungen.
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:server:25 intermediary</code> eröffnet auch eine SSH-Sitzung zum Rechner <em
                class="replaceable">intermediary</em>, aber <code
                class="command">ssh</code> nimmt dann auf diesem Rechner an Port 8000 Verbindungen an (siehe <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">Abbildung 9.4, „Einen entfernten Port mit SSH weiterleiten“</a>). Jede Verbindung, die an diesem Port hergestellt wird, veranlasst <code
                class="command">ssh</code>, eine Verbindung vom lokalen Rechner zum Port 25 des <em
                class="replaceable">server</em> zu öffnen und beide Verbindungen miteinander zu verknüpfen.
				</div><div
              class="para">
					In beiden Fällen werden Verbindungen zu Port 25 auf dem Host <em
                class="replaceable">server</em> hergestellt, die durch den SSH-Tunnel laufen, der zwischen dem lokalen Rechner und dem Rechner <em
                class="replaceable">intermediary</em> hergestellt wurde. Im ersten Fall ist der Eingang zum Tunnel der lokale Port 8000, und die Daten laufen zum Rechner <em
                class="replaceable">intermediary</em>, bevor sie zum <em
                class="replaceable">server</em> im „öffentlichen“ Netzwerk geleitet werden. Im zweiten Fall sind Ein- und Ausgang im Tunnel vertauscht: der Eingang ist Port 8000 auf dem Rechner <em
                class="replaceable">intermediary</em>, der Ausgang ist auf dem lokalen Host, und die Daten werden dann zum <em
                class="replaceable">server</em> geleitet. In der Praxis ist der Server normalerweise entweder der lokale Rechner oder der intermediäre. Auf diese Weise sichert SSH die Verbindung von einem Ende zum anderen.
				</div><div
              class="figure"><a
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Einen lokalen Port mit SSH weiterleiten" /></div></div><p
                class="title"><strong>Abbildung 9.3. Einen lokalen Port mit SSH weiterleiten</strong></p></div><div
              class="figure"><a
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Einen entfernten Port mit SSH weiterleiten" /></div></div><p
                class="title"><strong>Abbildung 9.4. Einen entfernten Port mit SSH weiterleiten</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.remote-desktops"></a>9.2.2. Entfernte grafische Arbeitsflächen benutzen</h3></div></div></div><div
            class="para">
				VNC (Virtual Network Computing) ermöglicht aus der Ferne Zugriff auf grafische Arbeitsflächen.
			</div><a
            id="idm139908629172560"
            class="indexterm"></a><a
            id="idm139908629171600"
            class="indexterm"></a><a
            id="idm139908629170672"
            class="indexterm"></a><a
            id="idm139908629169264"
            class="indexterm"></a><a
            id="idm139908629168336"
            class="indexterm"></a><div
            class="para">
				Dieses Hilfsprogramm wird vor allem zur technischen Unterstützung eingesetzt; der Administrator kann die Fehler sehen, denen ein Benutzer gegenübersteht, und ihm die richtige Vorgehensweise zeigen, ohne vor Ort sein zu müssen.
			</div><a
            id="idm139908629166704"
            class="indexterm"></a><a
            id="idm139908629165280"
            class="indexterm"></a><a
            id="idm139908629163856"
            class="indexterm"></a><div
            class="para">
				First, the user must authorize sharing their session. The GNOME graphical desktop environment in <span
              class="distribution distribution">Jessie</span> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <code
              class="command">vino</code>). KDE still requires using <code
              class="command">krfb</code> to allow sharing an existing session over VNC. For other graphical desktop environments, the <code
              class="command">x11vnc</code> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon.
			</div><a
            id="idm139908629159360"
            class="indexterm"></a><a
            id="idm139908629157936"
            class="indexterm"></a><a
            id="idm139908629156512"
            class="indexterm"></a><a
            id="idm139908629155088"
            class="indexterm"></a><div
            class="para">
				Wenn die grafische Sitzung durch VNC freigeschaltet wurde, muss sich der Administrator über einen VNC-Client mit ihr verbinden. GNOME verfügt zu diesem Zweck über <code
              class="command">vinagre</code> und <code
              class="command">remmina</code>, während KDE <code
              class="command">krdc</code> enthält (im Menü unter <span
              class="guimenu"><strong>K-Menü</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Krdc - Verbindung zu Fremdrechner</strong></span>). Es gibt weitere VNC-Clients, die die Befehlszeile verwenden, wie zum Beispiel <code
              class="command">xvnc4viewer</code> im gleichnamigen Debian-Paket. Sobald die Verbindung hergestellt ist, kann der Administrator sehen, was vorgeht, kann aus der Ferne auf dem Rechner arbeiten und dem Benutzer zeigen, wie er vorgehen soll.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SICHERHEIT</em></span> VNC über SSH</strong></p></div></div></div><a
              id="idm139908629148128"
              class="indexterm"></a><div
              class="para">
				Falls Sie über VNC eine Verbindung herstellen, Ihre Daten aber nicht im Klartext über das Netzwerk schicken wollen, können Sie sie in einem SSH-Tunnel verbergen (siehe <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Abschnitt 9.2.1.3, „Verschlüsselte Tunnel mit Port-Weiterleitung einrichten“</a>). Sie müssen nur wissen, dass VNC standardmäßig den Port 5900 für den ersten Bildschirm („localhost:0“ genannt), 5901 für den zweiten („localhost:1“ genannt) usw. verwendet.
			</div><div
              class="para">
				Der Befehl <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">rechner</em></code> erstellt einen Tunnel zwischen dem lokalen Port 5901 in der localhost-Schnittstelle und Port 5900 auf dem Host <em
                class="replaceable">rechner</em>. Das erste „localhost“ beschränkt SSH darauf, nur an dieser Schnittstelle des lokalen Rechners auf Anfragen zu warten. Das zweite „localhost“ bezeichnet die Schnittstelle des entfernten Rechners, die den Netzverkehr entgegennehmen wird, der in „localhost:5901“ eintritt. Auf diese Weise verbindet <code
                class="command">vncviewer localhost:1</code> den VNC-Client mit dem entfernten Bildschirm, obwohl Sie den Namen des lokalen Rechners angeben.
			</div><div
              class="para">
				Wenn die VNC-Sitzung beendet ist, vergessen Sie nicht, den Tunnel zu schließen, indem Sie auch die entsprechende SSH-Sitzung beenden.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Display Manager</strong></p></div></div></div><a
              id="idm139908629140752"
              class="indexterm"></a><a
              id="idm139908629139632"
              class="indexterm"></a><a
              id="idm139908629138512"
              class="indexterm"></a><a
              id="idm139908629137392"
              class="indexterm"></a><a
              id="idm139908629136272"
              class="indexterm"></a><a
              id="idm139908629134832"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code>, and <code
                class="command">xdm</code> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session.
			</div></div><div
            class="para">
				VNC funktioniert auch für mobile Anwender oder für Angestellte, die sich gelegentlich von zu Hause aus anmelden müssen, um auf einen entfernten Bildschirm ähnlich dem an ihrem Arbeitsplatz zuzugreifen. Die Konfiguration eines derartigen Dienstes ist komplizierter: zunächst installieren Sie das Paket <span
              class="pkg pkg">vnc4server</span>, passen die Konfiguration des Display Managers dahingehend an, dass er Anfragen an <code
              class="literal">XDMCP Query</code> annimmt (für <code
              class="command">gdm3</code> kann dies durch Hinzufügen von <code
              class="literal">Enable=true</code> im Abschnitt “xdmcp” von <code
              class="filename">/etc/gdm3/daemon.conf</code>) und starten schließlich den VNC-Server mit <code
              class="command">inetd</code>, so dass eine Sitzung automatisch beginnt, wenn ein Benutzer sich anzumelden versucht. Sie können zum Beispiel folgende Zeile zu <code
              class="filename">/etc/inetd.conf</code> hinzufügen:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</pre><div
            class="para">
				Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <code
              class="command">gdm3</code> login screen (or equivalent <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code>, because the port used is 5950.
			</div><a
            id="idm139908629122816"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Zurück</strong>Kapitel 9. Unix-Dienste</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Weiter</strong>9.3. Berechtigungen verwalten</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.remote-login.html">ar-MA</a></li><li><a
              href="../da-DK/sect.remote-login.html">da-DK</a></li><li><a
              href="../de-DE/sect.remote-login.html">de-DE</a></li><li><a
              href="../el-GR/sect.remote-login.html">el-GR</a></li><li><a
              href="../en-US/sect.remote-login.html">en-US</a></li><li><a
              href="../es-ES/sect.remote-login.html">es-ES</a></li><li><a
              href="../fa-IR/sect.remote-login.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.remote-login.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.remote-login.html">hr-HR</a></li><li><a
              href="../id-ID/sect.remote-login.html">id-ID</a></li><li><a
              href="../it-IT/sect.remote-login.html">it-IT</a></li><li><a
              href="../ja-JP/sect.remote-login.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.remote-login.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.remote-login.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.remote-login.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.remote-login.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.remote-login.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.remote-login.html">zh-CN</a></li></ul></div></body></html>
