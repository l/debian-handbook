<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.3. Das Innenleben eines Rechners: die verschiedenen beteiligten Schichten</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Prozess, Hierarchie, Grundlegende Befehle" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Anhang B. Kurzer Förderkurs" /><link
        rel="prev"
        href="sect.filesystem-hierarchy.html"
        title="B.2. Organisation der Dateisystem-Hierarchie" /><link
        rel="next"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Einige vom Kernel erledigte Aufgaben" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/de-DE/sect.computer-layers.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.filesystem-hierarchy.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-role-and-tasks.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.computer-layers"></a>B.3. Das Innenleben eines Rechners: die verschiedenen beteiligten Schichten</h2></div></div></div><div
          class="para">
			Ein Rechner wird häufig als etwas ziemlich Abstraktes angesehen, und die äußerlich sichtbare Schnittstelle ist wesentlich einfacher als seine interne Komplexität. Diese Komplexität ergibt sich zum Teil aus der Zahl der beteiligten Teile. Diese Teile können jedoch in Form von Schichten betrachtet werden, wobei eine Schicht nur mit der unmittelbar darüber- und darunterliegenden interagiert.
		</div><div
          class="para">
			Ein Endbenutzer kann zurechtkommen, ohne diese Einzelheiten zu kennen... solange alles funktioniert. Wenn man einem Problem wie „Das Internet geht nicht!“ gegenübersteht, besteht der erste Schritt darin herauszufinden, aus welcher Schicht das Problem herrührt. Funktioniert die Netzwerkkarte (Hardware)? Wird sie vom Rechner erkannt? Sieht sie der Linux-Kernel? Sind die Netzwerkparameter richtig eingestellt? All diese Fragen grenzen die zutreffende Schicht ein und richten das Augenmerk auf die mögliche Quelle des Problems.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware"></a>B.3.1. Die unterste Schicht: Die Hardware</h3></div></div></div><a
            id="id-1.21.6.4.2"
            class="indexterm"></a><a
            id="id-1.21.6.4.3"
            class="indexterm"></a><a
            id="id-1.21.6.4.4"
            class="indexterm"></a><a
            id="id-1.21.6.4.5"
            class="indexterm"></a><a
            id="id-1.21.6.4.6"
            class="indexterm"></a><a
            id="id-1.21.6.4.7"
            class="indexterm"></a><a
            id="id-1.21.6.4.8"
            class="indexterm"></a><a
            id="id-1.21.6.4.9"
            class="indexterm"></a><div
            class="para">
				Lassen Sie uns mit der grundlegenden Erinnerung beginnen, dass ein Rechner in erster Linie eine Zusammenstellung von Hardwareelementen ist. Es gibt im Allgemeinen eine Hauptplatine (das <span
              class="emphasis"><em>Motherboard</em></span>) mit einem (oder mehreren) Prozessor(en), etwas RAM, Gerätesteuerungen und Erweiterungssteckplätze für Optionskarten (für weitere Gerätesteuerungen). Von diesen Steuerungen sind vor allem das IDE (paralleles ATA), das SCSI und das serielle ATA zum Anschluss von Speichergeräten wie Festplatten beachtenswert. Zu den weiteren Steuerungen gehören das USB, das eine große Vielfalt an Geräten (von Webkameras zu Thermometern, von Tastaturen zu Systemen für die Hausautomation) aufnehmen kann, und das IEEE_1394 (Firewire). Diese Steuerungen ermöglichen es häufig, mehrere Geräte anzuschließen. Daher wird das vollständige Subsystem, für das eine Steuerung zuständig ist, gewöhnlich als „Bus“ bezeichnet. Zu den Optionskarten gehören Grafikkarten (an die Bildschirme angeschlossen werden), Soundkarten, Netzwerkschnittstellenkarten und so weiter. Bei einigen Hauptplatinen sind diese Bestandteile bereits fest eingebaut, so dass sie keine Optionskarten benötigen.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN DER PRAXIS</em></span> Überprüfen, ob die Hardware funktioniert</strong></p></div></div></div><div
              class="para">
				Zu überprüfen, ob ein Hardwareteil funktioniert, kann schwierig sein. Dagegen lässt sich manchmal recht einfach feststellen, dass es nicht funktioniert.
			</div><div
              class="para">
				Ein Festplattenlaufwerk besteht aus sich drehenden Platten und sich bewegenden Magnetköpfen. Wenn eine Festplatte angeschaltet wird, erzeugt der Plattenmotor ein charakteristisches Surren. Außerdem gibt er Energie in Form von Hitze ab. Deshalb ist ein Festplattenlaufwerk, das beim Anschalten kalt und still bleibt, defekt.
			</div><div
              class="para">
				Netzwerkkarten besitzen häufig LEDs, die den Verbindungsstatus anzeigen. Falls ein Kabel angeschlossen ist und zu einem funktionierenden Netzwerk-Hub oder -Schalter führt, wird zumindest eine LED an sein. Falls keine LED leuchtet, ist entweder die Karte selbst, das Netzwerkgerät oder das Kabel zwischen ihnen defekt. Der nächste Schritt besteht deshalb dann darin, jede Komponente einzeln zu überprüfen.
			</div><div
              class="para">
				Einige Optionskarten - insbesondere 3D-Videokarten - enthalten Kühlungen, wie Kühlkörper und Ventilatoren. Wenn sich der Ventilator nicht dreht, obwohl die Karte angeschaltet ist, besteht eine plausible Erklärung darin, dass die Karte überhitzt ist. Das Gleiche gilt auch für den oder die Hauptprozessor(en) auf der Hauptplatine.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.bios"></a>B.3.2. Der Starter: das BIOS oder UEFI</h3></div></div></div><a
            id="id-1.21.6.5.2"
            class="indexterm"></a><a
            id="id-1.21.6.5.3"
            class="indexterm"></a><a
            id="id-1.21.6.5.4"
            class="indexterm"></a><div
            class="para">
				Hardware ist für sich genommen ohne entsprechende Software, die sie steuert, nicht in der Lage, sinnvolle Tätigkeiten auszuführen. Der Zweck des Betriebssystems und der Anwendungen besteht darin, die Hardware zu kontrollieren und mit ihr zu interagieren. Ihrerseits benötigen sie funktionierende Hardware, um zu laufen.
			</div><div
            class="para">
				Diese Symbiose zwischen Hardware und Software kommt nicht von allein zustande. Wenn der Rechner zu Anfang hochgefahren wird, muss zunächst einiges eingerichtet werden. Diese Rolle übernimmt das BIOS oder UEFI, ein Stück Software, das in der Hauptplatine eingebettet ist und beim Hochfahren automatisch ausgeführt wird. Seine Hauptaufgabe besteht darin, nach Software Ausschau zu halten, an die es die Kontrolle übergeben kann. Normalerweise bedeutet dies im Falle von BIOS, nach der ersten Festplatte mit einem Boot-Sektor zu suchen (auch <span
              class="emphasis"><em>Master Boot Record</em></span> oder <acronym
              class="acronym">MBR</acronym> genannt), dann diesen Boot-Sektor zu laden und ihn auszuführen. Von da an ist das BIOS (bis zum nächsten Hochfahren) normalerweise nicht mehr beteiligt. Im Falle von UEFI startet der Prozess die Suche nach einer EFI Partition welche die weiteren zu startenden EFI Applikationen enthält.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HILFSPROGRAMM</em></span> Setup, das BIOS/UEFI-Konfigurationsprogramm</strong></p></div></div></div><a
              id="id-1.21.6.5.7.2"
              class="indexterm"></a><div
              class="para">
				Das BIOS/UEFI enthält auch Software namens Setup, das dazu bestimmt ist, bestimmte Aspekte des Rechners einzustellen. Insbesondere lässt sich mit ihm das bevorzugte Startgerät auswählen (zum Beispiel das Disketten- oder das CD-ROM-Laufwerk), die Systemuhr einstellen und so weiter. Um Setup zu starten, muss normalerweise unmittelbar nach dem Einschalten des Rechners eine Taste gedrückt werden. Diese Taste ist häufig <span
                class="keycap"><strong>Entf</strong></span> oder <span
                class="keycap"><strong>Esc</strong></span>, manchmal auch <span
                class="keycap"><strong>F2</strong></span> oder <span
                class="keycap"><strong>F10</strong></span>. Meistens wird die Auswahlmöglichkeit während des Hochfahrens kurz eingeblendet.
			</div></div><div
            class="para">
				Der Bootsektor (oder die UEFI Partition) enthält seinerseits Software, Boot-Loader genannt, dessen Zweck darin besteht, ein Betriebssystem zu finden und auszuführen. Da dieser Boot-Loader nicht auf der Hauptplatine eingebettet ist, sondern von einer Platte geladen wird, kann er intelligenter als das BIOS sein, woraus sich erklärt, warum nicht das BIOS selbst das Betriebssystem lädt. Zum Beispiel kann der Boot-Loader (auf einem Linux-System häufig GRUB) die verfügbaren Betriebssysteme auflisten und den Benutzer bitten, eines auszuwählen. Normalerweise ist dies mit einem Zeitlimit und einer voreingestellten Auswahl versehen. Manchmal kann der Benutzer auch zusätzliche Parameter zur Weiterleitung an den Kernel angeben und so weiter. Schließlich wird ein Kernel gefunden, in den Speicher geladen und ausgeführt.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTIZ</em></span> UEFI, ein moderner BIOS-Ersatz</strong></p></div></div></div><a
              id="id-1.21.6.5.9.2"
              class="indexterm"></a><a
              id="id-1.21.6.5.9.3"
              class="indexterm"></a><div
              class="para">
				UEFI ist eine relativ neue Entwicklung. Die meisten neuen Computer unterstützen das Booten mit UEFI, aber in der Regel auch mit BIOS, um durch Rückwärtskompatibilität mit Betriebssystemen booten zu können, die nicht in der Lage sind UEFI zu nutzen.
			</div><div
              class="para">
				Dieses neue System enfernt einige Beschränkungen des Bootens mit BIOS: durch Verwendung einer eignenen Partition brauchen die Bootloader keine speziellen Tricks mehr, einen sehr kleinen <span
                class="emphasis"><em>Master Boot Record</em></span> unterzubringen, um dann den zu bootenden Kernel zu finden. Besser noch, mit einem passenden Linux Kernel kann UEFI diesen ohne dazwischengeschalteten Bootloader direkt booten. UEFI ist also die Grundlage für <span
                class="emphasis"><em>Secure Boot</em></span>, eine Technologie, die sicherstellt, dass Sie nur durch den Betriebbssystemhersteller geprüfte Software laufen lassen.
			</div></div><div
            class="para">
				Das BIOS/UEFI ist auch dafür zuständig, eine Anzahl von Geräten zu finden und zu initialisieren. Offensichtlich gehören hierzu die IDE/SATA-Geräte (normalerweise Festplatten und CD/DVD-ROM-Laufwerke) aber auch PCI-Geräte. Erkannte Geräte werden häufig während des Hochfahrens auf dem Bildschirm angezeigt. Falls diese Liste zu schnell vorbeiläuft, können Sie die <span
              class="keycap"><strong>Pause</strong></span>-Taste drücken, um sie zum Lesen anzuhalten. PCI-Geräte, die installiert sind, aber nicht angezeigt werden, sind ein schlechtes Zeichen. Im schlimmsten Fall ist das Gerät defekt. Im besten Fall ist es nur nicht mit der aktuellen Version des BIOS oder der Hauptplatine kompatibel. PCI-Spezifikationen entwickeln sich weiter, und bei alten Hauptplatinen ist nicht gewährleistet, dass sie mit neueren PCI-Geräten umgehen können.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.kernel"></a>B.3.3. Der Kernel</h3></div></div></div><div
            class="para">
				Sowohl das BIOS/UEFI als auch der Boot-Loader laufen jeweils nur für einige Sekunden; wir gelangen nun zur ersten Software, die länger läuft: dem Betriebssystem-Kernel. Dieser Kernel nimmt die Rolle eines Orchesterdirigenten ein und gewährleistet die Koordination zwischen Hardware und Software. Zu dieser Rolle gehören mehrere Aufgaben, unter anderem: Hardware betreiben, Prozesse verwalten, Benutzer und Berechtigungen, das Dateisystem und so weiter. Der Kernel stellt eine gemeinsame Grundlage für alle anderen Programme des Systems zur Verfügung.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.userspace-presentation"></a>B.3.4. Die Anwendungsebene</h3></div></div></div><div
            class="para">
				Obwohl alles, was außerhalb des Kernels geschieht, unter dem Begriff „Anwendungsebene“ zusammengefasst werden kann, können wir sie dennoch in verschiedene Software-Ebenen unterteilen. Ihr Zusammenwirken ist jedoch komplexer als zuvor, und die Unterteilungen sind manchmal nicht gerade einfach. Eine Anwendung verwendet normalerweise Bibliotheken, die wiederum den Kernel einbeziehen, die Kommunikation kann aber auch andere Programme einbeziehen, oder zahlreiche Bibliotheken können sich sogar gegenseitig aufrufen.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.filesystem-hierarchy.html"><strong>Zurück</strong>B.2. Organisation der Dateisystem-Hierarchie</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-role-and-tasks.html"><strong>Weiter</strong>B.4. Einige vom Kernel erledigte Aufgaben</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.computer-layers.html">ar-MA</a></li><li><a
              href="../da-DK/sect.computer-layers.html">da-DK</a></li><li><a
              href="../de-DE/sect.computer-layers.html">de-DE</a></li><li><a
              href="../el-GR/sect.computer-layers.html">el-GR</a></li><li><a
              href="../en-US/sect.computer-layers.html">en-US</a></li><li><a
              href="../es-ES/sect.computer-layers.html">es-ES</a></li><li><a
              href="../fa-IR/sect.computer-layers.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.computer-layers.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.computer-layers.html">hr-HR</a></li><li><a
              href="../id-ID/sect.computer-layers.html">id-ID</a></li><li><a
              href="../it-IT/sect.computer-layers.html">it-IT</a></li><li><a
              href="../ja-JP/sect.computer-layers.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.computer-layers.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.computer-layers.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.computer-layers.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.computer-layers.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.computer-layers.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.computer-layers.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.computer-layers.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.computer-layers.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.computer-layers.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.computer-layers.html">zh-TW</a></li></ul></div></body></html>
