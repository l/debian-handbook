<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Einige vom Kernel erledigte Aufgaben</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-de-DE-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Prozess, Hierarchie, Grundlegende Befehle" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Anhang B. Kurzer Förderkurs" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Das Innenleben eines Rechners: die verschiedenen beteiligten Schichten" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. Die Anwendungsebene" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/de-DE/sect.kernel-role-and-tasks.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Einige vom Kernel erledigte Aufgaben</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Die Hardware steuern</h3></div></div></div><div
            class="para">
				Es ist vor allem Aufgabe des Kernels, die Hardwareelemente zu steuern, sie zu erkennen, sie einzuschalten, wenn der Rechner angeschaltet wird, und so weiter. Er macht sie auch über eine vereinfachte Programmierschnittstelle für die Software auf höherer Ebene verfügbar, so dass Anwendungen Geräte nutzen können, ohne sich um Einzelheiten kümmern zu müssen, wie zum Beispiel, in welchen Erweiterungssteckplatz die Optionsplatine eingesteckt ist. Die Programmierschnittstelle stellt auch eine Abstraktionsschicht zur Verfügung; diese ermöglicht es zum Beispiel einer Videokonferenz-Anwendung, eine Webkamera unabhängig von ihrer Marke und ihrem Modell zu verwenden. Die Anwendung kann einfach die Schnittstelle <span
              class="emphasis"><em>Video for Linux</em></span> (V4L) benutzen, und der Kernel übersetzt die Funktionsaufrufe dieser Schnittstelle in die tatsächlichen Hardwarebefehle, die von der konkret verwendeten Webkamera benötigt werden.
			</div><div
            class="para">
				<a
              id="idm139908610781776"
              class="indexterm"></a> <a
              id="idm139908610780976"
              class="indexterm"></a> <a
              id="idm139908610780176"
              class="indexterm"></a> <a
              id="idm139908610779376"
              class="indexterm"></a> Der Kernel exportiert über die virtuellen Dateisysteme <code
              class="filename">/proc/</code> und <code
              class="filename">/sys/</code> zahlreiche Einzelheiten über die erkannte Hardware. Verschiedene Hilfsprogramme fassen diese Einzelheiten zusammen. Von ihnen zeigt <code
              class="command">lspci</code> (im Paket <span
              class="pkg pkg">pciutils</span>) eine Liste der PCI-Geräte an, <code
              class="command">lsusb</code> (im Paket <span
              class="pkg pkg">usbutils</span>) führt USB-Geräte auf und <code
              class="command">lspcmcia</code> (im Paket <span
              class="pkg pkg">pcmciautils</span>) PCMCIA-Karten. Diese Hilfsprogramme sind zur Identifizierung des genauen Modells eines Geräts sehr hilfreich. Diese Identifizierung ermöglicht auch ein genaueres Suchen im Web, das wiederum zu relevanteren Dokumenten führt.
			</div><div
            class="example"><a
              id="idm139908610773760"></a><p
              class="title"><strong>Beispiel B.1. Beispiel der von <code
                  class="command">lspci</code> und <code
                  class="command">lsusb</code> angezeigten Informationen</strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Diese Programme haben eine Option <code
              class="literal">-v</code>, durch die wesentlich detailliertere (aber gewöhnlich nicht erforderliche) Informationen angezeigt werden. Schließlich listet der Befehl <code
              class="command">lsdev</code> (im Paket <span
              class="pkg pkg">procinfo</span>) die von den Geräten benutzten Kommunikationsressourcen auf.
			</div><div
            class="para">
				Anwendungen greifen häufig mittels spezieller in <code
              class="filename">/dev/</code> erzeugter Dateien auf Geräte zu (siehe Seitenleiste <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Zugriffsberechtigungen für Geräte</a>). Dies sind besondere Dateien, die Plattenlaufwerke (zum Beispiel <code
              class="filename">/dev/hda</code> und <code
              class="filename">/dev/sdc</code>), Partitionen (<code
              class="filename">/dev/hda1</code> oder <code
              class="filename">/dev/sdc3</code>), Mäuse (<code
              class="filename">/dev/input/mouse0</code>), Tastaturen (<code
              class="filename">/dev/input/event0</code>), Soundkarten (<code
              class="filename">/dev/snd/*</code>), serielle Schnittstellen (<code
              class="filename">/dev/ttyS*</code>) und so weiter repräsentieren.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Dateisysteme</h3></div></div></div><a
            id="idm139908610760144"
            class="indexterm"></a><a
            id="idm139908610759184"
            class="indexterm"></a><div
            class="para">
				Dateisysteme sind einer der bedeutendsten Aspekte des Kernels. Unix-Systeme vereinen alle Dateispeicher in einer gemeinsamen Hierarchie, die es Benutzern (und Anwendungen) ermöglicht, auf Daten einfach durch Kenntnis ihres Ortes innerhalb dieser Hierarchie zuzugreifen.
			</div><div
            class="para">
				Der Ausgangspunkt dieses Hierarchiebaums wird „root“ genannt, <code
              class="filename">/</code>. Dieses Verzeichnis kann mit Namen versehene Unterverzeichnisse enthalten. Das Unterverzeichnis <code
              class="literal">home</code> von <code
              class="filename">/</code> wird beispielsweise <code
              class="filename">/home/</code> genannt. Dieses Unterverzeichnis kann wiederum weitere Unterverzeichnisse enthalten und so weiter. Jedes Verzeichnis kann auch Dateien enthalten, in denen die tatsächlichen Daten gespeichert sind. So bezieht sich <code
              class="filename">/home/rmas/Desktop/hello.txt</code> auf eine Datei namens <code
              class="literal">hello.txt</code>, die im Unterverzeichnis <code
              class="literal">Desktop</code> des Unterverzeichnisses <code
              class="literal">rmas</code> des Verzeichnisses <code
              class="literal">home</code> gespeichert ist, das sich in root befindet. Der Kernel übersetzt zwischen diesem Benennungssystem und dem tatsächlichen, physikalischen Speicherort auf einer Platte.
			</div><div
            class="para">
				Im Gegensatz zu anderen Systemen gibt es nur eine derartige Hierarchie, und sie kann Daten verschiedener Speicherplatten einbinden. Eine dieser Platten wird als Wurzelverzeichnis verwendet, und die übrigen werden innerhalb der Hierarchie in Verzeichnissen „eingehängt“ (der entsprechende Unixbefehl heißt <code
              class="command">mount</code>); diese anderen Platten sind dann unter ihren „Einhängepunkten“ verfügbar. Hierdurch wird es möglich, die Home-Verzeichnisse der Benutzer (üblicherweise in <code
              class="filename">/home/</code> gespeichert) auf einer zweiten Festplatte abzuspeichern, die dann Verzeichnisse wie <code
              class="literal">rhertzog</code> und <code
              class="literal">rmas</code> enthält. Sobald diese Platte auf <code
              class="filename">/home/</code> eingehängt ist, sind diese Verzeichnisse an ihren üblichen Orten zugänglich, und Pfade wie <code
              class="filename">/home/rmas/Desktop/hello.txt</code> funktionieren weiterhin.
			</div><a
            id="idm139908610748848"
            class="indexterm"></a><div
            class="para">
				There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> and <span
              class="emphasis"><em>ext4</em></span>, but others exist. For instance, <span
              class="emphasis"><em>vfat</em></span> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <code
              class="command">mkfs.ext3</code> (where <code
              class="command">mkfs</code> stands for <span
              class="emphasis"><em>MaKe FileSystem</em></span>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <code
              class="filename">/dev/sda1</code>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</div><div
            class="para">
				There are also network filesystems, such as <acronym
              class="acronym">NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Gemeinsam genutzte Funktionen</h3></div></div></div><div
            class="para">
				Da eine Anzahl von Funktionen von allen Programmen gemeinsam benutzt wird, macht es Sinn, sie im Kernel zusammenzufassen. Zum Beispiel ermöglicht der Einsatz eines gemeinsam benutzten Dateisystems es jeder Anwendung, einfach eine Datei anhand ihres Namens zu öffnen, ohne sich darum zu kümmern, wo die Datei physisch gespeichert ist. Die Datei kann in mehreren Teilen auf einer Festplatte gespeichert sein, über mehrere Festplatten verteilt sein oder sogar auf einem entfernten Dateiserver abgelegt sein. Gemeinsam genutzte Kommunikationsfunktionen werden von Anwendungen dazu verwendet, Daten unabhängig von der Art auf der sie transportiert werden, auszutauschen. Zum Beispiel könnte der Transport über eine beliebige Kombination aus lokalen und kabellosen Netzwerken oder über eine Festnetztelefonleitung verlaufen.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Prozesse verwalten</h3></div></div></div><a
            id="idm139908610737936"
            class="indexterm"></a><div
            class="para">
				Ein Prozess führt ein Programm aus. Dies erfordert Speicherplatz, um sowohl das Programm selbst als auch seine Betriebsdaten zu speichern. Es ist die Aufgabe des Kernels, sie zu erzeugen und zu verfolgen. Wenn ein Programm läuft, reserviert der Kernel zunächst Speicherplatz, lädt dann den ausführbaren Code aus dem Dateisystem in den Speicher und beginnt schließlich, den Code auszuführen. Er hält Informationen über diesen Prozess bereit, von denen die am leichtesten erkennbare eine Identifikationsnummer namens <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span>) ist.
			</div><div
            class="para">
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There's actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they're actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HINWEIS</em></span> Multiprozessorsysteme (und Varianten)</strong></p></div></div></div><div
              class="para">
				The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <span
                class="emphasis"><em>per processor core</em></span> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes.
			</div></div><div
            class="para">
				Natürlich ermöglicht der Kernel es auch, mehrere unabhängige Instanzen desselben Programms auszuführen. Jedoch kann jede von ihnen nur auf ihre eigenen Zeitabschnitte und ihren eigenen Speicherplatz zugreifen. Ihre Daten bleiben daher voneinander unabhängig.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Rechteverwaltung</h3></div></div></div><div
            class="para">
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started the process. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a
              class="xref"
              href="sect.rights-management.html">Abschnitt 9.3, „Berechtigungen verwalten“</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Zurück</strong>B.3. Das Innenleben eines Rechners: die verschied...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Weiter</strong>B.5. Die Anwendungsebene</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li></ul></div></body></html>
