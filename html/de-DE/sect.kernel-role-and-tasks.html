<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Einige vom Kernel erledigte Aufgaben</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Prozess, Hierarchie, Grundlegende Befehle" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Anhang B. Kurzer Förderkurs" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Das Innenleben eines Rechners: die verschiedenen beteiligten Schichten" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. Die Anwendungsebene" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/de-DE/sect.kernel-role-and-tasks.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Einige vom Kernel erledigte Aufgaben</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Die Hardware steuern</h3></div></div></div><div
            class="para">
				Es ist vor allem Aufgabe des Kernels, die Hardwareelemente zu steuern, sie zu erkennen, sie einzuschalten, wenn der Rechner angeschaltet wird, und so weiter. Er macht sie auch über eine vereinfachte Programmierschnittstelle für die Software auf höherer Ebene verfügbar, so dass Anwendungen Geräte nutzen können, ohne sich um Einzelheiten kümmern zu müssen, wie zum Beispiel, in welchen Erweiterungssteckplatz die Optionsplatine eingesteckt ist. Die Programmierschnittstelle stellt auch eine Abstraktionsschicht zur Verfügung; diese ermöglicht es zum Beispiel einer Videokonferenz-Anwendung, eine Webkamera unabhängig von ihrer Marke und ihrem Modell zu verwenden. Die Anwendung kann einfach die Schnittstelle <span
              class="emphasis"><em>Video for Linux</em></span> (V4L) benutzen, und der Kernel übersetzt die Funktionsaufrufe dieser Schnittstelle in die tatsächlichen Hardwarebefehle, die von der konkret verwendeten Webkamera benötigt werden.
			</div><div
            class="para">
				<a
              id="id-1.21.7.2.3.1"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.2"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.3"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.4"
              class="indexterm"></a> Der Kernel exportiert über die virtuellen Dateisysteme <code
              class="filename">/proc/</code> und <code
              class="filename">/sys/</code> zahlreiche Einzelheiten über die erkannte Hardware. Verschiedene Hilfsprogramme fassen diese Einzelheiten zusammen. Von ihnen zeigt <code
              class="command">lspci</code> (im Paket <span
              class="pkg pkg">pciutils</span>) eine Liste der PCI-Geräte an, <code
              class="command">lsusb</code> (im Paket <span
              class="pkg pkg">usbutils</span>) führt USB-Geräte auf und <code
              class="command">lspcmcia</code> (im Paket <span
              class="pkg pkg">pcmciautils</span>) PCMCIA-Karten. Diese Hilfsprogramme sind zur Identifizierung des genauen Modells eines Geräts sehr hilfreich. Diese Identifizierung ermöglicht auch ein genaueres Suchen im Web, das wiederum zu relevanteren Dokumenten führt.
			</div><div
            class="example"><a
              id="id-1.21.7.2.4"></a><p
              class="title"><strong>Beispiel B.1. Beispiel der von <code
                  class="command">lspci</code> und <code
                  class="command">lsusb</code> angezeigten Informationen</strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Diese Programme haben eine Option <code
              class="literal">-v</code>, durch die wesentlich detailliertere (aber gewöhnlich nicht erforderliche) Informationen angezeigt werden. Schließlich listet der Befehl <code
              class="command">lsdev</code> (im Paket <span
              class="pkg pkg">procinfo</span>) die von den Geräten benutzten Kommunikationsressourcen auf.
			</div><div
            class="para">
				Anwendungen greifen häufig mittels spezieller in <code
              class="filename">/dev/</code> erzeugter Dateien auf Geräte zu (siehe Seitenleiste <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Zugriffsberechtigungen für Geräte</a>). Dies sind besondere Dateien, die Plattenlaufwerke (zum Beispiel <code
              class="filename">/dev/hda</code> und <code
              class="filename">/dev/sdc</code>), Partitionen (<code
              class="filename">/dev/hda1</code> oder <code
              class="filename">/dev/sdc3</code>), Mäuse (<code
              class="filename">/dev/input/mouse0</code>), Tastaturen (<code
              class="filename">/dev/input/event0</code>), Soundkarten (<code
              class="filename">/dev/snd/*</code>), serielle Schnittstellen (<code
              class="filename">/dev/ttyS*</code>) und so weiter repräsentieren.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Dateisysteme</h3></div></div></div><a
            id="id-1.21.7.3.2"
            class="indexterm"></a><a
            id="id-1.21.7.3.3"
            class="indexterm"></a><div
            class="para">
				Dateisysteme sind einer der bedeutendsten Aspekte des Kernels. Unix-Systeme vereinen alle Dateispeicher in einer gemeinsamen Hierarchie, die es Benutzern (und Anwendungen) ermöglicht, auf Daten einfach durch Kenntnis ihres Ortes innerhalb dieser Hierarchie zuzugreifen.
			</div><div
            class="para">
				Der Ausgangspunkt dieses Hierarchiebaums wird „root“ genannt, <code
              class="filename">/</code>. Dieses Verzeichnis kann mit Namen versehene Unterverzeichnisse enthalten. Das Unterverzeichnis <code
              class="literal">home</code> von <code
              class="filename">/</code> wird beispielsweise <code
              class="filename">/home/</code> genannt. Dieses Unterverzeichnis kann wiederum weitere Unterverzeichnisse enthalten und so weiter. Jedes Verzeichnis kann auch Dateien enthalten, in denen die tatsächlichen Daten gespeichert sind. So bezieht sich <code
              class="filename">/home/rmas/Desktop/hello.txt</code> auf eine Datei namens <code
              class="literal">hello.txt</code>, die im Unterverzeichnis <code
              class="literal">Desktop</code> des Unterverzeichnisses <code
              class="literal">rmas</code> des Verzeichnisses <code
              class="literal">home</code> gespeichert ist, das sich in root befindet. Der Kernel übersetzt zwischen diesem Benennungssystem und dem tatsächlichen, physikalischen Speicherort auf einer Platte.
			</div><div
            class="para">
				Im Gegensatz zu anderen Systemen gibt es nur eine derartige Hierarchie, und sie kann Daten verschiedener Speicherplatten einbinden. Eine dieser Platten wird als Wurzelverzeichnis verwendet, und die übrigen werden innerhalb der Hierarchie in Verzeichnissen „eingehängt“ (der entsprechende Unixbefehl heißt <code
              class="command">mount</code>); diese anderen Platten sind dann unter ihren „Einhängepunkten“ verfügbar. Hierdurch wird es möglich, die Home-Verzeichnisse der Benutzer (üblicherweise in <code
              class="filename">/home/</code> gespeichert) auf einer zweiten Festplatte abzuspeichern, die dann Verzeichnisse wie <code
              class="literal">rhertzog</code> und <code
              class="literal">rmas</code> enthält. Sobald diese Platte auf <code
              class="filename">/home/</code> eingehängt ist, sind diese Verzeichnisse an ihren üblichen Orten zugänglich, und Pfade wie <code
              class="filename">/home/rmas/Desktop/hello.txt</code> funktionieren weiterhin.
			</div><a
            id="id-1.21.7.3.7"
            class="indexterm"></a><div
            class="para">
				Es gibt zahlreiche Dateisystemformate entsprechend den zahlreichen Arten, auf die Daten physisch auf Platten gespeichert werden. Die bekanntesten sind <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> und <span
              class="emphasis"><em>ext4</em></span>, es gibt aber auch andere. <span
              class="emphasis"><em>vfat</em></span> ist zum Beispiel das System, das ursprünglich von DOS und den Windows-Betriebssystemen verwendet wurde, mit dem es möglich ist, Festplatten sowohl unter Debian als auch unter Windows zu benutzen. In jedem Fall muss auf einer Platte ein Dateisystem eingerichtet werden, bevor sie eingehängt werden kann, und dieser Vorgang wird als „formatieren“ bezeichnet. Befehle wie <code
              class="command">mkfs.ext3</code> (wobei <code
              class="command">mkfs</code> für <span
              class="emphasis"><em>MaKe FileSystem</em></span> steht) erledigen das Formatieren. Diese Befehle benötigen als einen ihrer Parameter eine Gerätedatei, die die zu formatierende Partition darstellt (zum Beispiel <code
              class="filename">/dev/sda1</code>). Dieser Vorgang ist löschend und sollte nur einmal ausgeführt werden, es sei denn, man möchte absichtlich ein Dateisystem unwiederbringlich löschen und von Neuem beginnen.
			</div><div
            class="para">
				Es gibt auch Netzwerk-Dateisysteme, wie zum Beispiel <acronym
              class="acronym">NFS</acronym>, bei denen Daten nicht auf einer lokalen Platte gespeichert sind. Stattdessen werden Daten über das Netzwerk zu einem Server übertragen, der sie nach Bedarf speichert und abruft. Die Dateisystem-Abstraktion bewahrt Benutzer davor, sich darum kümmern zu müssen: Dateien bleiben in ihrer üblichen hierarchischen Weise zugänglich.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Gemeinsam genutzte Funktionen</h3></div></div></div><div
            class="para">
				Da eine Anzahl von Funktionen von allen Programmen gemeinsam benutzt wird, macht es Sinn, sie im Kernel zusammenzufassen. Zum Beispiel ermöglicht der Einsatz eines gemeinsam benutzten Dateisystems es jeder Anwendung, einfach eine Datei anhand ihres Namens zu öffnen, ohne sich darum zu kümmern, wo die Datei physisch gespeichert ist. Die Datei kann in mehreren Teilen auf einer Festplatte gespeichert sein, über mehrere Festplatten verteilt sein oder sogar auf einem entfernten Dateiserver abgelegt sein. Gemeinsam genutzte Kommunikationsfunktionen werden von Anwendungen dazu verwendet, Daten unabhängig von der Art auf der sie transportiert werden, auszutauschen. Zum Beispiel könnte der Transport über eine beliebige Kombination aus lokalen und kabellosen Netzwerken oder über eine Festnetztelefonleitung verlaufen.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Prozesse verwalten</h3></div></div></div><a
            id="id-1.21.7.5.2"
            class="indexterm"></a><div
            class="para">
				Ein Prozess führt ein Programm aus. Dies erfordert Speicherplatz, um sowohl das Programm selbst als auch seine Betriebsdaten zu speichern. Es ist die Aufgabe des Kernels, sie zu erzeugen und zu verfolgen. Wenn ein Programm läuft, reserviert der Kernel zunächst Speicherplatz, lädt dann den ausführbaren Code aus dem Dateisystem in den Speicher und beginnt schließlich, den Code auszuführen. Er hält Informationen über diesen Prozess bereit, von denen die am leichtesten erkennbare eine Identifikationsnummer namens <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span>) ist.
			</div><div
            class="para">
				Unix-artige Kernel (einschließlich Linux) sind, wie die meisten anderen modernen Betriebssysteme fähig, im „Mehrprozessbetrieb“ zu laufen. Mit anderen Worten ermöglichen sie die Ausführung zahlreicher Prozesse „zur gleichen Zeit“. In Wirklichkeit läuft zu einem bestimmten Zeitpunkt immer nur ein Prozess, aber der Kernel teilt die Zeit in kleine Abschnitte auf und führt reihum jeden Prozess aus. Da diese Zeitabschnitte sehr kurz sind (im Bereich von Tausendstelsekunden), entsteht die Illusion, dass die Prozesse parallel laufen, obwohl sie jeweils nur während bestimmter Zeitabschnitte aktiv sind und im übrigen untätig. Die Aufgabe des Kernels besteht darin, seinen Zeitplanungsmechanismus so anzupassen, dass diese Illusion erhalten bleibt, und gleichzeitig die allgemeine Systemleistung maximiert wird. Wenn die Zeitabschnitte zu lang sind, könnte es der Anwendung nicht so schnell angezeigt werden wie erwünscht. Sind sie zu kurz, verliert das System Zeit durch zu häufiges Umschalten zwischen den Aufgaben. Diese Entscheidungen können mithilfe von Prozessprioritäten optimiert werden. Prozesse mit hoher Priorität laufen länger und häufiger als Prozesse mit niedriger Priorität.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HINWEIS</em></span> Multiprozessorsysteme (und Varianten)</strong></p></div></div></div><div
              class="para">
				Die oben beschriebene Einschränkung, nur einen Prozess gleichzeitig laufen zu lassen, gilt nicht immer. Die tatsächliche Einschränkung besteht darin, dass zu einem gegebenen Zeitpunkt immer nur ein Prozess <span
                class="emphasis"><em>je Prozessorkern</em></span> laufen kann. Multiprozessor-, Multikern- oder „Hyper-Threading“-Systeme ermöglichen die parallele Ausführung mehrerer Prozesse. Das gleiche Zeitunterteilungssystem wird zwar weiterhin verwendet, jetzt jedoch dazu, mit Situationen umzugehen, in denen es mehr aktive Prozesse als verfügbare Prozessorkerne gibt. Dies ist nicht ungewöhnlich: ein einfaches System, selbst wenn es weitgehend nichts tut, führt fast ständig Dutzende von Prozessen aus.
			</div></div><div
            class="para">
				Natürlich ermöglicht der Kernel es auch, mehrere unabhängige Instanzen desselben Programms auszuführen. Jedoch kann jede von ihnen nur auf ihre eigenen Zeitabschnitte und ihren eigenen Speicherplatz zugreifen. Ihre Daten bleiben daher voneinander unabhängig.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Rechteverwaltung</h3></div></div></div><div
            class="para">
				Unix-artige Systeme sind auch Mehrplatzsysteme. Sie verfügen über ein Rechteverwaltungssystem, das getrennte Gruppen und Benutzer ermöglicht und auf der Basis von Berechtigungen die Auswahl zwischen dem Zulassen und Blockieren von Aktionen. Der Kernel verwaltet für jeden Prozess die Daten, die es ermöglichen, Berechtigungen zu überprüfen. Meistens werden Prozesse anhand der Benutzer, die ihn gestartet haben, identifiziert. Der Prozess kann nur die Aktionen ausführen, die auch dem Besitzer erlaubt sind. Zum Beispiel muss der Kernel beim Versuch, eine Datei zu öffnen, die Identität des Prozesses hinsichtlich der Zugriffsberechtigungen überprüfen (für mehr Einzelheiten zu diesem speziellen Beispiel siehe <a
              class="xref"
              href="sect.rights-management.html">Abschnitt 9.3, „Berechtigungen verwalten“</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Zurück</strong>B.3. Das Innenleben eines Rechners: die verschied...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Weiter</strong>B.5. Die Anwendungsebene</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.kernel-role-and-tasks.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.kernel-role-and-tasks.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.kernel-role-and-tasks.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.kernel-role-and-tasks.html">zh-TW</a></li></ul></div></body></html>
