<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Die Anwendungsebene</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Prozess, Hierarchie, Grundlegende Befehle" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Anhang B. Kurzer Förderkurs" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Einige vom Kernel erledigte Aufgaben" /><link
        rel="next"
        href="backcover.html"
        title="Anhang C. Das Debian Administrationshandbuch" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/de-DE/sect.user-space.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.user-space"></a>B.5. Die Anwendungsebene</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			„Anwendungsebene“ bezieht sich auf die Laufzeitumgebung normaler Prozesse (im Gegensatz zu Kernelprozessen). Das bedeutet nicht unbedingt, dass diese Prozesse tatsächlich von Benutzern gestartet wurden, da auf einem Standardsystem üblicherweise bereits mehrere „Daemon“-Prozesse laufen, bevor ein Benutzer überhaupt eine Sitzung eröffnet. Daemon-Prozesse sind Prozesse der Anwendungsebene.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-basics"></a>B.5.1. Prozess</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Wenn der Kernel seine Initialisierungsphase beendet hat, startet er den ersten Prozess, <code
              class="command">init</code>. Prozess #1 ist für sich selbst kaum nützlich und Unix-artige Systeme laufen mit vielen zusätzlichen Prozessen.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Zunächst einmal kann sich ein Prozess kopieren (dies wird als <span
              class="emphasis"><em>Fork</em></span> bezeichnet). Der Kernel teilt einen neuen, aber gleichgroßen Prozess-Speicherplatz zu und einen weiteren Prozess, um ihn zu nutzen. Zu diesem Zeitpunkt besteht der einzige Unterschied zwischen den beiden Prozessen in ihrer <span
              class="emphasis"><em>PID</em></span>. Der neue Prozess wird üblicherweise Kindprozess genannt, und der Prozess, dessen <span
              class="emphasis"><em>PID</em></span> sich nicht ändert, Elternprozess.
			</div><div
            class="para">
				Manchmal fährt der Kindprozess fort, sein eigenes Leben unabhängig vom Elternprozess mit seinen eigenen, vom Elternprozess kopierten Daten zu führen. In vielen Fällen führt der Kindprozess jedoch ein anderes Programm aus. Bis auf wenige Ausnahmen wird sein Speicher einfach durch den Speicher des neuen Programms ersetzt, und die Ausführung dieses neuen Programms beginnt. Dieser Mechanismus wird vom „init“-Prozess (der die Prozessnummer 1 hat) genutzt um weitere Services zu starten und so die gesamte Startsequenz durchzuführen. Zu einem bestimmten Zeitpunkt startet ein Prozess der <code
              class="command">init</code>-Abkömmlinge dann eine grafische Schnittstelle, über die sich Benutzer anmelden können (der tatsächliche Ablauf der Ereignisse ist in größerer Ausführlichkeit in <a
              class="xref"
              href="unix-services.html#sect.system-boot">Abschnitt 9.1, „Systemstart“</a> beschrieben.
			</div><div
            class="para">
				Wenn ein Prozess die Aufgabe, für die er gestartet wurde, erfüllt hat, beendet er sich. Anschließend nimmt der Kernel den diesem Prozess zugewiesenen Speicher wieder zurück und hört auf, Teile der Prozessorzeit zuzuteilen. Der Elternprozess wird über die Beendigung seines Kindprozesses informiert. Auf diese Weise kann ein Prozess auf den Abschluss einer Aufgabe warten, die er an einen Kindprozess übertragen hat. Dieses Verhalten ist bei Kommandozeileninterpretern (auch als <span
              class="emphasis"><em>Shells</em></span> bekannt) deutlich zu sehen. Wenn ein Befehl in eine Shell eingegeben wird, erscheint die Eingabeaufforderung erst dann wieder, wenn die Ausführung des Befehls beendet ist. Die meisten Shells ermöglichen eine Ausführung des Befehls im Hintergrund. Dazu wird einfach ein <strong
              class="userinput"><code>&amp;</code></strong> an das Ende des Befehls angehängt. Die Eingabeaufforderung wird dann sofort wieder angezeigt, was jedoch zu Problemen führen kann, wenn das abgesetzte Kommando seine eigenen Daten anzeigen muss.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.daemons"></a>B.5.2. Hintergrundprozesse (Dämonprozesse)</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				Ein „Daemon“ ist ein Prozess, der beim Hochfahren automatisch gestartet wird. Er läuft (im Hintergrund) weiter, um Verwaltungsaufgaben zu erledigen oder Dienste für andere Prozesse bereitzustellen. Diese „Hintergrundaufgabe“ ist genau genommen willkürlich und entspricht aus Sicht des Systems nichts Bestimmtem. Es sind, wie andere Prozesse auch, einfach Prozesse, die reihum laufen, wann immer ihr zugeteilter Zeitabschnitt kommt. Eine Unterscheidung gibt es nur in der menschlichen Sprache: ein Prozess, der ohne eine Interaktion mit einem Benutzer läuft (insbesondere ohne eine grafische Schnittstelle), wird als „im Hintergrund“ laufend oder als „Daemon“ bezeichnet.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Daemon, Dämon, eine abwertende Bezeichnung?</strong></p></div></div></div><div
              class="para">
				Obwohl die Bezeichnung <span
                class="emphasis"><em>Daemon</em></span> ihren griechischen Ursprung mit <span
                class="emphasis"><em>Dämon</em></span> teilt, unterstellt erstere nichts teuflisch Übles, im Gegenteil sollte sie als eine Art hilfreicher Geist verstanden werden. Diese Unterscheidung ist im Englischen bereits recht subtil, in anderen Sprachen ist es jedoch noch schlimmer, in denen dasselbe Wort in beiden Bedeutungen verwendet wird.
			</div></div><div
            class="para">
				Mehrere solcher Daemons sind ausführlich in <a
              class="xref"
              href="unix-services.html">Kapitel 9, <em>Unix-Dienste</em></a> beschrieben.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ipc"></a>B.5.3. Interprozesskommunikationen</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				Ein einzelner Prozess, ob ein Daemon oder eine interaktive Anwendung, ist selten für sich genommen nützlich. Daher gibt es verschiedene Methoden, um getrennten Prozessen die Kommunikation miteinander zu ermöglichen, entweder um Daten auszutauschen oder um sich gegenseitig zu steuern. Die allgemeine Bezeichnung hierfür lautet <span
              class="emphasis"><em>Interprozesskommunikation</em></span> oder abgekürzt IPC.
			</div><div
            class="para">
				Das einfachste IPC-System besteht darin, Dateien zu verwenden. Der Prozess, der Daten übersenden möchte, schreibt sie in eine Datei (mit einem zuvor bekannten Namen), während der Empfänger nur die Datei zu öffnen und den Inhalt zu lesen braucht.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				In den Fällen, in denen man keine Daten auf einer Platte speichern möchte, kann man eine <span
              class="emphasis"><em>Pipe</em></span> benutzen, die einfach ein Objekt mit zwei Enden ist; Bytes, die am einen Ende geschrieben werden, können am anderen gelesen werden. Wenn diese Enden von verschiedenen Prozessen kontrolliert werden, führt dies zu einem einfachen und praktischen Interprozesskommunikationskanal. Pipes können in zwei Arten unterschieden werden: benannte Pipes und anonyme Pipes. Eine benannte Pipe wird durch einen Eintrag im Dateisystem dargestellt (obwohl die übermittelten Daten dort nicht gespeichert sind), so dass beide Prozesse sie unabhängig voneinander öffnen können, falls der Ort der benannten Pipe vorab bekannt ist. In Fällen, in denen die Kommunikationsprozesse in Zusammenhang miteinander stehen (zum Beispiel ein Eltern- und sein Kindprozess), kann der Elternprozess auch eine anonyme Pipe erstellen, bevor er sich vervielfältigt, und der Kindprozess übernimmt sie dann. Beide Prozesse können sodann durch diese Pipe Daten miteinander austauschen, ohne das Dateisystem zu benötigen.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN DER PRAXIS</em></span> Ein konkretes Beispiel</strong></p></div></div></div><div
              class="para">
				Lassen Sie uns beschreiben, was geschieht, wenn ein komplexer Befehl (eine <span
                class="emphasis"><em>Pipeline</em></span>) von einer Konsole aus ausgeführt wird. Wir nehmen an, dass wir einen <code
                class="command">bash</code>-Prozess haben (die standardmäßige Benutzerkonsole bei Debian) mit der <span
                class="emphasis"><em>PID</em></span> 4374; in diese Konsole schreiben wir den Befehl: <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Die Konsole interpretiert zunächst den eingegebenen Befehl. In unserem Fall versteht sie, dass es zwei Programme gibt (<code
                class="command">ls</code> und <code
                class="command">sort</code>) mit einem Datenstrom, der vom einen zum anderen fließt (gekennzeichnet durch das <strong
                class="userinput"><code>|</code></strong>-Zeichen, das als <span
                class="emphasis"><em>Pipe</em></span> bezeichnet wird). <code
                class="command">bash</code> erstellt zunächst eine anonyme Pipe (die anfangs nur innerhalb des <code
                class="command">bash</code>-Prozesses selbst besteht).
			</div><div
              class="para">
				Dann vervielfältigt sich die Konsole; dies führt zu einem neuen <code
                class="command">bash</code>-Prozess mit der <span
                class="emphasis"><em>PID</em></span> 4521 (<span
                class="emphasis"><em>PIDs</em></span> sind abstrakte Zahlen und haben im Allgemeinen keine besondere Bedeutung). Prozess 4521 übernimmt die Pipe, was bedeutet, das er auf ihrer „Eingabe“-Seite schreiben kann; <code
                class="command">bash</code> leitet seinen Standardausgabestrom auf die Eingabe dieser Pipe um. Dann führt es das Programm <code
                class="command">ls</code> aus, das den Inhalt des aktuellen Verzeichnisses auflistet (und ersetzt sich selbst durch dieses Programm). Da <code
                class="command">ls</code> auf seine Standardausgabe schreibt und diese Ausgabe zuvor umgeleitet wurde, werden die Ergebnisse im Endeffekt in die Pipe geschickt.
			</div><div
              class="para">
				Ein ähnlicher Vorgang findet beim zweiten Befehl statt: <code
                class="command">bash</code> vervielfältigt sich wieder, was zu einem neuen <code
                class="command">bash</code>-Prozess mit der PID 4522 führt. Da er ebenfalls ein Kindprozess von 4374 ist, übernimmt er auch die Pipe; <code
                class="command">bash</code> verbindet dann seine Standardeingabe mit der Pipeausgabe und führt danach den Befehl <code
                class="command">sort</code> aus, der seine Eingabe sortiert und die Ergebnisse anzeigt (und ersetzt sich selbst durch diesen Befehl).
			</div><div
              class="para">
				Alle Teile des Puzzles stehen nun bereit: <code
                class="command">ls</code> liest das aktuelle Verzeichnis ein und schreibt die Liste der Dateien in die Pipe; <code
                class="command">sort</code> liest diese Liste, sortiert sie alphabetisch und zeigt die Ergebnisse an. Die Prozesse 4521 und 4522 enden dann, und 4374 (der während des Vorgangs auf sie gewartet hatte) übernimmt wieder die Kontrolle und zeigt die Eingabeaufforderung an, die es dem Benutzer ermöglicht, einen neuen Befehl einzugeben.
			</div></div><div
            class="para">
				Jedoch werden nicht alle Interprozesskommunikationen zur Übermittlung von Daten benutzt. In vielen Situationen bestehen die einzigen Informationen, die übertragen werden müssen, aus Steuerungsmitteilungen wie „Ausführung anhalten“ oder „Ausführung fortsetzen“. Unix (und Linux) stellen einen Mechanismus bereit, der <span
              class="emphasis"><em>Signale</em></span> genannt wird, durch den ein Prozess einfach ein spezifisches Signal (aus einer festgelegten Liste vordefinierter Signale) an einen anderen Prozess senden kann. Die einzige Voraussetzung besteht hierbei darin, dass die <span
              class="emphasis"><em>PID</em></span> des Zielprozesses bekannt ist.
			</div><div
            class="para">
				Für komplexere Kommunikationen gibt es ebenfalls Mechanismen, die es einem Prozess ermöglichen, einem anderen Prozess Zugriff auf einen Teil des ihm zugeteilten Speicherplatzes zu gewähren oder ihn gemeinsam mit ihm zu benutzen. Der nun gemeinsam benutzte Speicherplatz ermöglicht es dann, Daten zwischen den Prozessen hin und her zu schieben.
			</div><div
            class="para">
				Schließlich können auch Netzwerkverbindungen Prozessen helfen, miteinander zu kommunizieren; diese Prozesse können sogar auf verschiedenen Rechnern laufen, möglicherweise tausende von Kilometern voneinander entfernt.
			</div><div
            class="para">
				Es ist für ein typisches Unix-artiges System recht normal, all diese Mechanismen in wechselndem Umfang zu verwenden.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.libraries"></a>B.5.4. Bibliotheken</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Programmbibliotheken spielen in einem Unix-artigen Betriebssystem eine entscheidende Rolle. Sie sind nicht wirklich Programme, da sie für sich allein nicht ausgeführt werden können, sondern Ansammlungen von Code-Fragmenten, die von Standardprogrammen verwendet werden können. Unter den gängigen Bibliotheken sind vor allem folgende erwähnenswert:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						die Standard-C-Bibliothek (<span
                    class="emphasis"><em>glibc</em></span>), die grundlegende Funktionen enthält wie das Öffnen von Dateien und von Netzwerkverbindungen und andere unterstützende Interaktionen mit dem Kernel;
					</div></li><li
                class="listitem"><div
                  class="para">
						grafische Werkzeugsätze, wie zum Beispiel Gtk+ und Qt, die es vielen Programmen ermöglichen, die grafischen Objekte, die sie bereitstellen, ihrerseits zu verwenden;
					</div></li><li
                class="listitem"><div
                  class="para">
						die <span
                    class="emphasis"><em>libpng</em></span>-Bibliothek, die das Laden, Interpretieren und Speichern von Bildern im PNG-Format ermöglicht.
					</div></li></ul></div><div
            class="para">
				Dank dieser Bibliotheken können Anwendungen bestehenden Code wiederverwenden. Die Anwendungsentwicklung wird hierdurch entsprechend vereinfacht; insbesondere, wenn viele Anwendungen die gleichen Funktionen wiederverwenden. Da Bibliotheken häufig von verschiedenen Personen entwickelt werden, steht die allgemeine Entwicklung dieses Systems der historischen Philosophie von Unix sehr nahe.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KULTUR</em></span> Der Unix-Methode: Eins nach dem Anderen</strong></p></div></div></div><div
              class="para">
				Eines der wesentlichen Konzepte, das der Unix-Familie von Betriebssystemen zugrunde liegt, ist, dass jedes Werkzeug nur eine Sache erledigen sollte, und dass es diese gut machen sollte; Anwendungen können dann diese Werkzeuge wiederverwenden, um damit eine höhere Logik aufzubauen. Dieses Konzept ist in vielen Verkörperungen zu erkennen. Shellskripte sind vielleicht das beste Beispiel: sie fügen komplexe Folgen sehr einfacher Werkzeuge zusammen (wie zum Beispiel <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code> und so weiter). Eine andere Umsetzung dieser Philosophie ist in den Code-Bibliotheken zu erkennen: die Bibliothek <span
                class="emphasis"><em>libpng</em></span> ermöglicht es, PNG-Bilder mit verschiedenen Optionen und auf verschiedene Weise zu lesen und zu schreiben, aber sie tut nur das; es kommt nicht infrage, dass ihr Funktionsmerkmale hinzugefügt werden, die Bilder anzeigen oder editieren.
			</div></div><div
            class="para">
				Ferner werden diese Bibliotheken häufig als „gemeinsam benutzte Bibliotheken“ bezeichnet, da der Kernel sie nur einmal in den Speicher laden kann, selbst wenn gleichzeitig mehrere Prozesse dieselbe Bibliothek nutzen. Hierdurch kann im Vergleich zur entgegengesetzten (hypothetischen) Situation, bei der der Bibliothekscode so viele Male geladen würde, wie es Prozesse gibt, die ihn benutzen, Speicherplatz gespart werden.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Zurück</strong>B.4. Einige vom Kernel erledigte Aufgaben</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Weiter</strong>Anhang C. Das Debian Administrationshandbuch</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.user-space.html">ar-MA</a></li><li><a
              href="../da-DK/sect.user-space.html">da-DK</a></li><li><a
              href="../de-DE/sect.user-space.html">de-DE</a></li><li><a
              href="../el-GR/sect.user-space.html">el-GR</a></li><li><a
              href="../en-US/sect.user-space.html">en-US</a></li><li><a
              href="../es-ES/sect.user-space.html">es-ES</a></li><li><a
              href="../fa-IR/sect.user-space.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.user-space.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.user-space.html">hr-HR</a></li><li><a
              href="../id-ID/sect.user-space.html">id-ID</a></li><li><a
              href="../it-IT/sect.user-space.html">it-IT</a></li><li><a
              href="../ja-JP/sect.user-space.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.user-space.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.user-space.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.user-space.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.user-space.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.user-space.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.user-space.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.user-space.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.user-space.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.user-space.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.user-space.html">zh-TW</a></li></ul></div></body></html>
