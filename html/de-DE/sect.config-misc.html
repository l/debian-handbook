<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.9. Weitere Konfigurationen: Zeitsynchronisation, Protokolle, Gemeinsamer Zugang…</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-de-DE-1.0-1" /><meta
        name="keywords"
        content="Konfigurierung, Lokalisierung, Sprachumgebungen, Netzwerk, Namensauflösung, Benutzer, Gruppen, Benutzerkonten, Befehlszeileninterpreter, Shell, Drucken, Boot-Loader, Kernel-Kompilierung" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="basic-configuration.html"
        title="Kapitel 8. Basis-Konfigurierung: Netzwerk, Benutzerkonten, Drucken..." /><link
        rel="prev"
        href="sect.config-bootloader.html"
        title="8.8. Den Boot-Loader konfigurieren" /><link
        rel="next"
        href="sect.kernel-compilation.html"
        title="8.10. Einen Kernel kompilieren" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/de-DE/sect.config-misc.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.config-misc"></a>8.9. Weitere Konfigurationen: Zeitsynchronisation, Protokolle, Gemeinsamer Zugang…</h2></div></div></div><div
          class="para">
			Die zahlreichen in diesem Abschnitt aufgeführten Elemente sind für jeden wissenswert, der alle Aspekte der Konfigurierung eines GNU/Linux-Systems beherrschen möchte. Sie werden jedoch nur kurz behandelt, und häufig wird auf die Dokumentation verwiesen.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.timezone"></a>8.9.1. Zeitzone</h3></div></div></div><a
            id="idm139686929941440"
            class="indexterm"></a><div
            class="sidebar"><a
              id="sidebar.symbolic-link"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Symbolische Verknüpfungen</strong></p></div></div></div><a
              id="idm139686929939056"
              class="indexterm"></a><a
              id="idm139686929937616"
              class="indexterm"></a><a
              id="idm139686929936688"
              class="indexterm"></a><div
              class="para">
				Eine symbolische Verknüpfung ist ein Verweis auf eine andere Datei. Wenn man auf sie zugreift, wird die Datei, auf die sie verweist, geöffnet. Die Entfernung der Verknüpfung führt nicht dazu, dass die Datei, auf die sie verweist, gelöscht wird. Ebenso hat sie nicht ihren eigenen Satz von Berechtigungen, sondern behält die Berechtigungen ihres Ziels bei. Und schließlich kann sie auf jede Art von Datei verweisen: Verzeichnisse, spezielle Dateien (Sockets, benannte Pipes, Gerätedateien usw.) und selbst auf andere symbolische Verknüpfungen.
			</div><div
              class="para">
				Der Befehl <code
                class="command">ln -s <em
                  class="replaceable">ziel</em> <em
                  class="replaceable">verknüpfungsname</em></code> erstellt eine symbolische Verknüpfung namens <em
                class="replaceable">verknüpfungsname</em>, die auf <em
                class="replaceable">ziel</em> verweist.
			</div><div
              class="para">
				Falls das Ziel nicht existiert, ist die Verknüpfung „gebrochen“, und der Zugriff darauf ergibt eine Fehlermeldung, die besagt, dass die Zieldatei nicht existiert. Falls die Verknüpfung auf eine andere Verknüpfung verweist, hat man eine „Kette“ von Verknüpfungen, die zu einem „Kreis“ wird, falls eines der Ziele auf einen seiner Vorgänger verweist. In diesem Fall führt der Zugriff auf eine der Verknüpfungen in diesem Kreis zu einer besonderen Fehlermeldung („too many levels of symbolic links“); das heißt, dass der Kernel nach einigen Runden des Kreises aufgegeben hat.
			</div></div><div
            class="para">
				The timezone, configured during initial installation, is a configuration item for the <span
              class="pkg pkg">tzdata</span> package. To modify it, use the <code
              class="command">dpkg-reconfigure tzdata</code> command, which allows you to choose the timezone to be used in an interactive manner. Its configuration is stored in the <code
              class="filename">/etc/timezone</code> file. Additionally, the corresponding file in the <code
              class="filename">/usr/share/zoneinfo</code> directory is copied into <code
              class="filename">/etc/localtime</code>; this file contains the rules governing the dates where daylight saving time is active, for countries that use it.
			</div><a
            id="idm139686929927248"
            class="indexterm"></a><a
            id="idm139686929926128"
            class="indexterm"></a><a
            id="idm139686929925008"
            class="indexterm"></a><a
            id="idm139686929923888"
            class="indexterm"></a><a
            id="idm139686929922768"
            class="indexterm"></a><a
            id="idm139686929921808"
            class="indexterm"></a><div
            class="para">
				Wenn man die Zeitzone vorübergehend ändern muss, verwendet man die Umgebungsvariable <code
              class="varname">TZ</code>, die Vorrang vor der konfigurierten Voreinstellung des Systems hat:
			</div><a
            id="idm139686929919840"
            class="indexterm"></a><a
            id="screen.tz"></a><pre
            class="screen">
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>date</code></strong>
<code
              class="computeroutput">Thu Feb 19 11:25:18 CET 2015</code>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>TZ="Pacific/Honolulu" date</code></strong>
<code
              class="computeroutput">Thu Feb 19 00:25:21 HST 2015</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HINWEIS</em></span> System-Uhr, Hardware-Uhr</strong></p></div></div></div><div
              class="para">
				There are two time sources in a computer. A computer's motherboard has a hardware clock, called the “CMOS clock”. This clock is not very precise, and provides rather slow access times. The operating system kernel has its own, the software clock, which it keeps up to date with its own means (possibly with the help of time servers, see <a
                class="xref"
                href="sect.config-misc.html#sect.time-synchronization">Abschnitt 8.9.2, „Zeitsynchronisierung“</a>). This system clock is generally more accurate, especially since it doesn't need access to hardware variables. However, since it only exists in live memory, it is zeroed out every time the machine is booted, contrary to the CMOS clock, which has a battery and therefore “survives” rebooting or halting of the machine. The system clock is, thus, set from the CMOS clock during boot, and the CMOS clock is updated on shutdown (to take into account possible changes or corrections if it has been improperly adjusted).
			</div><div
              class="para">
				In der Praxis entsteht ein Problem, da die CMOS-Uhr lediglich ein Zähler ist und keinerlei Informationen zur Zeitzone enthält. Bezüglich ihrer Interpretation ist daher eine Entscheidung zu treffen: entweder geht das System davon aus, dass sie in Weltzeit (UTC, früher GMT) läuft, oder in Ortszeit. Diese Entscheidung könnte zu einer einfachen Verschiebung führen, in Wirklichkeit sind die Dinge jedoch etwas komplizierter: aufgrund der Sommerzeit ist dieser Versatz nicht konstant. Daher hat das System keine Möglichkeit zu entscheiden, ob der Versatz korrekt ist, insbesondere nicht zu Zeiten der Zeitumstellung. Da es immer möglich ist, die Ortszeit aus der Weltzeit und der Information über die Zeitzone abzuleiten, empfehlen wir nachdrücklich, die CMOS-Uhr in Weltzeit zu verwenden.
			</div><div
              class="para">
				Leider ignorieren Windows-Systeme in ihrer Standardeinstellung diese Empfehlung; sie halten die CMOS-Uhr auf Ortszeit und ändern beim Hochfahren des Rechners die Zeit, indem sie bei einer Zeitumstellung abschätzen, ob die Umstellung bereits stattgefunden hat oder noch nicht. Dies funktioniert solange relativ gut, wie auf dem System nur Windows läuft. Wenn ein Rechner jedoch mehrere Systeme hat (ob dies nun eine „Dual-Boot“-Konfiguration ist oder andere Systeme als virtuelle Rechner laufen), entsteht Chaos, ohne eine Möglichkeit zu entscheiden, ob die Zeit korrekt ist. Falls Sie Windows unbedingt auf einem Rechner behalten müssen, sollten Sie dieses so einstellen, dass die CMOS-Uhr auf UTC eingestellt wird (durch Einstellen des Registry-Schlüssel <code
                class="literal">HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</code> vom Typ DWORD auf "1") oder indem Sie mit <code
                class="command">hwclock --localtime --set</code> auf dem Debian System die Hardware-Uhr setzen und als Quelle für für die lokale Zeit festlegen (und sorgen Sie dafür, dass Ihre Uhr im Frühjahr und Herbst von Hand umgestellt wird).
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.time-synchronization"></a>8.9.2. Zeitsynchronisierung</h3></div></div></div><a
            id="idm139686929907632"
            class="indexterm"></a><a
            id="idm139686929906672"
            class="indexterm"></a><div
            class="para">
				Zeitsynchronisierung, die auf einem Rechner überflüssig erscheinen mag, ist in einem Netzwerk sehr wichtig. Da Benutzer keine Berechtigung zur Änderung des Datums und der Zeit haben, ist es wichtig, dass diese Information genau stimmt, um Verwirrung zu vermeiden. Außerdem können Informationen aus den Protokollen verschiedener Rechner besser aufeinander bezogen werden, wenn alle Rechner eines Netzwerks synchronisiert sind. Im Falle eines Angriffs ist es so einfacher, die zeitliche Abfolge der Ereignisse auf verschiedenen von der Störung betroffenen Rechnern zu rekonstruieren. Daten, die auf verschiedenen Rechnern zu statistischen Zwecken gesammelt werden, wären nicht sehr sinnvoll, wenn sie nicht synchronisiert wären.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> NTP</strong></p></div></div></div><a
              id="idm139686929902944"
              class="indexterm"></a><a
              id="idm139686929901984"
              class="indexterm"></a><div
              class="para">
				NTP (Network Time Protocol) ermöglicht es einem Rechner, sich mit anderen recht genau zu synchronisieren unter Berücksichtigung der Verzögerungen, die durch die Informationsübertragung über das Netzwerk und andere mögliche Verschiebungen entstehen.
			</div><div
              class="para">
				Obwohl es im Internet zahlreiche NTP-Server gibt, können die bekannteren überlastet sein. Daher empfehlen wir, den NTP-Server <span
                class="emphasis"><em>pool.ntp.org</em></span> zu benutzen, der in Wirklichkeit eine Gruppe von Rechnern ist, die laut Vereinbarung als öffentliche NTP-Server dienen. Sie können sogar die Benutzung auf eine für ein Land bestimmte Untergruppe beschränken, wie zum Beispiel <span
                class="emphasis"><em>de.pool.ntp.org</em></span> für Deutschland oder <span
                class="emphasis"><em>at.pool.ntp.org</em></span> für Österreich usw.
			</div><div
              class="para">
				Wenn Sie jedoch ein großes Netzwerk verwalten, ist es empfehlenswert, Ihren eigenen NTP-Server zu installieren, der sich mit den öffentlichen Servern synchronisiert. Auf diese Weise können alle anderen Rechner in Ihrem Netzwerk Ihren internen NTP-Server benutzen, statt die Belastung der öffentlichen Server zu erhöhen. Sie steigern so auch die Homogenität Ihrer Uhren, da sich alle Rechner mit derselben Quelle synchronisieren und diese Quelle bezogen auf die Übertragungszeiten sehr nah ist.
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ntp-on-workstations"></a>8.9.2.1. Für Arbeitsplatzrechner</h4></div></div></div><div
              class="para">
					Da Arbeitsplatzrechner häufig neu gestartet werden (selbst wenn dies nur zur Energieersparnis dient), genügt es, sie beim Hochfahren über NTP zu synchronisieren. Hierzu installieren Sie einfach das Paket <span
                class="pkg pkg">ntpdate</span>. Bei Bedarf können Sie den verwendeten NTP-Server durch Änderung der Datei <code
                class="filename">/etc/default/ntpdate</code> wechseln.
				</div><a
              id="idm139686929893536"
              class="indexterm"></a><a
              id="idm139686929892416"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ntp-on-servers"></a>8.9.2.2. Für Server</h4></div></div></div><div
              class="para">
					Server werden nur selten neu gestartet, und es ist sehr wichtig, dass ihre Systemzeit korrekt ist. Um dauerhaft die richtige Zeit beizubehalten, sollten Sie einen lokalen NTP-Server installieren, einen Dienst, der vom Paket <span
                class="pkg pkg">ntp</span> angeboten wird. In seiner voreingestellten Konfiguration synchronisiert sich dieser Server mit <span
                class="emphasis"><em>pool.ntp.org</em></span> und stellt die Zeit auf Anfragen aus dem lokalen Netzwerk hin bereit. Sie können ihn konfigurieren, indem Sie die Datei <code
                class="filename">/etc/ntp.conf</code> editieren, wobei die wichtigste Änderung in dem NTP-Server besteht, an den er sich wendet. Falls das Netzwerk viele Server hat, könnte es von Interesse sein, einen lokalen Server einzurichten, der sich mit den öffentlichen Servern synchronisiert und der dann von den anderen Servern des Netzwerks als Quelle benutzt wird.
				</div><a
              id="idm139686929887024"
              class="indexterm"></a><a
              id="idm139686929885600"
              class="indexterm"></a><a
              id="idm139686929884160"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>WEITERE SCHRITTE</em></span> GPS-Module und andere Zeitquellen</strong></p></div></div></div><a
                id="idm139686929881632"
                class="indexterm"></a><a
                id="idm139686929880672"
                class="indexterm"></a><div
                class="para">
					Falls die Zeitsynchronisierung für Ihr Netzwerk besonders kritisch ist, können Sie einen Server mit einem GPS-Modul ausstatten (das die Zeit eines GPS-Satelliten verwendet) oder mit einem DCF-77-Modul (das die Zeit mit der Atomuhr in der Nähe von Frankfurt/Main synchronisiert). In diesen Fällen ist die Konfigurierung des NTP-Servers ein bisschen komplizierter und die vorherige Lektüre der Dokumentation eine absolute Notwendigkeit.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.rotation-logs"></a>8.9.3. Protokolldateien rotieren</h3></div></div></div><a
            id="idm139686929877184"
            class="indexterm"></a><a
            id="idm139686929875744"
            class="indexterm"></a><a
            id="idm139686929874304"
            class="indexterm"></a><a
            id="idm139686929873376"
            class="indexterm"></a><div
            class="para">
				Protokolldateien können größer werden, und zwar schnell, und es ist wichtig, sie zu archivieren. Das häufigste System besteht in einem rotierenden Archiv: die Protokolldatei wird regelmäßig archiviert, und nur die letzten <em
              class="replaceable">X</em> Archivdateien aufbewahrt. <code
              class="command">logrotate</code>, das für diese Rotationen zuständige Programm folgt den Anweisungen, die ihm in der Datei <code
              class="filename">/etc/logrotate.conf</code> und in allen im Verzeichnis <code
              class="filename">/etc/logrotate.d/</code> befindlichen Dateien gegeben werden. Der Administrator kann diese Dateien verändern, falls er die von Debian festgelegten Richtlinien zur Protokollrotation anpassen möchte. Die Handbuchseite <span
              class="citerefentry"><span
                class="refentrytitle">logrotate</span>(1)</span> beschreibt alle in diesen Konfigurationsdateien verfügbaren Optionen. Sie möchten vielleicht die Anzahl der in der Protokollrotation zurückbehaltenen Dateien erhöhen oder Protokolldateien in ein besonderes Verzeichnis verschieben, um sie zu archivieren statt zu löschen. Sie könnten sie auch per E-Mail verschicken, um sie andernorts zu archivieren.
			</div><div
            class="para">
				Das Programm <code
              class="command">logrotate</code> wird täglich durch das Termimsteuerungssprogramm <code
              class="command">cron</code> ausgeführt (beschrieben in <a
              class="xref"
              href="sect.task-scheduling-cron-atd.html">Abschnitt 9.7, „Aufgaben mit <code
                class="command">cron</code> und <code
                class="command">atd</code> zeitlich festlegen“</a>).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.sharing-admin-rights"></a>8.9.4. Administratorrechte gemeinsam nutzen</h3></div></div></div><a
            id="idm139686929864800"
            class="indexterm"></a><a
            id="idm139686929863360"
            class="indexterm"></a><a
            id="idm139686929862400"
            class="indexterm"></a><div
            class="para">
				Häufig arbeiten mehrere Administratoren am selben Netzwerk. Die Root-Passwörter gemeinsam zu nutzen, ist nicht sehr elegant und öffnet die Tür zu Missbrauch wegen der Anonymität, die eine derartige gemeinsame Nutzung schafft. Die Lösung dieses Problems besteht in dem Programm <code
              class="command">sudo</code>, das es bestimmten Benutzern ermöglicht, bestimmte Befehle mit besonderen Rechten auszuführen. Im gewöhnlichsten Fall erlaubt <code
              class="command">sudo</code> einem vertrauenswürdigen Benutzer die Ausführung jeden Befehls als Root. Hierzu führt der Benutzer einfach <code
              class="command">sudo <em
                class="replaceable">befehl</em></code> aus und authentifiziert sich dabei mit seinem persönlichen Passwort.
			</div><div
            class="para">
				Wenn es installiert ist, gibt das Paket <span
              class="pkg pkg">sudo</span> volle Root-Rechte an Mitglieder der Gruppe <code
              class="literal">sudo</code>. Um andere Berechtigungen zu vergeben, muss der Administrator mit dem Befehl <code
              class="command">visudo</code> die Konfigurationsdatei <code
              class="filename">/etc/sudoers</code> verändern (auch hier wird der Editor <code
              class="command">vi</code> aufrufen oder ein anderer in der Umgebungsvariablen <code
              class="varname">EDITOR</code> definierter Editor). Das Hinzufügen einer Zeile mit <code
              class="literal"><em
                class="replaceable">benutzername</em> ALL=(ALL) ALL</code> ermöglicht es dem betreffenden Benutzer, einen beliebigen Befehl als Root auszuführen.
			</div><a
            id="idm139686929854272"
            class="indexterm"></a><a
            id="idm139686929853152"
            class="indexterm"></a><a
            id="idm139686929852032"
            class="indexterm"></a><div
            class="para">
				Komplexere Konfigurationen ermöglichen es, bestimmte Befehle nur bestimmten Benutzern zu erlauben. Alle Einzelheiten der verschiedenen Möglichkeiten werden auf der Handbuchseite <span
              class="citerefentry"><span
                class="refentrytitle">sudoers</span>(5)</span> beschrieben.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.fstab-mount-points"></a>8.9.5. Liste der Einhängepunkte</h3></div></div></div><a
            id="idm139686929847840"
            class="indexterm"></a><a
            id="idm139686929846880"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Ein- und Aushängen</strong></p></div></div></div><div
              class="para">
				In einem unixähnlichen System wie Debian sind Dateien in einer einzelnen baumähnlichen Hierarchie von Verzeichnissen organisiert. Das Verzeichnis <code
                class="filename">/</code> wird „Wurzelverzeichnis“ genannt; alle weiteren Verzeichnisse sind Unterverzeichnisse dieser Wurzel. „Einhängen“ ist die Maßnahme, mit der der Inhalt eines Peripheriegerätes (häufig einer Festplatte) in den allgemeinen Dateienbaum des Systems einbezogen wird. Falls man eine separate Festplatte zur Speicherung der persönlichen Daten der Benutzer verwendet, muss diese Platte folglich in das Verzeichnis <code
                class="filename">/home/</code> „eingehängt“ werden. Das Wurzelverzeichnis wird vom Kernel beim Hochfahren immer eingehängt; andere Geräte werden häufig später im Verlauf der Startsequenz eingehängt oder von Hand mit dem Befehl <code
                class="command">mount</code>.
			</div><a
              id="idm139686929842176"
              class="indexterm"></a><div
              class="para">
				Einige auswechselbare Geräte werden automatisch eingehängt, wenn sie angeschlossen werden, insbesondere wenn die grafischen Arbeitsumgebungen GNOME, KDE oder andere verwendet werden. Andere Geräte müssen durch den Benutzer von Hand eingehängt werden. Sie müssen auch wieder ausgehängt (aus dem Dateibaum entfernt) werden. Normale Benutzer haben im Allgemeinen nicht die Berechtigung, die Befehle <code
                class="command">mount</code> und <code
                class="command">umount</code> auszuführen. Der Administrator kann jedoch diese Vorgänge erlauben (unabhängig für jeden einzelnen Einhängepunkt), indem er die Option <code
                class="literal">user</code> zur Datei <code
                class="filename">/etc/fstab</code> hinzufügt.
			</div><div
              class="para">
				Der Befehl <code
                class="command">mount</code> kann ohne Argumente benutzt werden (er listet dann alle eingehängten Dateisysteme auf). Die nachfolgenden Parameter sind erforderlich, um ein Gerät ein- oder auszuhängen. Entnehmen Sie bitte die vollständige Auflistung den Handbuchseiten <span
                class="citerefentry"><span
                  class="refentrytitle">mount</span>(8)</span> und <span
                class="citerefentry"><span
                  class="refentrytitle">umount</span>(8)</span>. Für einfache Fälle ist die Syntax ebenfalls einfach: um zum Beispiel die Partition <code
                class="filename">/dev/sdc1</code>, die ein ext3-Dateisystem hat, in das Verzeichnis <code
                class="filename">/mnt/tmp/</code> einzuhängen, würden Sie einfach <code
                class="command">mount -t ext3 /dev/sdc1 /mnt/tmp/</code> eingeben.
			</div></div><div
            class="para">
				Die Datei <code
              class="filename">/etc/fstab</code> enthält eine Liste aller möglichen Einhängepunkte, die entweder während des Hochfahrens automatisch eingehängt werden oder bei auswechselbaren Speichergeräten von Hand. Jeder Einhängepunkt wird in einer Zeile mit mehreren durch Leerzeichen getrennten Feldern beschrieben: <a
              id="idm139686929832160"
              class="indexterm"></a> <a
              id="idm139686929831360"
              class="indexterm"></a>
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						einzuhängendes Gerät: dies kann eine lokale Partition sein (Festplatte, CD-ROM) oder ein entferntes Dateisystem (wie zum Beispiel ein NFS).
					</div><div
                  class="para">
						Dieses Feld wird häufig durch die eindeutige ID des Dateisystems ersetzt (die man mit dem Befehl <code
                    class="command">blkid <strong
                      class="userinput"><code>gerät</code></strong></code> feststellen kann) mit vorausgestellter <code
                    class="literal">UUID=</code>. Dies schützt vor einer Änderung des Gerätenamens, falls ein Gerät hinzugefügt oder entfernt wird, oder falls Platten in einer anderen Reihenfolge erkannt werden.
					</div></li><li
                class="listitem"><div
                  class="para">
						mount point: dies ist der Ort innerhalb des lokalen Dateisystems, an dem das Gerät, das entfernte System oder die Partition eingehängt werden.
					</div></li><li
                class="listitem"><div
                  class="para">
						type: dieses Feld legt das auf dem eingehängten Gerät verwendete Dateisystem fest. <code
                    class="literal">ext4</code>, <code
                    class="literal">ext3</code>, <code
                    class="literal">vfat</code>, <code
                    class="literal">ntfs</code>, <code
                    class="literal">btrfs</code>, <code
                    class="literal">xfs</code> sind einige Beispiele.
					</div><div
                  class="sidebar"><div
                    class="titlepage"><div><div><p
                          class="title"><strong><span
                              class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> NFS, ein Netzwerk-Dateisystem</strong></p></div></div></div><div
                    class="para">
						NFS ist ein Netzwerk-Dateisystem; unter Linux ermöglicht es einen transparenten Zugriff auf entfernte Dateien, indem sie in das lokale Dateisystem einbezogen werden.
					</div></div><div
                  class="para">
						Eine vollständige Liste bekannter Dateisysteme steht auf der Handbuchseite <span
                    class="citerefentry"><span
                      class="refentrytitle">mount</span>(8)</span> zur Verfügung. Der besondere Wert <code
                    class="literal">swap</code> gilt für Swap-Partitionen; der besondere Wert <code
                    class="literal">auto</code> weist das Programm <code
                    class="command">mount</code> an, das Dateisystem selbstständig zu ermitteln (was besonders bei Laufwerken und USB-Sticks hilfreich ist, da jedes ein anderes Dateisystem haben kann);
					</div></li><li
                class="listitem"><div
                  class="para">
						options: es gibt viele in Abhängigkeit vom Dateisystem, und sie sind auf der Handbuchseite von <code
                    class="command">mount</code> dokumentiert. Die häufigsten sind
					</div><div
                  class="itemizedlist"><ul><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">rw</code> und <code
                          class="literal">ro</code> bedeuten, dass das Gerät mit den Berechtigungen zum Lesen und Schreiben beziehungsweise nur zum Lesen eingehängt wird.
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">noauto</code> deaktiviert das automatische Einhängen beim Hochfahren.
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">user</code> erlaubt es allen Benutzern, dieses Dateisystem einzuhängen (ein Vorgang, der sonst nur auf den Root-Benutzer beschränkt wäre).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">defaults</code> bezeichnet die Gruppe der voreingestellten Optionen: <code
                          class="literal">rw</code>, <code
                          class="literal">suid</code>, <code
                          class="literal">dev</code>, <code
                          class="literal">exec</code>, <code
                          class="literal">auto</code>, <code
                          class="literal">nouser</code> und <code
                          class="literal">async</code>, von denen jede einzeln nach <code
                          class="literal">defaults</code> abgestellt werden kann, indem man <code
                          class="literal">nosuid</code>, <code
                          class="literal">nodev</code> und so weiter hinzufügt, um <code
                          class="literal">suid</code>, <code
                          class="literal">dev</code> und so weiter zu sperren. Das Hinzufügen der Option <code
                          class="literal">user</code>reaktiviert diese wieder, da <code
                          class="literal">defaults</code> die Option <code
                          class="literal">nouser</code> enthält.
							</div></li></ul></div></li><li
                class="listitem"><div
                  class="para">
						backup: dieses Feld ist fast immer auf <code
                    class="literal">0</code> gesetzt. Falls es <code
                    class="literal">1</code> ist, weist dies das Hilfsprogramm <code
                    class="command">dump</code> darauf hin, dass die Partition Daten enthält, die gesichert werden müssen.
					</div></li><li
                class="listitem"><div
                  class="para">
						check order: dieses letzte Feld zeigt an, ob die Integrität des Dateisystems beim Hochfahren überprüft werden soll, und in welcher Reihenfolge diese Überprüfung durchgeführt werden soll. Falls es <code
                    class="literal">0</code> ist, wird keine Überprüfung durchgeführt. Das Wurzelverzeichnis sollte den Wert <code
                    class="literal">1</code> haben, während andere dauerhaft eingehängte Dateisysteme den Wert <code
                    class="literal">2</code> erhalten.
					</div></li></ul></div><div
            class="example"><a
              id="example.fstab"></a><p
              class="title"><strong>Beispiel 8.5. Beispiel der Datei <code
                  class="filename">/etc/fstab</code>:</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0
</pre></div></div><div
            class="para">
				Der letzte Eintrag dieses Beispiels bezieht sich auf ein Netzwerk-Dateisystem (NFS): das Verzeichnis <code
              class="filename">/shared/</code> auf dem Server <span
              class="emphasis"><em>arrakis</em></span> wird auf dem lokalen Rechner unter <code
              class="filename">/shared/</code> eingehängt. Das Format der Datei <code
              class="filename">/etc/fstab</code> ist auf der Handbuchseite <span
              class="citerefentry"><span
                class="refentrytitle">fstab</span>(5)</span> dokumentiert.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>WEITERE SCHRITTE</em></span> Selbstständiges Einhängen</strong></p></div></div></div><div
              class="para">
				Das Paket <span
                class="emphasis"><em>am-utils</em></span> stellt <code
                class="command">amd</code> zur Verfügung, ein Dienstprogramm zum selbstständigen Einhängen, das in der Lage ist, Wechselmedien bei Bedarf einzuhängen, wenn ein Benutzer versucht, auf ihren üblichen Einhängepunkt zuzugreifen. Es hängt diese Geräte wieder aus, wenn kein Prozess mehr auf sie zugreift.
			</div><a
              id="idm139686929787280"
              class="indexterm"></a><a
              id="idm139686929786160"
              class="indexterm"></a><a
              id="idm139686929785040"
              class="indexterm"></a><a
              id="idm139686929783920"
              class="indexterm"></a><a
              id="idm139686929782800"
              class="indexterm"></a><div
              class="para">
				Es gibt weitere Dienstprogramme zum selbstständigen Einhängen, wie zum Beispiel <code
                class="command">automount</code> im Paket <span
                class="emphasis"><em>autofs</em></span>.
			</div><div
              class="para">
				Beachten Sie auch, dass GNOME, KDE und andere grafische Arbeitsplatzumgebungen mit dem System <span
                class="emphasis"><em>udisks</em></span> zusammenarbeiten und automatisch Wechselmedien einhängen können, wenn diese angeschlossen werden.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.locate-updatedb"></a>8.9.6. <code
                    class="command">locate</code> und <code
                    class="command">updatedb</code></h3></div></div></div><a
            id="idm139686929777168"
            class="indexterm"></a><a
            id="idm139686929776048"
            class="indexterm"></a><a
            id="idm139686929774928"
            class="indexterm"></a><div
            class="para">
				Der Befehl <code
              class="command">locate</code> kann den Ort einer Datei finden, wenn Sie nur einen Teil ihres Namens kennen. Er zeigt das Ergebnis fast sofort an, da er in einer Datenbank nachschlägt, die den Ort aller auf dem System befindlichen Dateien speichert; diese Datenbank wird täglich durch den Befehl <code
              class="command">updatedb</code> aktualisiert. Es gibt -zig Implementierungen des Befehls <code
              class="command">locate</code> und Debian hat <span
              class="pkg pkg">mlocate</span> für sein Standard-System gewählt.
			</div><div
            class="para">
				<code
              class="command">mlocate</code> ist so intelligent, dass es nur Dateien zurückliefert, auf die der Anwender Zugriff hat, auch wenn die zugrundeliegende Datenbank alle Dateien auf dem System kennt (weil die Implementierung des zugehörigen <code
              class="command">updatedb</code> ohne Root-Rechte läuft). Als zusätzliche Absicherung kann der Administrator mit <code
              class="varname">PRUNEDPATHS</code> in <code
              class="filename">/etc/updatedb.conf</code> einzelne Verzeichnisse von der Indexierung ausschließen.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>Zurück</strong>8.8. Den Boot-Loader konfigurieren</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>Weiter</strong>8.10. Einen Kernel kompilieren</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.config-misc.html">ar-MA</a></li><li><a
              href="../da-DK/sect.config-misc.html">da-DK</a></li><li><a
              href="../de-DE/sect.config-misc.html">de-DE</a></li><li><a
              href="../el-GR/sect.config-misc.html">el-GR</a></li><li><a
              href="../en-US/sect.config-misc.html">en-US</a></li><li><a
              href="../es-ES/sect.config-misc.html">es-ES</a></li><li><a
              href="../fa-IR/sect.config-misc.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.config-misc.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.config-misc.html">hr-HR</a></li><li><a
              href="../id-ID/sect.config-misc.html">id-ID</a></li><li><a
              href="../it-IT/sect.config-misc.html">it-IT</a></li><li><a
              href="../ja-JP/sect.config-misc.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.config-misc.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.config-misc.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.config-misc.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.config-misc.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.config-misc.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.config-misc.html">zh-CN</a></li></ul></div></body></html>
