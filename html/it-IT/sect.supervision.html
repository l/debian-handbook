<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Supervisione: prevenire, rilevare, dissuadere</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="security.html"
        title="Capitolo 14. Sicurezza" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall o filtraggio dei pacchetti" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Introduzione a AppArmor" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/it-IT/sect.supervision.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.supervision"></a>14.3. Supervisione: prevenire, rilevare, dissuadere</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			Il monitoraggio è parte integrante di ogni politica di sicurezza per svariati motivi. Tra questi, il fatto che l'obiettivo della sicurezza non è solitamente limitato soltanto alla garanzia della riservatezza dei dati, ma include anche l'assicurazione alla disponibilità dei servizi. È quindi obbligatorio verificare che tutto funzioni come previsto, e rilevare in maniera tempestiva ogni comportamento anomalo o variazione nella qualità dei(l) servizi(o) erogati(o). L'attività di monitoraggio permette di evidenziare tentativi di intrusione e permette di reagire rapidamente prima che si possa arrivare a gravi conseguenze. Questa sezione passa in rassegna alcuni strumenti che possono essere usati per monitorare molti degli aspetti di un sistema Debian. Come tale, completa <a
            class="xref"
            href="sect.monitoring.html">Sezione 12.4, «Monitoraggio»</a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.logcheck"></a>14.3.1. Monitorare i log con <code
                    class="command">logcheck</code></h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				Il comando <code
              class="command">logcheck</code> monitora i file di log ogni ora per impostazione predefinita. Invia messaggi di log inconsueti via email all'amministratore per analisi più approfondite.
			</div><div
            class="para">
				La lista dei file monitorati è salvata in <code
              class="filename">/etc/logcheck/logcheck.logfiles</code>; i valori predefiniti funzionano bene se il file <code
              class="filename">/etc/rsyslog.conf</code> non è stato completamente stravolto.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> lavora in uno di tre modi più o meno dettagliati: <span
              class="emphasis"><em>paranoid</em></span>, <span
              class="emphasis"><em>server</em></span> e <span
              class="emphasis"><em>workstation</em></span>. Il primo è <span
              class="emphasis"><em>molto</em></span> prolisso, e dovrebbe essere usato solo per server specifici come i firewall. Il secondo modo (predefinito) è consigliato per la maggior parte dei server. L'ultimo è progettato per le workstation, ed è ancora più conciso (filtra maggiormente i messaggi).
			</div><div
            class="para">
				In tutti e tre i casi, <code
              class="command">logcheck</code> probabilmente dovrà essere personalizzato escludendo alcuni messaggi extra (a seconda dei servizi installati), a meno che l'amministratore non voglia veramente ricevere ammassi orari di lunghe e noiose email. Poiché il meccanismo di selezione dei messaggi è piuttosto complesso, il file <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> è una lettura consigliata, anche se impegnativa.
			</div><div
            class="para">
				Le regole applicate possono essere suddivise in varie tipologie:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						quelle che qualificano il messaggio come un tentativo di intrusione (memorizzato in un file nella directory <code
                    class="filename">/etc/logcheck/cracking.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						quelle che cancellano tale qualifica (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						quelle che classificano il messaggio come un allarme di sicurezza (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						quelle che cancellano questa classificazione (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						infine, quelle che si applicano ai rimanenti messaggi (considerati come <span
                    class="emphasis"><em>eventi di sistema</em></span>).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATTENZIONE</em></span> Ignorare un messaggio</strong></p></div></div></div><div
              class="para">
				Tutti i messaggi etichettati come tentativo di intrusione oppure come allarme di sicurezza (seguendo una regola memorizzata in un file <code
                class="filename">/etc/logcheck/violations.d/miofile</code>) possono essere ignorati solamente tramite una regola nei file <code
                class="filename">/etc/logcheck/violations.ignore.d/miofile</code> oppure <code
                class="filename">/etc/logcheck/violations.ignore.d/miofile-<em
                  class="replaceable">estensione</em></code>.
			</div></div><div
            class="para">
				Un evento di sistema è sempre segnalato a meno che una regola in una directory <code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> stabilisca che l'evento debba essere ignorato. Le sole directory prese in considerazione sono esclusivamente quelle corrispondenti ad un livello di prolissità maggiore o uguale alla modalità di funzionamento selezionata.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.monitoring-activity"></a>14.3.2. Attività di monitoraggio</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.real-time-monitoring"></a>14.3.2.1. In tempo reale</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> è uno strumento interattivo che mostra l'elenco dei processi attualmente in esecuzione. L'ordinamento predefinito è basato sull'utilizzo corrente del processore e può essere ottenuto con il tasto <span
                class="keycap"><strong>P</strong></span>. Altri tipi di ordinamento sono per occupazione di memoria (tasto <span
                class="keycap"><strong>M</strong></span>), per tempo totale di processore (tasto <span
                class="keycap"><strong>T</strong></span>) e per identificatore di processo (tasto <span
                class="keycap"><strong>N</strong></span>). Il tasto <span
                class="keycap"><strong>k</strong></span> permette di terminare un processo inserendo il suo identificatore di processo. Il tasto <span
                class="keycap"><strong>r</strong></span> permette il <span
                class="emphasis"><em>renice</em></span> di un processo, cioè la variazione della sua priorità.
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					Quando il sistema sembra essere sovraccarico, <code
                class="command">top</code> è uno strumento fondamentale per capire quali processi competono per il tempo di processore o consumano troppa memoria. In particolare, spesso è interessante controllare se il processo che utilizza le risorse corrisponde realmente ad un servizio che la macchina mette a disposizione. Un processo sconosciuto in esecuzione con utente www-data dovrebbe subito saltare all'occhio ed essere controllato, dato che potenzialmente potrebbe essere l'istanza di un programma installato ed eseguito nel sistema attraverso la vulnerabilità di un'applicazione web.
				</div><div
              class="para">
					<code
                class="command">top</code> è uno strumento molto flessibile e le pagine del manuale riportano i dettagli di come modificarne la visualizzazione e adattarla alle abitudini e bisogni personali.
				</div><div
              class="para">
					Lo strumento grafico <code
                class="command">gnome-system-monitor</code> è simile a <code
                class="command">top</code> e fornisce più o meno le stesse caratteristiche.
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.monitoring-history"></a>14.3.2.2. Storico</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					Il carico del processore, il traffico di rete e lo spazio libero su disco sono informazioni che variano costantemente. Mantenere uno storico della loro evoluzione spesso è utile nel determinare esattamente come viene utilizzato un computer.
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					Esistono molti strumenti dedicati a questo compito. La maggior parte può recuperare dati via SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) al fine di centralizzare l'informazione. Un ulteriore beneficio è che si possono recuperare dati da elementi di rete che non necessariamente sono computer generici, come ad esempio switch di rete o router dedicati.
				</div><div
              class="para">
					Questo libro tratta Munin in dettaglio (vedere <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Sezione 12.4.1, «Impostazione di Munin»</a>) come parte di <a
                class="xref"
                href="advanced-administration.html">Capitolo 12: «<em>Amministrazione avanzata</em>»</a>. Debian fornisce anche un altro strumento simile, <span
                class="pkg pkg">cacti</span>. La sua installazione è leggermente più complessa, poiché si basa solo su SNMP. Pur disponendo di un'interfaccia web, capire i concetti coinvolti nella configurazione richiede ancora qualche sforzo. La lettura della documentazione HTML (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) deve essere considerata un prerequisito.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (nel pacchetto che ha lo stesso nome) è un vecchio strumento. Nonostante sia un po' grezzo, può aggregare dati storici e visualizzarli sotto forma di grafici. Il pacchetto comprende una serie di script dedicati alla raccolta dei dati monitorati più diffusi come il carico del processore, il traffico di rete, le visite alle pagine web e così via.
				</div><div
                class="para">
					I pacchetti <span
                  class="pkg pkg">mrtg-contrib</span> e <span
                  class="pkg pkg">mrtgutils</span> contengono script di esempio che possono essere utilizzati direttamente.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="id-1.17.6.6"></a>14.3.3. Rilevare le modifiche</h3></div></div></div><div
            class="para">
				Una volta che il sistema è installato e configurato, a meno di aggiornamenti di sicurezza, la maggior parte dei file e directory rimangono statici, dati a parte. È allora interessante fare in modo che i file realmente non possano cambiare: ogni variazione inattesa dovrebbe perciò catturare la nostra attenzione. Questa sezione presenta alcuni strumenti che permettono di monitorare i file e di avvisare l'amministratore quando si verificano cambiamenti non previsti (o semplicemente di elencarli).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.dpkg-verify"></a>14.3.3.1. Revisione dei Pacchetti con <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>APPROFONDIMENTI</em></span> Proteggere contro le modifiche degli autori originali</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> è utile nel segnalare variazioni ai file forniti dai pacchetti Debian, ma è inutile se il pacchetto stesso è compromesso, per esempio quando il mirror Debian è compromesso. Proteggersi da questa tipologia di attacchi implica l'uso del sistema di verifica delle firme digitali di APT (vedere <a
                  class="xref"
                  href="sect.package-authentication.html">Sezione 6.5, «Controllare l'autenticità dei pacchetti»</a>), e fare in modo di installare solamente i pacchetti da un'origine certificata.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (o <code
                class="command">dpkg -V</code>) è un'interessante strumento che permette di trovare i file installati che sono stati modificati (potenzialmente da un hacker), ma questo dovrebbe essere preso con le pinze. Per fare il proprio lavoro si basa su checksum memorizzati sul proprio database dpkg sull'hard disk (posso essere trovati in <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>); un hacker scrupoloso aggiornerà quindi questi file in modo da contenere i nuovi checksum per i file modificati.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>FONDAMENTALI</em></span> File di Imponte Digitali</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					Promemoria: l'impronta digitale è un valore, spesso numerico (anche se in notazione esadecimale), che contiene una specie di firma del contenuto di un file. Questa firma è calcolata con un algoritmo (MD5 oppure SHA1 sono gli esempi più diffusi) che garantisce con buona probabilità che anche il più piccolo cambiamento nel contenuto del file porti ad una variazione nell'impronta digitale; è conosciuto come "effetto valanga". Ciò permette di usare un'impronta numerica semplice per verificare se il contenuto di un file è stato alterato. Questi algoritmi non sono reversibili; in altre parole, per la maggior parte di questi, conoscere un'impronta digitale non permette di ricavarne il contenuto corrispondente. Recenti progressi matematici sembra abbiano però indebolito la sicurezza di questi principi, ma il loro uso finora non è stato messo in discussione, dal momento che sembra ancora piuttosto difficile creare contenuti differenti con la stessa impronta digitale.
				</div></div><div
              class="para">
					L'esecuzione di <code
                class="command">dpkg -V</code> verificherà tutti i pacchetti installati e stamperà una riga per ogni file con test fallito. Il formato è uguale a quello di <code
                class="command">rpm -V</code> dove ogni carattere indica un test su alcuni meta-dati specifici. Purtroppo <code
                class="command">dpkg</code> non memorizza i meta-dati necessari per la maggior parte dei test e quindi questi saranno contrassegnati con un punto interrogativo. Attualmente solo il test di checksum può produrre un "5" sul terzo carattere (quando fallisce).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					Nell'esempio sopra, dpkg riporta una modifica al file del servizio SSH che l'amministratore ha fatto al file compresso invece di usare un'appropriata sovrascrittura di <code
                class="filename">/etc/systemd/system/ssh.service</code> (che potrebbe essere memorizzata in <code
                class="filename">/etc</code> come dovrebbe essere ogni altro file di configurazione). Elenca anche più file di configurazione (identificati dalla lettera "c" sul secondo campo) che sono stati legittimamente modificati.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.debsums"></a>14.3.3.2. Controllo dei pacchetti: <code
                      class="command">debsums</code> e i suoi limiti</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> è l'antenato di <code
                class="command">dpkg -V</code> ed è quindi in gran parte obsoleto.Ha gli stessi limiti di di dpkg. Fortunatamente, alcune delle limitazioni posso eseere aggirate (mentre dpkg non offre questa possibilità).
				</div><div
              class="para">
					Dal momento che i dati su disco non possono essere sicuri, <code
                class="command">debsums</code> offre la possibilità di fare i controlli sulla base dei file <code
                class="filename">.deb</code> anzichè affidarsi al database di dpkg. Per scaricare i file <code
                class="filename">.deb</code> fidati di tutti i pacchetti installati, possiamo contare solo sui download autenticati di APT. Questa operazione può essere lenta e noiosa, e quindi non dovrebbe essere considerata una tecnica proattiva da utilizzare in modo abituale.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Da notare che questo esempio utilizza il comando <code
                class="command">grep-status</code> del pacchetto <span
                class="pkg pkg">dctrl-tools</span>, che non è installato in modo predefinito.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="id-1.17.6.6.5"></a>14.3.3.3. Monitorare i file: AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					Lo strumento AIDE (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) permette di verificare l'integrità dei file e rileva tutti i cambiamenti rispetto ad una immagine valida archiviata del sistema. Questa immagine viene memorizzata in un database (<code
                class="filename">/var/lib/aide/aide.db</code>) contenente le informazioni significative di tutti i file del sistema (impronte digitali, permessi, data e ora e così via). Questo database viene generato inizialmente con <code
                class="command">aideinit</code>; esso viene poi utilizzato su base giornaliera (dallo script <code
                class="filename">/etc/cron.daily/aide</code>) per verificare che non sia cambiato nulla di significativo. Quando viene rilevata una modifica, AIDE la elenca nei file di log (<code
                class="filename">/var/log/aide/*.log</code>) e invia i risultati via email all'amministratore.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN PRATICA</em></span> Proteggere il database</strong></p></div></div></div><div
                class="para">
					Dal momento che AIDE usa un database locale per confrontare lo stato dei file, l'affidabilità dei suoi risultati è direttamente legata alla validità del suo database. Se un autore di un attacco acquisisce i permessi di root su un sistema compromesso, sarà in grado di sostituire il database per nascondere le sue tracce. Una possibile soluzione è quella di salvare i relativi dati su un supporto a sola lettura.
				</div></div><div
              class="para">
					Sono presenti molte opzioni in <code
                class="filename">/etc/default/aide</code> per modificare il comportamento del pacchetto <span
                class="pkg pkg">aide</span>. La configurazione vera e propria di AIDE viene memorizzata in <code
                class="filename">/etc/aide/aide.conf</code> e <code
                class="filename">/etc/aide/aide.conf.d/</code> (in realtà, questi file vengono utilizzati da <code
                class="command">update-aide.conf</code> per generare <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code>). La configurazione indica quali proprietà di quali file devono essere controllate. Per esempio, il contenuto dei file di log cambia regolarmente, e tali cambiamenti possono essere ignorati fino a quando i permessi di questi file rimangono invariati, ma sia il contenuto che i permessi dei programmi eseguibili devono rimanere costanti. Anche se non molto complessa, la sintassi della configurazione non è del tutto intuitiva, ed è quindi consigliato leggere la pagina di manuale <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span>.
				</div><div
              class="para">
					Una nuova versione del database è generata giornalmente in <code
                class="filename">/var/lib/aide/aide.db.new</code>; se tutte le variazioni raccolte sono legittime, viene usato per sostituire il database di riferimento.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire e Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire è molto simile ad AIDE; anche la sintassi del file di configurazione è bene o male la stessa. La principale novità fornita da <span
                  class="pkg pkg">tripwire</span> è il meccanismo di firma del file di configurazione, affinché un autore di un attacco non possa associarlo a una diversa versione del database di riferimento.
				</div><div
                class="para">
					Anche Samhain offre caratteristiche simili, oltre ad alcune funzioni per permettere la rilevazione dei rootkit (vedere il riquadro <a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"><span
                    class="emphasis"><em>APPROFONDIMENTI</em></span> I pacchetti <span
                    class="pkg pkg">checksecurity</span> e <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span></a>). Può anche essere distribuito globalmente in rete, memorizzando i suoi risultati in un server centrale (con firma).
				</div></div><div
              class="sidebar"><a
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>APPROFONDIMENTI</em></span> I pacchetti <span
                          class="pkg pkg">checksecurity</span> e <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span></strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					Il primo di questi pacchetti contiene numerosi script brevi che eseguono controlli di base sul sistema (password vuote, nuovi file con setuid e così via) e avvertono l'amministratore se necessario. Nonostante il suo nome esplicito, un amministratore non dovrebbe affidarsi solamente ad esso per garantire la sicurezza di un sistema Linux.
				</div><div
                class="para">
					I pacchetti <span
                  class="pkg pkg">chkrootkit</span> e <span
                  class="pkg pkg">rkhunter</span> permettono di cercare <span
                  class="emphasis"><em>rootkit</em></span> potenzialmente installati nel sistema. Come promemoria, un rootkit è una parte di software progettata per nascondere il fatto che il sistema è compromesso mentre mantiene in modo discreto il controllo sulla macchina. I test non sono affidabili al 100%, ma solitamente riescono ad attirare l'attenzione dell'amministratore su potenziali problemi.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.intrusion-detection"></a>14.3.4. Rilevare intrusioni (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>FONDAMENTALI</em></span> «Denial of service»</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				Un attacco «denial of service» ha un solo scopo: bloccare la disponibilità di un servizio. Che un attacco di questo tipo implichi il sovraccarico del server tramite interrogazioni o lo sfruttamento di un bug, il risultato finale è il medesimo: il servizio non è più fruibile. Gli utenti ordinari sono scontenti, e il soggetto che ospita il servizio di rete preso di mira subisce una perdita di reputazione (e probabilmente di ricavi, per esempio se il servizio è un sito di e-commerce).
			</div><div
              class="para">
				Un attacco di questo tipo si presenta talvolta "distribuito"; di solito si causa un sovraccarico del server attraverso una grande quantità di interrogazioni provenienti da numerose sorgenti distinte portando all'incapacità di rispondere alle interrogazioni legittime. A queste tipologie di attacchi sono stati associati acronimi ben conosciuti: <acronym
                class="acronym">DDoS</acronym> e <acronym
                class="acronym">DoS</acronym> (a seconda che il denial of service sia distribuito o meno).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (nel pacchetto Debian con lo stesso nome) è un NIDS — un <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. La sua funzione è quella di mettersi in ascolto sulla rete e cercare di rilevare tentativi di infiltrazione e/o atti ostili (inclusi attacchi denial of service). Tutti questi eventi vengono raccolti in file multipli in <code
              class="filename">/var/log/suricata</code>. Ci sono strumenti di terze parti (Kibana/logstash) per consultare al meglio i dati raccolti. <div
              class="url">→ <a
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              class="url">→ <a
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATTENZIONE</em></span> Raggio d'azione</strong></p></div></div></div><div
              class="para">
				L'efficacia di <code
                class="command">suricata</code> è limitata al traffico che transita sull'interfaccia di rete monitorata. Ovviamente non sarà in grado di rilevare alcunché se non può osservare il traffico reale. Quando è collegato ad uno switch di rete, rileverà quindi solo gli attacchi alla macchina nella quale è in esecuzione, cosa che probabilmente non è ciò che si desidera. La macchina che ospita <code
                class="command">suricata</code> dovrà perciò essere connessa ad una porta "mirror" dello switch, che è solitamente riservata a collegare altri switch e quindi rileva il traffico complessivo.
			</div></div><div
            class="para">
				La configurazione di suricata implica la configurazione e la modifica di <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, che è molto lunga poichè ogni parametro è abbondantemente commentato. Una configurazione minima richiede che venga descritto l'intervallo di indirizzi coperti dalla rete locale (parametro <code
              class="literal">HOME_NET</code>). In pratica, questo significa l'insieme di tutti i potenziali obiettivi d'attacco. Ma per ottenere la maggior parte di queste cose è richiesta la lettura in tutto ed adattandola alla situazione locale.
			</div><div
            class="para">
				Prima di questo, si dovrebbe modificare anche il file <code
              class="filename">/etc/default/suricata</code> per definire l'interfaccia di rete da monitorare e consentire lo script di init (impostando <code
              class="literal">RUN=yes</code>). Si potrebbe anche voler impostare <code
              class="literal">LISTENMODE=pcap</code> perchè per impostazione predefinita <code
              class="literal">LISTENMODE=nfqueue</code> richiede un'ulteriore configurazione per funzionare correttamente (il firewall netfilter deve essere configurato per far passare i pacchetti in qualche coda dello spazio utente gestito da suricata tramite il target <code
              class="literal">NFQUEUE</code>).
			</div><div
            class="para">
				Per rilevare un comportamento malevolo, <code
              class="command">suricata</code> ha bisogno di un insieme di regole di monitoraggio: è possibile trovare le regole nel pacchetto <span
              class="pkg pkg">snort-rules-default</span>. <code
              class="command">snort</code> è il riferimento storico nell'ecosistema IDS e <code
              class="command">suricata</code> è in grado di riutilizzare le regole scritte per esso. Purtroppo questo pacchetto manca da <span
              class="distribution distribution">Debian Jessie</span> e deve essere recuperato da un altro rilascio di Debian come <span
              class="distribution distribution">Testing</span> o <span
              class="distribution distribution">Unstable</span>.
			</div><div
            class="para">
				In alternativa, può essere usato <code
              class="command">oinkmaster</code> (nel apchhetto dello stesso nome) per scaricare di set di regole di Snort da fonti esterne.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>APPROFONDIMENTI</em></span> Integrazione con <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude permette il monitoraggio centralizzato delle informazioni di sicurezza. La sua architetture modulare fornisce un server (il <span
                class="emphasis"><em>manager</em></span> in <span
                class="pkg pkg">prelude-manager</span>) che raccoglie gli allarmi generati da <span
                class="emphasis"><em>sensori</em></span> di varie tipologie.
			</div><div
              class="para">
				Suricata può essere configurato come un sensore. Altre possibilità includono <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) che controlla i file di log (in maniera del tutto simile a <code
                class="command">logcheck</code>, descritto in <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Sezione 14.3.1, «Monitorare i log con <code
                  class="command">logcheck</code>»</a>).
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Indietro</strong>14.2. Firewall o filtraggio dei pacchetti</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Avanti</strong>14.4. Introduzione a AppArmor</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.supervision.html">ar-MA</a></li><li><a
              href="../da-DK/sect.supervision.html">da-DK</a></li><li><a
              href="../de-DE/sect.supervision.html">de-DE</a></li><li><a
              href="../el-GR/sect.supervision.html">el-GR</a></li><li><a
              href="../en-US/sect.supervision.html">en-US</a></li><li><a
              href="../es-ES/sect.supervision.html">es-ES</a></li><li><a
              href="../fa-IR/sect.supervision.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.supervision.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.supervision.html">hr-HR</a></li><li><a
              href="../id-ID/sect.supervision.html">id-ID</a></li><li><a
              href="../it-IT/sect.supervision.html">it-IT</a></li><li><a
              href="../ja-JP/sect.supervision.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.supervision.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.supervision.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.supervision.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.supervision.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.supervision.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.supervision.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.supervision.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.supervision.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.supervision.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.supervision.html">zh-TW</a></li></ul></div></body></html>
