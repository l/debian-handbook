<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.3. Funzionamento Interno di un Computer: i Diversi Livelli Coinvolti</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Processo, Gerarchia, Comandi Base" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Appendice B. Breve Corso di Recupero" /><link
        rel="prev"
        href="sect.filesystem-hierarchy.html"
        title="B.2. Organizzazione della Gerarchia del Filesystem" /><link
        rel="next"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Alcuni Compiti di cui si occupa il Kernel" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/it-IT/sect.computer-layers.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.filesystem-hierarchy.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-role-and-tasks.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.computer-layers"></a>B.3. Funzionamento Interno di un Computer: i Diversi Livelli Coinvolti</h2></div></div></div><div
          class="para">
			Un computer è spesso considerato come qualcosa piuttosto astratto, e l'interfaccia visibile esternamente è molto più semplice rispetto alla complessità interna. Tale complessità deriva in parte dal numero di pezzi coinvolti. Tuttavia, questi pezzi possono essere visualizzati in strati, dove uno strato interagisce solo con quelli immediatamente sopra o sotto.
		</div><div
          class="para">
			Un utente finale può utilizzarlo senza conoscere questi dettagli... fino a quando tutto funziona. Quando si affronta un problema come, "Internet non funziona!", la prima cosa da fare è identificare in quale strato ha avuto origine il problema. La scheda di rete (hardware) funziona? E' riconosciuta dal computer? Il kernel Linux la vede? I parametri di rete sono configurati correttamente? Tutte queste domande isolano uno strato adeguato e mettono a fuoco la potenziale fonte del problema.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware"></a>B.3.1. Lo Strato più Profondo: l'Hardware</h3></div></div></div><a
            id="id-1.21.6.4.2"
            class="indexterm"></a><a
            id="id-1.21.6.4.3"
            class="indexterm"></a><a
            id="id-1.21.6.4.4"
            class="indexterm"></a><a
            id="id-1.21.6.4.5"
            class="indexterm"></a><a
            id="id-1.21.6.4.6"
            class="indexterm"></a><a
            id="id-1.21.6.4.7"
            class="indexterm"></a><a
            id="id-1.21.6.4.8"
            class="indexterm"></a><a
            id="id-1.21.6.4.9"
            class="indexterm"></a><div
            class="para">
				Cominciamo con un promemoria base che un computer è, prima di tutto, un insieme di elementi hardware. C'è generalmente una scheda principale (nota come <span
              class="emphasis"><em>scheda madre</em></span>), con uno (o più) processori, qualche RAM, controller di dispositivi, e slot di espansione per schede aggiuntive (per altri controller di dispositivi). I più degni di nota tra questi controller sono gli IDE (Parallel ATA), SCSI e Serial ATA, per il collegamento di dispositivi di memorizzazione come gli hard disk. Altri controller includono l'USB, che è in grado di ospitare una grande varietà di dispositivi (che vanno dalle webcam ai termometri, dalle tastiere ai sistemi di automazione domestica) e l'IEEE 1394 (Firewire). Questi controller spesso consentono il collegamento di più dispositivi così il sottosistema completo gestito da un controller è quindi generalmente noto come "bus". Schede opzionali includono le schede grafiche (alle quali verranno collegati gli schermi dei monitor), le schede audio, le schede di rete, e così via. Alcune schede madri hanno già integrate queste caratteristiche, e non hanno bisogno di schede aggiuntive.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN PRACTICA</em></span> Verifica dell'hardware</strong></p></div></div></div><div
              class="para">
				La veririfica che una parte di hardware funzioni può essere difficile. D'altra parte, dimostrare che non funziona è qualche volta abbastanza semplice.
			</div><div
              class="para">
				Un hard disk è fatto di piatti rotanti e testine magnetica in movimento. Quando un hard disk si accende, il motore del piatto fa un ronzio caratteristico. E dissipa anche energia come calore. Di conseguenza, un disco rigido che rimane freddo e silenzioso quando acceso è rotto.
			</div><div
              class="para">
				Le schede di rete spesso includono LED che mostrano lo stato del collegamento. Se un cavo è collegato ad un hub di rete funzionante o ad uno switch, almeno un LED si accende. Se non si accende nessun LED, o la scheda stessa, o il dispositivo di rete, oppure il cavo tra di loro, è difettoso. Il passo successivo è quindi testare ciascun componente singolarmente.
			</div><div
              class="para">
				Alcune schede opzionali - le schede video 3D in particolare - includono dispositivi di raffreddamento, come i dissipatori di calore e/o ventilatori. Se la ventola non gira anche se la scheda è alimentata, una spiegazione plausibile è la scheda sia surriscaldata. Questo vale anche per il processore(i) principale(i) situato(i) sulla scheda madre.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.bios"></a>B.3.2. L'Avviatore: il BOIS o l'UEFI</h3></div></div></div><a
            id="id-1.21.6.5.2"
            class="indexterm"></a><a
            id="id-1.21.6.5.3"
            class="indexterm"></a><a
            id="id-1.21.6.5.4"
            class="indexterm"></a><div
            class="para">
				L'hardware, da solo, non è in grado di eseguire operazioni utili il corrispondente pezzo di software che lo guidi. Il controllo e l'interazione con l'hardware è lo scopo del sistema operativo e delle applicazioni. Questi, a loro volta, richiedono hardware funzionale per essere eseguiti.
			</div><div
            class="para">
				Questa simbiosi tra hardware e software non avviene da sola. Quando il computer viene acceso dapprima, sono necessarie alcune configurazioni iniziali. Questo compito è assunto dal BIOS o dall'UEFI, un pezzo di software incluso nella scheda madre che si avvia automaticamente al momento dell'accensione. Il suo compito principale è cercare un software a cui possa cui trasferire il controllo. Di solito, nel caso del BIOS, questo comporta la ricerca del primo disco rigido con settore d'avvio (noto anche come <span
              class="emphasis"><em>master boot record</em></span> o <acronym
              class="acronym">MBR</acronym>), per caricare il settore d'avvio, ed eseguirlo. Da quel momento in poi, il BIOS di solito non è più coinvolto (fino al successivo avvio). Nel caso di EUFI, il processo comporta anche la scansione dei dischi per trovare una partizione EFI dedicata contenente ulteriori applicazioni EFI da eseguire.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>STRUMENTO</em></span> Impostare, lo strumento di configurazione del BIOS/UEFI</strong></p></div></div></div><a
              id="id-1.21.6.5.7.2"
              class="indexterm"></a><div
              class="para">
				Il BIOS/UEFI contiene anche un software chiamato programma di installazione, progettato per consentire di configurare gli spetti del computer. In particolare, consente di scegliere il dispositivo d'avvio preferito (per esempio, il floppy disk o il CD-ROM), di impostare l'orologio di sistema, e così via. L'avvio del setup di solito si ottiene premendo molto presto un tastosubito dopo che il computer si è acceso. Questo tasto è spesso <span
                class="keycap"><strong>Del</strong></span> o <span
                class="keycap"><strong>Esc</strong></span>, a volte <span
                class="keycap"><strong>F2</strong></span> o <span
                class="keycap"><strong>F10</strong></span>. L amggior parte delle volte, la scelta è visualizzata sullo schermo durante l'avvio.
			</div></div><div
            class="para">
				Il settore di avvio (o la partizione EFI), a sua volta, contiene un'altro pezzo di software, chiamato bootloader, il cui scopo è quello di trovare ed eseguire un sistema operativo. Dal momento che questo bootloader non è incorporato nella scheda madre, ma è caricato dal disco, può avere più funzionalità del BIOS, il che spiega perché il BIOS non carica il sistema operativo stesso. Ad esempio, il bootloader (spesso GRUB su sistemi Linux) può elencare i sistemi operativi disponibili e chiedere all'utente di sceglierne uno. Di solito, viene fornita una scelta predefinita ed una di timeout. A volte l'utente può anche scegliere di aggiungere parametri da passare al kernel, e così via. Alla fine, un kernel viene trovato, caricato in memoria, ed eseguito.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> UEFI, un moderno sostituto del BIOS</strong></p></div></div></div><a
              id="id-1.21.6.5.9.2"
              class="indexterm"></a><a
              id="id-1.21.6.5.9.3"
              class="indexterm"></a><div
              class="para">
				UEFI è uno sviluppo relativamente recente. La maggior parte dei nuovi computer supportano il boot UEFI, ma di solito hanno anche il supporto all'avvio da BIOS per retrocompatibilità con i sistemi operativi che non sono pronti a sfruttare UEFI.
			</div><div
              class="para">
				Questo nuovo sistema si libera di alcune delle limitazioni del BIOS: con l'utilizzo di una partizione dedicata, i bootloader non hanno più bisogno trucchi speciali per adattarsi in un piccolo <span
                class="emphasis"><em>master boot record</em></span> e poi scoprire il kernel da avviare. Ancora meglio, con un kernel Linux opportunamente costruito, UEFI può avviare direttamente il kernel senza alcun bootloader intermedio. UEFI è anche il fondamento di base usato per fornire <span
                class="emphasis"><em>Secure Boot</em></span>, una tecnologia per garantire che si esegua solo software convalidato dal produttore del sistema operativo.
			</div></div><div
            class="para">
				Il BIOS/UEFI è anche responsabile del rilevamento edell'inizializzazione di un numero di dispositivi. Ovviamente, questo include i dispositivi IDE/SATA (di solito hard disk e unità CD/DVD-ROM), ma anche i dispositivi PCI. I dispositivi rilevati sono spesso elencati sullo schermo durante il processo di avvio. Se questo elenco scorre troppo velocemente, utilizzare il tasto <span
              class="keycap"><strong>Pausa</strong></span> per fermarlo il tempo sufficiente per leggere. Dispositivi PCI installati che non vengono visualizzati sono un cattivo presagio. Nel peggiore dei casi, il dispositivo è difettoso. Nella migliore delle ipotesi, è semplicemente incompatibile con la versione corrente del BIOS o con la scheda madre. Le specifiche PCI si evolvono, e le vecchie scehde madri non garantiscono di gestire i dispositivi PCI più recenti.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.kernel"></a>B.3.3. Il Kernel</h3></div></div></div><div
            class="para">
				Sia il BIOS/EUFI che il bootloader sono eseguiti solo per pochi secondi ciascuno; ora stiamo ottenendo il primo pezzo di software che viene eseguito per un tempo più lungo, il kernel del sistema operativo. Questo kernel assume il ruolo di un direttore d'orchestra, e assicura il coordinamento tra hardware e software. Questo ruolo prevede diverse attività tra cui: guidare l'hardware, gestire i processi, gli utenti ed i permessi, il filesystem, e così via. Il kernel fornisce una base comune a tutti gli altri programmi sul sistema.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.userspace-presentation"></a>B.3.4. Lo Spazio Utente</h3></div></div></div><div
            class="para">
				Anche se tutto ciò che accade al di fuori del kernel può essere accomunato sottola dicitura "user space" (spazio utente), possiamo ancora separarlo in strati software. Tuttavia, le interazioni tra i processi esterni al kernel sono più complesse rispetto a prima, e le classificazioni possono non essere così semplici. Un'applicazione utilizza comunemente librerie, che a loro volta coinvolgono il kernel, ma le comunicazioni possono coinvolgere anche altri programmi, o anche altre librerie che si chiamano a vicenda.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.filesystem-hierarchy.html"><strong>Indietro</strong>B.2. Organizzazione della Gerarchia del Filesystem</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-role-and-tasks.html"><strong>Avanti</strong>B.4. Alcuni Compiti di cui si occupa il Kernel</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.computer-layers.html">ar-MA</a></li><li><a
              href="../da-DK/sect.computer-layers.html">da-DK</a></li><li><a
              href="../de-DE/sect.computer-layers.html">de-DE</a></li><li><a
              href="../el-GR/sect.computer-layers.html">el-GR</a></li><li><a
              href="../en-US/sect.computer-layers.html">en-US</a></li><li><a
              href="../es-ES/sect.computer-layers.html">es-ES</a></li><li><a
              href="../fa-IR/sect.computer-layers.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.computer-layers.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.computer-layers.html">hr-HR</a></li><li><a
              href="../id-ID/sect.computer-layers.html">id-ID</a></li><li><a
              href="../it-IT/sect.computer-layers.html">it-IT</a></li><li><a
              href="../ja-JP/sect.computer-layers.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.computer-layers.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.computer-layers.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.computer-layers.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.computer-layers.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.computer-layers.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.computer-layers.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.computer-layers.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.computer-layers.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.computer-layers.html">zh-TW</a></li></ul></div></body></html>
