<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Alcuni Compiti di cui si occupa il Kernel</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-it-IT-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Processo, Gerarchia, Comandi Base" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Appendice B. Breve Corso di Recupero" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Funzionamento Interno di un Computer: i Diversi Livelli Coinvolti" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. Lo Spazio Utente" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/it-IT/sect.kernel-role-and-tasks.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Alcuni Compiti di cui si occupa il Kernel</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Guidare l'Hardware</h3></div></div></div><div
            class="para">
				Il kernel ha, prima di tutto, il compito di controllare i componenti hardware, individuarli, avviarli quando il computer è acceso, e così via. Fornisce loro anche software di livello superiore con un'interfaccia di programmazione semplificata, cosicchè le applicazioni possono utilizzare i dispositivi senza doversi preoccupare di dettagli come ad esempio a quale slot di espansione è collegata la scheda aggiuntiva. L'interfaccia di programmazione prevede anche un livello di astrazione; questo permette al software di video-conferenza, ad esempio, di usare una webcam indipendentemente dalla sua marca e modello. Il software è in grado appena di utilizzare l'interfaccia <span
              class="emphasis"><em>Video for Linux</em></span> (V4L), ed il kernel traduce le chiamate di funzione di questa interfaccia nei comandi hardware effettivi necessari alla specifica webcam in uso.
			</div><div
            class="para">
				<a
              id="id-1.21.7.2.3.1"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.2"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.3"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.4"
              class="indexterm"></a> Il kernel esporta molti dettagli sull'hardware rilevato attraverso i filesystem virtuali <code
              class="filename">/proc/</code> e <code
              class="filename">/sys/</code>. Diversi strumenti riassumono questi dettagli. Tra questi, <code
              class="command">lspci</code> (nel pacchetto <span
              class="pkg pkg">pciutils</span>) elenca i dispositivi USB, e <code
              class="command">lspcmcia</code> (nel pacchetto <span
              class="pkg pkg">pcmciautils</span>) elenca le schede PCMCIA. Questi strumenti sono molto utili per identificare il modello esatto del dispositivo. Questa identificazione permette anche le ricerche più precise sul web, che a sua volta, porta a documenti più pertinenti.
			</div><div
            class="example"><a
              id="id-1.21.7.2.4"></a><p
              class="title"><strong>Esempio B.1. Esempio di informazioni fornite da <code
                  class="command">lspci</code> e <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Questi programmi hanno un'opzione <code
              class="literal">-v</code>, che riporta informazioni molto più dettagliate (ma di solito non è necessario). Infine, il comando <code
              class="command">lsdev</code> (nel pacchetto <span
              class="pkg pkg">procinfo</span>) elenca le risorse di comunicazione utilizzate dai dispositivi.
			</div><div
            class="para">
				Le applicazioni spesso accedono ai dispositivi per mezzo di file speciali creati all'interno della cartella <code
              class="filename">/dev/</code> (vedi riquadro <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>FONDAMENTALI</em></span> Permessi di accesso ai dispositivi</a>). Si tratta di file speciali che rappresentano le unità disco (per esempio, <code
              class="filename">/dev/hda</code> e <code
              class="filename">/dev/sdc</code>), le partizioni(<code
              class="filename">/dev/hda1</code> o <code
              class="filename">/dev/sdc3</code>), i mouse (<code
              class="filename">/dev/input/mouse0</code>), le tastiere (<code
              class="filename">/dev/input/event0</code>), le schede audio (<code
              class="filename">/dev/snd/*</code>), le porte seriali (<code
              class="filename">/dev/ttyS*</code>), e così via.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Filesystem</h3></div></div></div><a
            id="id-1.21.7.3.2"
            class="indexterm"></a><a
            id="id-1.21.7.3.3"
            class="indexterm"></a><div
            class="para">
				I filesystem sono uno degli aspetti più importanti del kernel. I sistemi unix uniscono tutti gli archivi in un'unica gerarchia, che permette agli utenti (ed alle applicazioni) di accedere ai dati semplicemente conoscendo la loro posizione all'interno di tale gerarchia.
			</div><div
            class="para">
				Il punto di partenza di questo albero gerarchico è chiamato radice (root), <code
              class="filename">/</code>. Questa directory può contenere sottodirectory. Ad esempio, la directory <code
              class="literal">home</code> sottodirectory di <code
              class="filename">/</code> è chiamata <code
              class="filename">/home/</code>. Questa sottodirectory può, a sua volta, contiene altre sottodirectory, e così via. Ogni directory può contenere anche file, in cui verranno memorizzati i dati effettivi. Così, il nome <code
              class="filename">/home/marco/Scrivania/ciao.txt</code> si riferisce ad un file chiamato <code
              class="literal">ciao.txt</code> memorizzato in <code
              class="literal">Scrivania</code> sottodirectory di <code
              class="literal">marco</code> sottodirectory della directory <code
              class="literal">home</code> presente nella radice. Il kernel fa la traduzione tra questo sistema di denominazione e la reale, fisica archiviazione su un disco.
			</div><div
            class="para">
				A differenza di altri sistemi, c'è solo un tale gerarchia, e può integrare dati da più dischi. Uno di questi dischi è usato come radice, e gli altri sono "montati" sulle directory nella gerarchia (il comando Unix è chiamato <code
              class="command">mount</code>); questi altri dischi sono poi disponibili sotto questi "punti di montaggio". Questo permette di memorizzare le directory home degli utenti (di solito memorizzate all'interno di <code
              class="filename">/home/</code>) su un secondo hard disk, che conterrà le directory <code
              class="literal">marco</code> e <code
              class="literal">grazia</code>. Una volta che il disco è montato in <code
              class="filename">/home/</code>, queste directory diventano accessibili alle loro solite posizioni, e percorsi come <code
              class="filename">/home/marco/Scrivania/ciao.txt</code> continueranno a funzionare.
			</div><a
            id="id-1.21.7.3.7"
            class="indexterm"></a><div
            class="para">
				Ci sono molti formati di filesystem, che corrispondono a molti modi per memorizzare fisicamente i dati sui dischi. I più conosciuti sono <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> ed <span
              class="emphasis"><em>ext4</em></span>, ma ne esistono altri. Ad esempio, <span
              class="emphasis"><em>vfat</em></span> è il sistema che è stato storicamente utilizzato dai sistemi operativi DOS e Windows, e che consente di utilizzare i disci rigidi sotto Debian così come in Windows. In questo caso, il filesystem deve essere preparato sul disco prima che venga montato e questa operazione è nota come "formattazione". I comandi come <code
              class="command">mkfs.ext3</code> (dove <code
              class="command">mkfs</code> sta per <span
              class="emphasis"><em>MaKe FileSystem</em></span>) gestiscono la formattazione. Questi comandi richiedono, come parametro, un file del dispositivo che rappresenta la partizione che deve essere formattata (per esempio, <code
              class="filename">/dev/sda1</code>). Questa operazione è distruttiva e deve essere eseguita una sola volta, a meno che non si voglia deliberatamente ripulire un filesystem e ricominciare da capo.
			</div><div
            class="para">
				Ci sono anche i file system di rete, come <acronym
              class="acronym">NFS</acronym>, in cui i dati non sono memorizzati su un disco locale. Invece, i dati vengono trasmessi attraverso la rete a un server che li memorizza e li recupera su richiesta. L'astrazione del filesystem protegge gli utenti dal dover fare attenzione: i file rimangono di solito accessibili in modo gerarchico.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Funzioni Condivise</h3></div></div></div><div
            class="para">
				Dal momento che un certo numero di stesse funzioni è utilizzato da tutti i software, ha senso che vengano centralizzate nel kernel. Ad esempio, la gestione del file system condiviso permette a qualsiasi applicazione semplicemente aprire un file per nome, senza la necessità di preoccuparsi del modo in cui il file è memorizzato fisicamente. Il file può essere memorizzato in parecchie parti diverse su un disco rigido, o diviso su più dischi rigidi, o anche memorizzato su un file server remoto. Le funzioni di comunicazione condivise vengono utilizzate dalle applicazioni per scambiare dati indipendentemente dal modo in cui i dati vengono trasportati. Per esempio, il trasporto potrebbe avvenire su qualsiasi combinazione di reti locali o wireless, o su un telefono fisso.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Gestione Processi</h3></div></div></div><a
            id="id-1.21.7.5.2"
            class="indexterm"></a><div
            class="para">
				Un processo è un'istanza di un programma in esecuzione. Ciò richiede memoria per memorizzare sia il programma che i suoi dati in esecuzione. Il kermel si occupa della creazione e del loro monitoraggio. Quando un programma viene eseguito, il kernel prima mette da parte un pò di memoria, quindi carica il codice eseguibile dal filesystem in esso, e poi avvia l'esecuzione del codice. Mantiene le informazioni su questo processo, delle quali la più visibile è il numero identificativo conosciuto come <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span>).
			</div><div
            class="para">
				I kernel Unix-like (incluso Linux), come la maggior parte dei sistemi operativi moderni, sono “multi-tasking”. In altre parole, permettono l'esecuzione di molti processi "contemporaneamente". In realtà c'è solo un processo in esecuzione in un dato momento, ma il kernel fraziona il tempo in intervalli ed esegue ogni processo a turno. Poiché questi intervalli di tempo sono molto brevi (in millisecondi), creano l'illusione di processi in esecuzione in parallelo, anche se in realtà sono attivi solo durante alcuni intervalli di tempo e inattivi il resto del tempo. Il lavoro del kernel è quello di regolare il suo meccanismo di pianificazione per mantenere questa illusione, massimizzando le prestazioni globali del sistema. Se gli intervalli di tempo sono troppo lunghi, l'applicazione potrebbe non mostrarsi così reattiva come si desidera. Se sono troppo brevi, il sitema perde tempo a passare da un lavoro (task) ad un'altro così di frequente. queste decisioni possono essere modificate attraverso le priorità dei processi. I processi ad alta priorità verranno eseguiti per più tempo e con intervalli più frequenti rispetto ai processi a bassa priorità.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Sistemi Multi-processore (e varianti)</strong></p></div></div></div><div
              class="para">
				La limitazione descritta sopra di un solo processo che può essere eseguito per volta, non si applica sempre. L'attuale restrizione è che ci può essere un solo processo in esecuzione <span
                class="emphasis"><em>per core di processore</em></span> alla volta. I sistemi multi-processore, multi-core o "hyper-threading" consentono l'esecuzione di più processi in parallelo. Lo stesso sistema time-slicing è ancora usato, anche se, per gestire i casi in cui vi sono processi più attivi che core disponibili. Questo è ben lungi dall'essere insolito: un sistema di base, anche uno in idle, quasi sempre ha decine di processi in esecuzione.
			</div></div><div
            class="para">
				Naturalmente, il kernel permette di eseguire diverse istanze indipendenti dello stesso programma. Ma ciascuno può accedere solo ai propri intervalli di tempo e memoria. I loro dati rimangono quindi indipendenti.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Gestione dei Diritti</h3></div></div></div><div
            class="para">
				I sistemi Unix-like sono anche multi-utente. Essi forniscono un sistema di gestione dei diritti che supporta utenti e gruppi separati; permette anche il controllo sulle azioni basate sulle autorizzazioni. Il kernel gestisce i dati per ogni processo, permettendo di controllare i permessi. La maggior parte del tempo, il processo è identificato dall'utente che lo ha iniziato. Tale processo è consentito solo per rendere quelle azioni disponibili al suo proprietario. Ad esempio, il tentativo di aprire un file richiede che il kernel controlli l'identità del processo contro le autorizzazioni di accesso (per maggiori dettagli su questo particolare esempio, vedere <a
              class="xref"
              href="sect.rights-management.html">Sezione 9.3, «Gestione dei permessi»</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Indietro</strong>B.3. Funzionamento Interno di un Computer: i Dive...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Avanti</strong>B.5. Lo Spazio Utente</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.kernel-role-and-tasks.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.kernel-role-and-tasks.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.kernel-role-and-tasks.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.kernel-role-and-tasks.html">zh-TW</a></li></ul></div></body></html>
