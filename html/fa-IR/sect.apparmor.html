<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.4. مقدمه‌ای بر AppArmor</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="فایروال, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="security.html"
        title="فصل 14. امنیت" /><link
        rel="prev"
        href="sect.supervision.html"
        title="14.3. نظارت: پیشگیری، شناسایی، بازدارندگی" /><link
        rel="next"
        href="sect.selinux.html"
        title="14.5. مقدمه‌ای بر SELinux" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/fa-IR/sect.apparmor.html" /></head><body
      dir="rtl"><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.supervision.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.selinux.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.apparmor"></a>14.4. مقدمه‌ای بر AppArmor</h2></div></div></div><a
          id="id-1.17.7.2"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.apparmor-principles"></a>14.4.1. اصول</h3></div></div></div><div
            class="para">
				AppArmor یک سیستم کنترل دسترسی ضروری یا <span
              class="emphasis"><em>Mandatory Access Control</em></span> (MAC) است که درون رابط ماژول‌های امنیتی لینوکس یا <span
              class="emphasis"><em>Linux Security Modules</em></span> (LSM) پیاده‌سازی شده است. در عمل، کرنل قبل از هر فراخوانی سیستمی از AppArmor پرس و جو می‌کند تا بداند آیا فرآیند مجاز به انجام عملیات مذکور است یا خیر. از طریق این مکانیزم، AppArmor برنامه‌ها را محدود به مجموعه کوچکی از منابع می‌کند.
			</div><a
            id="id-1.17.7.3.3"
            class="indexterm"></a><a
            id="id-1.17.7.3.4"
            class="indexterm"></a><div
            class="para">
				AppArmor مجموعه‌ای از قوانین (که بنام “پروفایل” شناخته می‌شوند) را روی هر برنامه اعمال می‌کند. پروفایل اعمال شده توسط کرنل وابسته با مکان نصب اولیه برنامه اجرایی است. بر خلاف SELinux (که در قسمت <a
              class="xref"
              href="sect.selinux.html">
      قسمت 14.5, “مقدمه‌ای بر SELinux”
    </a> توضیح داده شده است)، قوانین اعمال شده مبتنی بر کاربر نیستند. تمام کاربران هنگام اجرای برنامه مشابه از یک مجموعه قوانین پیروی می‌کنند (اما مجوزهای سنتی کاربری هنوز برقرار بوده و ممکن است عملکرد متفاوتی داشته باشند!).
			</div><div
            class="para">
				پروفایل‌های AppArmor در <code
              class="filename">/etc/apparmor.d/</code> ذخیره‌سازی شده و شامل فهرستی از قوانین کنترل دسترسی هستند که منابع مختلف را برای هر برنامه مشخص می‌کنند. پروفایل‌ها با استفاده از دستور <code
              class="command">apparmor_parser</code> کامپایل شده و درون کرنل قرار می‌گیرند. هر پروفایل تنها می‌تواند در یکی از حالت‌های enforcing یا complaining بارگیری شود. اولی با توجه به خط مشی امنیتی، تلاش‌های خرابکارانه را گزارش می‌دهد در صورتی که دومی اجباری در پیروی از خط مشی نداشته ولی فراخوانی‌های سیستمی غیرمجاز را ذخیره‌سازی می‌کند.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.apparmor-setup"></a>14.4.2. فعال‌سازی و مدیریت پروفایل‌های AppArmor</h3></div></div></div><div
            class="para">
				پشتیبانی از AppArmor در کرنل‌های استاندارد دبیان وجود دارد. از این رو، فعال‌سازی AppArmor به سادگی نصب چند بسته و افزودن برخی پارامترها به خط فرمان کرنل است:
			</div><pre
            class="screen"><code
              class="computeroutput"># </code><strong
              class="userinput"><code>apt install apparmor apparmor-profiles apparmor-utils
</code></strong><code
              class="computeroutput">[...]
# </code><strong
              class="userinput"><code>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</code></strong><code
              class="computeroutput"># </code><strong
              class="userinput"><code>update-grub
</code></strong></pre><div
            class="para">
				پس از راه‌اندازی مجدد سیستم، AppArmor عملیاتی بوده و می‌توان وضعیت آن را با استفاده از <code
              class="command">aa-status</code> بررسی کرد:
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-status</code></strong>
<code
              class="computeroutput">apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>یادداشت</em></span> پروفایل‌های بیشتر AppArmor</strong></p></div></div></div><div
              class="para">
				بسته <span
                class="pkg pkg">apparmor-profiles</span> شامل پروفایل‌هایی است که توسط جامعه کاربری AppArmor مدیریت می‌شوند. برای دریافت پروفایل‌های بیشتر می‌توانید بسته <span
                class="pkg pkg">apparmor-profiles-extra</span> را نصب کرده که شامل پروفایل‌های توسعه‌یافته توسط دبیان و اوبونتو می‌باشند.
			</div></div><div
            class="para">
				حالت هر پروفایل می‌تواند با استفاده از فراخوانی‌های <code
              class="command">aa-enforce</code> و <code
              class="command">aa-complain</code> به وضعیت enforcing و complaining تغییر یابد که اینکار به عنوان پارامتر در مسیر اجرایی برنامه یا مسیر فایل خطی مشی امنیتی صورت می‌پذیرد. به علاوه، یک پروفایل می‌تواند با استفاده از <code
              class="command">aa-disable</code> غیرفعال شده یا در حالت audit (برای ثبت فراخوانی‌های سیستمی مجاز) با استفاده از <code
              class="command">aa-audit</code> قرار گیرد.
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-enforce /usr/sbin/avahi-daemon</code></strong>
<code
              class="computeroutput">Setting /usr/sbin/avahi-daemon to enforce mode.</code>
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-complain /etc/apparmor.d/usr.bin.lxc-start</code></strong>
<code
              class="computeroutput">Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</code>
</pre></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.apparmor-new-profile"></a>14.4.3. ایجاد یک پروفایل جدید</h3></div></div></div><div
            class="para">
				با اینکه ایجاد یک پروفایل AppArmor کار ساده‌ای است، اما اکثر برنامه‌ها چنین پروفایلی ندارند. این قسمت به شما نشان می‌دهد که چطور می‌توان یک پروفایل جدید را از ابتدا و با استفاده از برنامه هدف ایجاد کرد تا AppArmor با مانیتور کردن فراخوانی سیستمی به آن بتواند منابع مصرفی‌اش را تحت نظر قرار دهد.
			</div><div
            class="para">
				مهمترین برنامه‌هایی که باید دسترسی محدود داشته باشند تحت شبکه بوده و آن‌هایی هستند که بیشتر هدف حملات راه‌دور قرار می‌گیرند. به همین دلیل است که AppArmor یک دستور متداول <code
              class="command">aa-unconfined</code> را فراهم می‌کند تا فهرستی از برنامه‌های تحت شبکه با سوکت باز که پروفایل مشخصی ندارند بدست آید. با گزینه <code
              class="literal">--paranoid</code> شما فهرستی از تمام فرآیندهای تعریف نشده که حداقل یک ارتباط فعال شبکه را دارند دریافت می‌کنید.
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-unconfined</code></strong>
<code
              class="computeroutput">801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</code>
</pre><div
            class="para">
				در مثال پیش رو، تلاش می‌کنیم که یک پروفایل برای <code
              class="command">/sbin/dhclient</code> ایجاد کنیم. برای این منظور از <code
              class="command">aa-genprof dhclient</code> استفاده می‌کنیم. این دستور از شما دعوت می‌کند تا از برنامه در پنجره دیگری استفاده کنید و زمانی که به پایان رسید به <code
              class="command">aa-genprof</code> بازگشته تا رویدادهای سیستمی مورد نظر AppArmor پیمایش شوند و از میان ‌آن‌ها قوانین دسترسی برنامه مشخص گردند. برای هر رویداد ثبت شده، یک یا چند پیشنهاد برای قانون مورد نظر ارائه می‌دهد که می‌توانید تایید یا به روش‌های دیگر آن‌ها را ویرایش کنید:
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-genprof dhclient</code></strong>
<code
              class="computeroutput">Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <span
                id="aa-genprof-execute"><img
                  class="callout"
                  src="Common_Content/images/1.png"
                  alt="1" /></span>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<strong
                class="userinput"><code>P</code></strong>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<strong
                class="userinput"><code>Y</code></strong>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <span
                id="aa-genprof-capability"><img
                  class="callout"
                  src="Common_Content/images/2.png"
                  alt="2" /></span>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<strong
                class="userinput"><code>A</code></strong>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <span
                id="aa-genprof-read"><img
                  class="callout"
                  src="Common_Content/images/3.png"
                  alt="3" /></span>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>3</code></strong>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <span
                id="aa-genprof-write"><img
                  class="callout"
                  src="Common_Content/images/4.png"
                  alt="4" /></span>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>N</code></strong>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <span
                id="aa-genprof-other-profile"><img
                  class="callout"
                  src="Common_Content/images/5.png"
                  alt="5" /></span>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<strong
                class="userinput"><code>S</code></strong>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<strong
                class="userinput"><code>F</code></strong>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</code></pre><div
            class="para">
				به یاد داشته باشید که برنامه کاراکترهای کنترلی از طرف شما را نشان نمی‌دهد ولی در اینجا به منظور بررسی شیوه عملکرد آن نمایش داده شده‌اند.
			</div><div
            class="calloutlist"><table
              border="0"
              summary="Callout list"><tr><td
                  width="5%"
                  valign="top"
                  align="right"><p><a
                      href="#aa-genprof-execute"><img
                        class="callout"
                        src="Common_Content/images/1.png"
                        alt="1" /></a> </p></td><td
                  valign="top"
                  align="right"><div
                    class="para">
						اولین رویداد تشخیص داده شده مربوط به اجرای برنامه دیگری است. در این مورد، شما چندین انتخاب دارید: می‌توانید برنامه را با پروفایل فرآیند والد آن (گزینه “Inherit”)، با پروفایل اختصاصی خود (گزینه‌های “Profile” و “Named”، که تنها در شیوه گزینش نام تفاوت دارند)، با پروفایل زیرمجموعه فرآیند والد آن (گزینه “Child”)، بدون پروفایل (گزینه “Unconfined”) اجرا کنید یا می‌توانید تصمیم بگیرید که برنامه اصلا اجرا نشود (گزینه “Deny”).
					</div><div
                    class="para">
						به یاد داشته باشید که در صورت انتخاب یک پروفایل اختصاصی و عدم وجود آن، این ابزار پروفایل جدید را برای شما ایجاد کرده و در همان قسمت قوانین پیشنهای را به شما ارائه می‌دهد.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="right"><p><a
                      href="#aa-genprof-capability"><img
                        class="callout"
                        src="Common_Content/images/2.png"
                        alt="2" /></a> </p></td><td
                  valign="top"
                  align="right"><div
                    class="para">
						در سطح کرنل، قدرت ویژه کاربر root به چندین “قابلیت” تقسیم می‌شود. زمانی که یک فراخوانی سیستمی نیازمند ... خاصی است، AppArmor تایید می‌کند آیا پروفایل به برنامه اجازه استفاده از چنین قابلیتی را می‌دهد یا خیر.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="right"><p><a
                      href="#aa-genprof-read"><img
                        class="callout"
                        src="Common_Content/images/3.png"
                        alt="3" /></a> </p></td><td
                  valign="top"
                  align="right"><div
                    class="para">
						در اینجا برنامه به دنبال مجوزهای <code
                      class="filename">/etc/nsswitch.conf</code> است. <code
                      class="command">aa-genprof</code> تشخیص داد که این مجوز توسط چندین “موجودیت” صادر شده و آن‌ها را به عنوان گزینه‌های جایگزین پیشنهاد می‌دهد. یک موجودیت مجموعه‌ای از قوانین دسترسی را فراهم می‌کند که این قوانین منابع مختلفی که معمولا با یکدیگر استفاده می‌شوند را گروه‌بندی می‌کنند. در این مورد بخصوص، فایل معمولا توسط nameservice مرتبط با توابع کتابخانه‌ای C قابل دسترسی است و برای انتخاب گزینه “#include &lt;abstractions/nameservice&gt;” عبارت “3” را وارد کرده و با درج “A” آن را تایید می‌کنیم.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="right"><p><a
                      href="#aa-genprof-write"><img
                        class="callout"
                        src="Common_Content/images/4.png"
                        alt="4" /></a> </p></td><td
                  valign="top"
                  align="right"><div
                    class="para">
						برنامه قصد ایجاد فایل <code
                      class="filename">/run/dhclient-eth0.pid</code> را دارد. اگر فقط اجازه ایجاد چنین فایل ویژه‌ای را بدهیم، برنامه زمانی که کاربر از آن در یک رابط شبکه دیگر استفاده کند کار نخواهد کرد. بنابراین با انتخاب “New” نام فایل را به عبارت متداول‌تر “/run/dhclient*.pid” قبل از اینکه توسط “Allow” ثبت شود تغییر می‌دهیم.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="right"><p><a
                      href="#aa-genprof-other-profile"><img
                        class="callout"
                        src="Common_Content/images/5.png"
                        alt="5" /></a> </p></td><td
                  valign="top"
                  align="right"><div
                    class="para">
						نکته اینکه این درخواست دسترسی قسمتی از پروفایل dhclient نبوده ولی در پروفایل جدید فراهم شده توسط <code
                      class="filename">/usr/lib/NetworkManager/nm-dhcp-helper</code> در زمان اختصاص پروفایل ویژه به آن قرار دارد.
					</div><div
                    class="para">
						پس از بازرسی تمام رویدادهای ثبت شده، برنامه پیشنهاد می‌دهد که تمام پروفایل‌های ایجاد شده در زمان اجرا ذخیره‌سازی شوند. در این مورد، دو پروفایل داریم که به صورت همزمان با استفاده از “Save” می‌توانیم ذخیره‌سازی کنیم (اما امکان ذخیره‌سازی انفرادی آن‌ها نیز وجود دارد) قبل از اینکه برنامه را با “Finish” به پایان برسانیم.
					</div></td></tr></table></div><div
            class="para">
				<code
              class="command">aa-genprof</code> در حقیقت به عنوان یک لایه انتزاعی برای <code
              class="command">aa-logprof</code> عمل می‌کند: این ابزار یک پروفایل خالی ایجاد کرده، آن را در حالت complain قرار می‌دهد و با اجرای <code
              class="command">aa-logprof</code>، که ابزاری برای بروزرسانی پروفایل است، محتویات آن را مبتنی با رویدادهای ثبت شده در سیستم برورزسانی می‌کند. بنابراین در زمان دیگری می‌توانید با اجرای این ابزار پروفایل خود را بهینه‌سازی کنید.
			</div><div
            class="para">
				اگر می‌خواهید که پروفایل تولید شده کامل باشد، باید از برنامه به شیوه‌ای که توضیح داده شده است استفاده کنید. در مورد dhclient، یعنی آن را با استفاده از Network Manager، ifupdown یا manual اجرا کنید. در انتها، ممکن است فایل <code
              class="filename">/etc/apparmor.d/sbin.dhclient</code> مشابه به این را دریافت کنید:
			</div><pre
            class="programlisting">
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
</pre></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.supervision.html"><strong>قبلی</strong>14.3. نظارت: پیشگیری، شناسایی، بازدارندگی</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.selinux.html"><strong>بعدی</strong>14.5. مقدمه‌ای بر SELinux</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.apparmor.html">ar-MA</a></li><li><a
              href="../da-DK/sect.apparmor.html">da-DK</a></li><li><a
              href="../de-DE/sect.apparmor.html">de-DE</a></li><li><a
              href="../el-GR/sect.apparmor.html">el-GR</a></li><li><a
              href="../en-US/sect.apparmor.html">en-US</a></li><li><a
              href="../es-ES/sect.apparmor.html">es-ES</a></li><li><a
              href="../fa-IR/sect.apparmor.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.apparmor.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.apparmor.html">hr-HR</a></li><li><a
              href="../id-ID/sect.apparmor.html">id-ID</a></li><li><a
              href="../it-IT/sect.apparmor.html">it-IT</a></li><li><a
              href="../ja-JP/sect.apparmor.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.apparmor.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.apparmor.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.apparmor.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.apparmor.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.apparmor.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.apparmor.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.apparmor.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.apparmor.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.apparmor.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.apparmor.html">zh-TW</a></li></ul></div></body></html>
