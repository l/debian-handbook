<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. برخی از وظایفی که کرنل به آن‌ها رسیدگی می‌کند</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="بایوس, کرنل, یونیکس, فرآیند, سلسله‌مراتب, دستورات ابتدایی" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="short-remedial-course.html"
        title="پيوست B. درس کاربردی کوتاه" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. طرزکار داخلی یک رایانه: لایه‌های مختلفی درگیر هستند" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. فضای کاربری" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/fa-IR/sect.kernel-role-and-tasks.html" /></head><body
      dir="rtl"><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. برخی از وظایفی که کرنل به آن‌ها رسیدگی می‌کند</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. مدیریت سخت‌افزار</h3></div></div></div><div
            class="para">
				کرنل، در درجه نخست، وظیفه مدیریت قسمت‌های سخت‌افزاری، شناسایی آن‌ها و فعال‌سازی هنگامی که رایانه روشن می‌شود را بر عهده دارد. همچنین باعث می‌شود که نرم‌افزاری که در لایه بالاتر قرار دارد بتواند از طریق یک رابط برنامه‌نویسی ساده با آن ارتباط برقرار کند تا برنامه‌های کاربردی بتوانند از مزایای آن استفاده کرده بدون آنکه درگیر جزئیات لایه پایین‌تر خود شوند. این رابط برنامه‌نویسی همچنین یک لایه انتزاعی بوجود می‌آورد؛ برای نمونه، باعث می‌شود یک نرم‌افزار ویدیو کنفرانس بدون اطلاع از مدل و شماره وب‌کم، براحتی از آن استفاده کند. نرم‌افزار تنها می‌تواند از <span
              class="emphasis"><em>Video for Linux</em></span> یا (V4L) استفاده کرده و کرنل وظیفه ترجمه فراخوانی‌های تابع را دارد که متناظر با دستورات موجود در خود سخت‌افزار وب‌کم باشند.
			</div><div
            class="para">
				<a
              id="id-1.21.7.2.3.1"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.2"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.3"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.4"
              class="indexterm"></a> کرنل بسیاری از جزئیات مربوط به سخت‌افزار را از طریق فایل سیستم‌های مجازی <code
              class="filename">/proc/</code> و <code
              class="filename">/sys/</code> ارائه می‌دهد. برخی ابزارها نیز قابلیت ارائه این گزارشات را دارند. از میان آن‌ها، دستور <code
              class="command">lspci</code> (واقع در بسته <span
              class="pkg pkg">pciutils</span>) فهرستی از دستگاه‌های PCI، دستور <code
              class="command">lsusb</code> (واقع در بسته <span
              class="pkg pkg">usbutils</span>) فهرستی از دستگاه‌های USB و دستور <code
              class="command">lspcmcia</code> (واقع در بسته <span
              class="pkg pkg">pcmciautils</span>) فهرستی از کارت‌های PCMCIA را نمایش می‌دهند. این ابزارها برای شناسایی مدل دقیق یک سخت‌افزار بسیار کاربردی هستند. این شناسایی دقیق منجر به جستجوهای دقیق‌تری در وب می‌شود که می‌تواند مستندات مرتبطی را نمایان سازد.
			</div><div
            class="example"><a
              id="id-1.21.7.2.4"></a><p
              class="title"><strong>
      مثال B.1. نمونه اطلاعاتی که <code
                  class="command">lspci</code> و <code
                  class="command">lsusb</code> ارائه می‌دهند</strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				این برنامه‌ها شامل یک گزینه <code
              class="literal">-v</code> هستند که اطلاعات بیشتری (البته نه ضروری) را نمایش می‌دهند. در نهایت، دستور <code
              class="command">lsdev</code> (واقع در بسته <span
              class="pkg pkg">procinfo</span>) فهرستی از منابع ارتباطی که توسط دستگاه‌ها استفاده می‌شوند را نمایش می‌دهد.
			</div><div
            class="para">
				برنامه‌های کاربردی اغلب بوسیله فایل‌های مخصوصی که درون <code
              class="filename">/dev/</code> ایجاد می‌شود (به قسمت <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>بازگشت به مقدمات</em></span> مجوزهای دسترسی به دستگاه</a> مراجعه شود) به دستگاه‌های مختلف دسترسی پیدا می‌کنند. فایل‌های مخصوصی هستند که درایوهای دیسک (برای نمونه، <code
              class="filename">/dev/hda</code> و <code
              class="filename">/dev/sda</code>)، پارتیشن‌ها (<code
              class="filename">/dev/hda1</code> یا <code
              class="filename">/dev/sda1</code>)، ماوس (<code
              class="filename">/dev/input/mouse0</code>)، صفحه کلید (<code
              class="filename">/dev/input/event0</code>)، کارت‌ صدا (<code
              class="filename">/dev/snd/*</code>)، پورت‌های سریال (<code
              class="filename">/dev/ttyS*</code>) و بسیاری موارد دیگر را مشخص می‌کنند.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. فایل‌سیستم‌ها</h3></div></div></div><a
            id="id-1.21.7.3.2"
            class="indexterm"></a><a
            id="id-1.21.7.3.3"
            class="indexterm"></a><div
            class="para">
				فایل‌سیستم‌ها یکی از برجسته‌ترین جنبه‌های کرنل هستند. سیستم‌های یونیکس تمام فایل‌های موجود را داخل یک ساختار درختی قرار می‌دهند، که به کاربران (و برنامه‌های کاربردی) به راحتی این امکان را می‌دهند تا با دانستن مکان فایل‌ها در این ساختار، از منابع آن استفاده کنند.
			</div><div
            class="para">
				نقطه آغازین این ساختار درختی، ریشه نام دارد، <code
              class="filename">/</code>. این دایرکتوری می‌تواند شامل دایرکتوری‌های فرزند دیگری باشد. برای نمونه، دایرکتوری فرزند <code
              class="literal">home</code> از <code
              class="filename">/</code> با نام <code
              class="filename">/home/</code> شناخته می‌شود. این دایرکتوری فرزند نیز می‌تواند زیر مجموعه‌های خود را داشته باشد و به همین ترتیب. هر دایرکتوری می‌تواند شامل فایل‌های گوناگونی باشد، جایی که داده‌های واقعی ذخیره می‌شوند. بنابراین، <code
              class="filename">/home/rmas/Desktop/hello.txt</code> به فایلی با نام <code
              class="literal">hello.txt</code> در دایرکتوری فرزند <code
              class="literal">Desktop</code> واقع در حساب کاربری <code
              class="literal">rmas</code> از <code
              class="literal">home</code> قرار دارد که خود زیرمجموعه دایرکتوری ریشه است. کرنل وظیفه ترجمه این مسیرها و آدرس حقیقی رو دیسک را بر عهده دارد.
			</div><div
            class="para">
				بر خلاف سایر سیستم‌ها، تنها یک ساختار درختی مانند این وجود دارد، که توانایی همگرائی داده‌ها از دیسک‌های فیزیکی گوناگون را داراست. یکی از این دیسک‌ها به عنوان دایرکتوری ریشه استفاده شده است و دیسک‌های دیگر بر روی سایر دایرکتوری‌های فرزند آن “سوار” شده‌اند (دستور یونیکس آن <code
              class="command">mount</code> خوانده می‌شود)؛ این دیسک‌ها تحت عبارت “نقاط دسترسی (سوار)” شناخته می‌شوند. این قابلیت، امکان ذخیره‌سازی دایرکتوری‌های مربوط به حساب کاربری افراد (که به صورت سنتی در <code
              class="filename">/home/</code> ذخیره می‌شود) را روی دیسک دیگری می‌دهد که شامل <code
              class="literal">rhertzog</code> و <code
              class="literal">rmas</code> است. زمانی که دیسک روی <code
              class="filename">/home/</code> سوار شود، این دایرکتوری‌ها در مکان‌های مورد نظر خود قادر دسترس خواهند شد و مسیرهایی مانند <code
              class="filename">/home/rmas/Desktop/hello.txt</code> به درستی کار خواهند کرد.
			</div><a
            id="id-1.21.7.3.7"
            class="indexterm"></a><div
            class="para">
				انواع مختلفی از فایل‌سیستم وجود دارد، که هر یک متناسب با یک شیوه ذخیره‌سازی داده روی دیسک هستند. شناخته‌شده‌ترین آن‌ها عبارتند از <span
              class="emphasis"><em>ext2</em></span> و <span
              class="emphasis"><em>ext3</em></span> و <span
              class="emphasis"><em>ext4</em></span> اما موارد دیگری نیز وجود دارد. برای نمونه، <span
              class="emphasis"><em>vfat</em></span> سیستمی است که سابق بر این توسط سیستم‌ عامل‌های داس و ویندوز استفاده می‌شد که امکان استفاده همزمان از هارددیسک روی دبیان و ویندوز را می‌دهد. در هر صورت، یک فایل سیستم ابتدا باید روی دیسک آماده شود قبل از اینکه بتوان از آن استفاده کرد که به این فرآیند “فرمت‌کردن” می‌گویند. دستوراتی مانند <code
              class="command">mkfs.ext3</code> (که <code
              class="command">mkfs</code> مخفف <span
              class="emphasis"><em>Make FileSystem</em></span> است) فرمت‌کردن را بر عهده دارند. این دستورات، به عنوان پارامتر، نیاز به فایلی دارند که نشان‌دهنده پارتیشنی است که باید فرمت شود (برای نمونه، <code
              class="filename">/dev/sda1</code>). این عملیات، مخرب است و تنها یکبار باید اجرا شود، مگر در شرایطی که کسی بخواهد به عمد تمام محتویات روی فایل‌سیستم را از بین ببرد.
			</div><div
            class="para">
				همچنین فایل‌سیستم‌های شبکه‌ای نیز وجود دارند، مانند <acronym
              class="acronym">NFS</acronym> که داده به صورت مستقیم از روی دیسک نصب شده روی رایانه خوانده نمی‌شود. در عوض، داده توسط شبکه به سروری که وظیفه نگهداری و بازنشانی داده را به عهده دارد، منتقل می‌شود. این فایل‌سیستم لایه‌ای انتزاعی برای کاربر بوجود می‌آورد: تمامی فایل‌ها با همان ساختار درختی سابق قابل دسترسی خواهند بود.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. توابع اشتراکی</h3></div></div></div><div
            class="para">
				از آنجایی که تعدادی از عملکردهای پایه در تمام نرم‌افزارها مورد استفاده قرار می‌گیرند، معقول به نظر می‌رسد که یک مکان مرکزی برای آن‌ها در کرنل در نظر بگیریم. برای نمونه، فایل‌سیستم اشتراکی به هر برنامه کاربری این امکان را می‌دهد که تمامی فایل‌ها را با استفاده از نامشان باز کند، بدون نگرانی از اینکه این فایل در کجای دیسک ذخیره شده است. فایل ممکن است در قطاع‌های گوناگونی از دیسک ذخیره شده باشد، یا حتی بین چند دیسک گوناگون تقسیم شده باشد، یا در یک فایل سرور روی شبکه قرار داشته باشد. توابع ارتباطی اشتراکی توسط برنامه‌های کاربردی به منظور تبادل داده مورد استفاده قرار می‌گیرند مستقل از راه و روش انتقال آن. برای نمونه، عملیات انتقال ممکن است با ترکیبی از شبکه‌های محلی یا بیسیم یا حتی خطوط تلفن صورت بگیرد.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. مدیریت فرآیندها (پروسه‌ها)</h3></div></div></div><a
            id="id-1.21.7.5.2"
            class="indexterm"></a><div
            class="para">
				یک فرآیند، نمونه اجرایی یک برنامه به حساب می‌آید. این عمل شامل حافظه‌ای است که هم برنامه را شامل شود هم عملیات کنترلی روی آن. کرنل وظیفه ایجاد و ردیابی آن‌ها را برعهده دارد. زمانی که یک برنامه اجرا می‌شود، کرنل در ابتدا مقداری حافظه کنار می‌گذارد، سپس کد اجرایی برنامه از از فایل‌سیستم خوانده و درون حافظه بارگذاری می‌کند و در نهایت به اجرای کد می‌پردازد. اطلاعات مربوط به این فرآیند را ذخیره می‌کند، که مهم‌ترین این اطلاعات یک شناسه عددی به نام <span
              class="emphasis"><em>pid</em></span> است (<span
              class="emphasis"><em>شناسه فرآیند</em></span>).
			</div><div
            class="para">
				کرنل‌های شبه یونیکس (از جمله لینوکس)، مانند سایر سیستم عامل‌های پیشرفته، قابلیت “چند وظیفگی” دارند. به عبارت دیگر، آن‌ها اجازه اجرای بسیاری از فرآیندها را “در یک زمان مشخص” می‌دهند. در حقیقت تنها یک فرآیند در هر واحد زمانی وجود دارد، اما کرنل زمان را به بازه‌های کوچکتری تبدیل می‌کند و به اجرای هر فرآیند می‌پردازد. از آنجایی که این بازه‌های زمانی بسیار کوتاه هستند (در محدوده هزارم ثانیه)، این خیال باطل بوجود می‌آید که گویی همه فرآیندها به صورت موازی اجرا می‌شوند، با اینکه در حقیقت هر یک از آن‌ها طی یک بازه زمانی فعال و در زمان دیگر دیگر بیکار هستند. وظیفه کرنل این است که مکانیزم این جدول زمانی را طوری تنظیم کند که این خیال به ذهن برسد، همزمان با اینکه عملکرد عمومی سیستم را افزایش دهد. اگر این بازه‌های زمانی بسیار طولانی باشند، برنامه کاربردی ممکن است پاسخی از خود نمایش ندهد و اگر بسیار کوتاه باشد سیستم توانایی تعویض این بازه‌ها را از دست خواهد داد. این تصمیمات می‌تواند با استفاده از اولویت‌بندی برای فرآیندها تغییر یایند. فرآیندهای با اولویت بالا برای مدت طولانی و با بازه‌های زمانی مکرر اجرا خواهند شد تا فرآیندهای با اولویت پایین.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>یادداشت</em></span> سیستم‌های چند پردازنده‌ای (و خانواده آن‌ها(</strong></p></div></div></div><div
              class="para">
				محدودیت اشاره شده بالا که تنها یک فرآیند در هر زمان قابل اجرا است، همیشه صادق نیست. محدودیت واقعی در حقیقت این است که تنها یک فرآیند در حال اجرا روی <span
                class="emphasis"><em>هر هسته پردازنده</em></span> در یک زمان قابل اجرا است. سیستم‌های چندپردازنده‌ای، چندهسته‌ای یا “چند-نخی” اجازه اجرای چندین فرآیند به صورت موازی را می‌دهند. کماکان از همان سیستم تقسیم زمانی استفاده می‌شود، البته، با این تفاوت که فرآیندهای فعال بیشتری روی هسته‌های پردازنده موجود هستند. این حالت اصلاً غیرعادی نیست: یک سیستم پایه، حتی بیکارترین آن‌ها، تقریباً همیشه ده‌ها فرآیند در حال اجرا دارد.
			</div></div><div
            class="para">
				البته، کرنل اجازه اجرای چند نسخه مختلف از یک برنامه را می‌دهد. اما هر یک از آن‌ها تنها می‌تواند به برش زمانی و حافظه خود دسترسی داشته باشد. داده‌های موجود در آن‌ها به صورت جداگانه باقی می‌مانند.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. مدیریت مجوز</h3></div></div></div><div
            class="para">
				سیستم‌های شبه‌-یونیکس همچنین چند-کاربره نیز هستند. آن‌ها سیستم مدیریت مجوزی را فراهم می‌کنند که از کاربران و گروه‌های کاربری جداگانه، حمایت می‌کند؛ همچنین اجازه کنترل بر اساس نوع فعالیت و مجوز آن را هم می‌دهد. کرنل داده مربوط به هر فرآیند را مدیریت می‌کند و به آن اجازه کنترل مجوزهایش را می‌دهد. در اکثر اوقات، یک فرآیند توسط کاربری که آن را أغاز کرده است شناخته می‌شود. آن فرآیند تنها مجاز به اجرای عملیاتی است که برای آن کاربر مشخص شده است. برای نمونه، تلاش برای باز کردن یک فایل نیازمند بررسی کرنل از شناسه فرآیند در مقابله با مجوزهای مورد نیازش می‌باشد (برای جزئیات بیشتر در این مورد خاص، <a
              class="xref"
              href="sect.rights-management.html">
      قسمت 9.3, “مدیریت دسترسی”
    </a> را ببینید).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>قبلی</strong>B.3. طرزکار داخلی یک رایانه: لایه‌های مختلفی درگی...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>بعدی</strong>B.5. فضای کاربری</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.kernel-role-and-tasks.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.kernel-role-and-tasks.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.kernel-role-and-tasks.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.kernel-role-and-tasks.html">zh-TW</a></li></ul></div></body></html>
