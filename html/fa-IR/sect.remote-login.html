<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. دسترسی از راه‌دور</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="راه‌اندازی سیستم, اسکریپت‌های init, SSH, Telnet, حقوق, مجوزها, نظارت, Inetd, Cron, پشتیبان‌گیری, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="unix-services.html"
        title="فصل 9. سرویس‌های یونیکس" /><link
        rel="prev"
        href="unix-services.html"
        title="فصل 9. سرویس‌های یونیکس" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. مدیریت دسترسی" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/fa-IR/sect.remote-login.html" /></head><body
      dir="rtl"><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.remote-login"></a>9.2. دسترسی از راه‌دور</h2></div></div></div><div
          class="para">
			اتصال به یک رایانه از راه‌دور برای مدیرسیستم یک امر ضروری است. سرورها، که در اتاق‌های جداگانه‌ای بدون صفحه‌کلید و نمایشگر قرار می‌گیرند - به شبکه متصل هستند.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>بازگشت به مقدمات</em></span> معماری کلاینت، سرور</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			سیستمی که در آن چندین فرآیند با یکدیگر در حال برقراری ارتباط هستند استعاره از “client/server” دارد. سرور برنامه‌ای است که به درخواست‌های دریافتی از کلایت پاسخ می‌دهد. این کلاینت است که عملیات را کنترل می‌کند، سرور هیچ عملیاتی را خود آعاز نمی‌کند.
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ssh"></a>9.2.1. ورود امن از راه‌دور: SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				پروتکل <span
              class="emphasis"><em>SSH</em></span> یا Secure SHell با توجه به اصول امنیتی و قابلیت اطمینان طراجی شده است. ارتباطاتی که از SSH استفاده می‌کنند امن هستند: طرف مقابل احراز هویت شده و تمام اطلاعات به صورت رمزگذاری شده ارسال می‌شوند.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>فرهنگ</em></span> منسوخ شدن استفاده Telnet و RSH</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				قبل از SSH، <span
                class="emphasis"><em>Telnet</em></span> و <span
                class="emphasis"><em>RSH</em></span> دو ابزار اصلی برای ارتباط راه‌دور بودند. اکنون این ابزارها منسوخ شده و با وجود فراهم بودن در دبیان نباید به این منظور استفاده گردند.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>واژگان</em></span> احراز هویت، رمزنگاری</strong></p></div></div></div><div
              class="para">
				زمانی که می‌خواهید از طریق یک کلاینت قابلیت اجرای برخی دستورات در سرور را داشته باشید، امنیت به میان می‌آید. باید هویت کلاینت را مشخص کنید؛ این کار احراز هویت نام دارد. این شناسایی معمولا شامل یک گذرواژه می‌باشد که باید به صورت خصوصی نگهداری شود، در غیر اینصورت هر کلاینت می‌تواند به آن وصل شود. این همان هدف رمزنگاری است، که شیوه‌ای به صورت رمزگذاری برای سیستم‌ها است تا بتوانند اطلاعات بین خود را از طریق یک کانال عمومی ناامن رد و بدل کنند.
			</div><div
              class="para">
				احرازهویت و رمزنگاری معمولا با یکدیگر بکار می‌روند، از آنجا که کاربرد مشابهی دارند و از آنجا که از مفاهیم مشترک ریاضی استفاده می‌کنند.
			</div></div><div
            class="para">
				SSH همچنین تو سرویس انتقال فایل را ارائه می‌دهد. <code
              class="command">scp</code> یک ابزار خط فرمان است که عملکردی مشابه <code
              class="command">cp</code> دارد، به جز مسیرهای خارج از یک رایانه که باید ابتدا نام رایانه به همراه دو نقطه آورده شود.
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp file machine:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> یک دستور تعاملی مشابه <code
              class="command">ftp</code> است. در یک نشست واحد، <code
              class="command">sftp</code> می‌تواند چندین فایل را منتقل کند و امکان ایجاد تغییرات در فایل‌های راه‌دور نیز وجود دارد (حذف، تغییر نام، تغییر مجوزها و از این قبیل).
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				دبیان از OpenSSH، یک نسخه آزاد از SSH که توسط پروژه <code
              class="command">OpenBSD</code> مدیریت می‌شود (یک سیستم عامل آزاد مبتنی بر کرنل BSD با تمرکز بر امنیت) و انشعاب نسخه اصلی نرم‌افزار SSH که توسط شرکت SSH Communications Security Corp در فنلاند اداره می‌شد، استفاده می‌کند. این شرکت در ابتدا SSH را به عنوان نرم‌افزار آزاد منتشر کرد، اما در ادامه مسیر تصمیم گرفت تا توسعه آن را تحت یک مجوز انحصاری انجام دهد. پروژه OpenBSD با ایجاد OpenSSH تصمیم گرفت یا یک نسخه آزاد از آن ارائه دهد.
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>بازگشت به مقدمات</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">Fork</em></span></strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				یک “انشعاب”، در حوزه نرم‌افزار، به معنای پروژه جدیدی بر اساس پروژه فعلی است که با آن رقابت می‌کند. از آن زمان به بعد، هر دو نرم‌افزار رویکردهای متفاوتی در نسخه‌های جدید دارند. یک انشعاب معمولا ناشی از عدم تفاقق بین اعضای یک تیم توسعه نرم‌افزار است.
			</div><div
              class="para">
				گزینه انشعاب برای یک پروژه از طبیعت نرم‌افزار آزاد نشات می‌گیرد؛ یک انشعاب رویدادی حیات بخش برای ادامه توسعه نرم‌افزار با فلسفه آزاد است (برای نمونه در مورد تغییر مجوز). انشعابی که از مسائل فنی یا شخصی نشات می‌گیرد معمولا به اتلاف منابع انسانی می‌انجامد؛ در این رابطه رویکرد دیگری ترجیح داده می‌شود. افرادی که دو پروژه متفاوت را که سابق بر این تحت یک عنوان فعالیت می‌کرد، راهبری می‌کنند با سابقه آن آشنا هستند.
			</div></div><div
            class="para">
				OpenSSH به دو بسته تقسیم شده است: بخش مربوط به کلاینت در بسته <span
              class="pkg pkg">openssh-client</span> و بخش مربوط به سرور در بسته <span
              class="pkg pkg">openssh-server</span> قرار دارد. بسته <span
              class="pkg pkg">ssh</span> به هر دو آن‌ها وابسته بوده و عملیات نصب آن‌ها را انجام می‌دهد (<code
              class="command">apt install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. احرازهویت کلید-محور</h4></div></div></div><div
              class="para">
					با هر بار ورود از طریق SSH، سرور راه‌دور درخواست یک گذرواژه برای احزارهویت کاربر می‌کند. این می‌تواند در صورت خودکارسازی ارتباط یا استفاده از ابزاری که نیاز به ارتباط مداوم با سرور دارد، مشکل‌ساز گردد. به همین دلیل است که SSH سیستم احرازهویت کلید-محور را فراهم کرده است.
				</div><div
              class="para">
					کاربر در رایانه خود اقدام به ایجاد یک جفت کلید با استفاده از دستور <code
                class="command">ssh-keygen -t rsa</code> می‌کند؛ کلید عمومی در فایل <code
                class="filename">~/.ssh/id_rsa.pub</code> و کلید خصوصی در فایل <code
                class="filename">~/.ssh/id_rsa</code> ذخیره می‌شوند. کاربر با اجرای دستور <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> کلید عمومی خود را به انتهای فایل <code
                class="filename">~/.ssh/authorized_keys</code> موجود در سرور اضافه می‌کند. اگر کلید خصوصی در زمان تولید خود با استفاده از “گذزواژه” محافظت نشده باشد، تمام ورودهای جداگانه به سرور بدون درخواست گذرواژه کار خواهند کرد. در غیر اینصورت، کلید خصوصی در هر مرتبه ورود به سرور نیاز به رمزگشایی با استفاده از گذرواژه مربوطه دارد. خوشبختانه، <code
                class="command">ssh-agent</code> امکان نگهداری کلید خصوصی در حافظه را به منظور دسترسی آسان‌تر فراهم می‌کند. به این منظور، کافی است <code
                class="command">ssh-add</code> را (برای هر نشست جداگانه) با یک نسخه کامل <code
                class="command">ssh-agent</code> بکار می‌برید. دبیان این کار را در نشست‌های گرافیکی به صورت خودکار انجام می‌دهد اما می‌توانید با تغییر در <code
                class="filename">/etc/X11/Xsession.options</code> آن را غیرفعال کنید. برای یک نشست کنسول، می‌توانید آن را به صورت دستی و با <code
                class="command">eval $(ssh-agent)</code> آغاز کنید.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>امنیت</em></span> محافظت از کلید خصوصی</strong></p></div></div></div><div
                class="para">
					هر کسی که به کلید خصوصی دسترسی داشته باشد با حساب کاربری مربوط به آن می‌تواند وارد شود. به همین دلیل است که دسترسی به کلید خصوصی از طریق یک “گذزواژه” محافظت می‌شود. کسی که یک رونوشت از کلید خصوصی می‌گیرد (برای نمونه، <code
                  class="filename">~/.ssh/id_rsa</code>) هنوز باید به گذرواژه مخصوص آن دسترسی داشته باشد. این لایه حفاظتی اضافی نیز، اگرچه، رسوخ‌ناپذیر نیست و اگر فکر می‌کنید که کلید خصوصی شما آشکار شده است بهتر است تا مجوز دسترسی به آن روی رایانه‌های سرور را از بین ببرید (با حفظ کردن آن از فایل <code
                  class="filename">authorized_keys</code>) و آن را با یک کلید جدید جایگزین کنید.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>فرهنگ</em></span> نقص OpenSSL در دبیان <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					کتابخانه OpenSSL، که ابتدا در دبیان <span
                  class="distribution distribution">Etch</span> ارائه شد، یک مشکل اساسی در تولیدکننده عدد تصادفی (RNG) خود داشت. در واقع، نگهدارنده بسته تغییر کوچکی ایجاد کرده بود تا برنامه‌هایی که از آن استفاده می‌کنند اقدام به تولید اخطارهای خاصی زمانی که از ابزار آزمون حافظه مانند <code
                  class="command">valgrind</code> استفاده می‌شود، نکنند. متاسفانه، این تغییر به معنای این بود که RNG تنها از یک منبع آنتروپی متناظر با شماره فرآیند (PID) که ۳۲،۰۰۰ مقدار آن برای تولید عدد تصادفی کافی نبود، استفاده می‌کرد. <div
                  class="url">→ <a
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					به خصوص، زمانی که OpenSSL برای تولید یک کلید استفاده می‌شد، همیشه کلیدی بین محدوده مشخصی از آن‌ها تولید می‌کرد (۳۲،۰۰۰ ضرب در تعداد کمی از طول کلید‌ها). این عملکرد روی کلیدهای SSH، کلیدهای SSL و گواهینامه‌های X.509 که توسط بسیاری برنامه‌ها مانند OpenVPN استفاده می‌شدند، تاثیر گذاشت. یک نفوذگر تنها می‌بایست تمام کلید‌های موجود در آن بازه را جهت دسترسی به سیستم پیدا کند. برای کاهش تاثیر این مشکل، فرآیند پس‌زمینه SSH طوری تغییر یافت تا کلیدهای دردسرساز فهرست شده در بسته‌های <span
                  class="pkg pkg">openssh-blacklist</span> و <span
                  class="pkg pkg">openssh-blacklist-extra</span> را رد کند. علاوه بر این، دستور <code
                  class="command">ssh-vulnkey</code> امکان شناسایی کلیدهای آشکارشده در سیستم را فراهم می‌کرد.
				</div><div
                class="para">
					تحلیل بیشتر روی این موضوع نشان داد که مشکلات کوچک بیشتری در پروژه OpenSSL و نگهدارنده بسته دبیان آن وجود داشت. کتابخانه بزرگی مانند OpenSSL - بدون تغییر - نباید پس از آزمون با <code
                  class="command">valgrind</code> پیام‌های اخطار صادر کند. علاوه بر این، کد (به خصوص قسمت حساسی مانند RNG) باید با توضیحات بهتری از بروز چنین خطایی پیشگیری کند. در طرف دبیان، نگهدارنده بسته قصد داشت تا تغییرات مورد نظر خود را با توسعه‌دهندگان اصلی OpenSSL سازگار سازد، اما بدون ارايه فایل وصله مناسب و در جریان گذاشتن تیم اصلی از تغییرات انجام گرفته خارج از مسئولیت‌های پروژه دبیان اقدام کرد. در نهایت، راه‌حل‌های پیشنهادی خیلی بهینه نبودند: تغییرات ایجاد شده در کد اصلی به خوبی مستند نشده بود؛ تمام تغییرات در یک مخزن Subversion ذخیره شده بودند اما هنگام ایجاد بسته اصلی تنها به تولید یک فایل وصله انجامید.
				</div><div
                class="para">
					در چنین شرایطی جستجو برای معیارهای درست به منظور جلوگیری از وقوع چنین رخدادهایی دشوار است. درسی که از این مورد می‌توان گرفت این است که کوچکترین تغییر مورد نظر از طریق دبیان باید به توسعه‌دهندگان اصلی اطلاع داده شده، به خوبی مستندسازی گردد و به صورت عمومی انتشار یابد. با این دید بود که قالب بسته‌های سورس جدید (“3.0 (quilt)”) و وب‌سرویس دبیان برای این منظور بوجود آمدند. <div
                  class="url">→ <a
                    href="http://sources.debian.net">http://sources.debian.net</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-x11"></a>9.2.1.2. استفاده راه‌دور از برنامه‌های X11</h4></div></div></div><div
              class="para">
					پروتکل SSH امکان فوروارد کردن داده‌های گرافیکی را می‌دهد (نشست “X11”، که از نام متداول‌ترین سیستم گرافیکی یونیکس گرفته شده است)؛ سرور یک کانال اختصاصی برای آن در نظر می‌گیرد. به خصوص، یک برنامه گرافیکی که از راه‌دور اجرا می‌شود می‌تواند روی سرور X.org سیستم محلی نمایش یابد و تمام نشست جاری (ورودی و نمایش) امن خواهد بود. از آنجا که این سیستم اجازه تداخل برنامه‌های راه‌دور با سیستم محلی را می‌دهد، به صورت پیش‌فرض غیرفعال است. می‌توانید با مشخص کردن <code
                class="literal">X11Forwarding yes</code> در فایل پیکربندی سرور (<code
                class="filename">/etc/ssh/sshd_config</code>) آن را فعال کنید. در نهایت، کاربر نیز هنگام درخواست <code
                class="command">ssh</code> باید گزینه <code
                class="literal">-X</code> را بیان کند.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. ایجاد تونل‌های رمزگذاری شده با پورت فورواردینگ</h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					گزینه‌های <code
                class="literal">-R</code> و <code
                class="literal">-L</code> به <code
                class="command">ssh</code> امکان ایجاد “تونل‌های رمزگذاری‌شده” بین دو رایانه را می‌دهند، که به تبع آن یک پورت TCP محلی (قسمت <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>بازگشت به مقدمات</em></span> TCP/UDP</a> را مشاهده کنید) به شیوه‌ای امن می‌تواند به یک ماشین راه‌دور فوروارد شود یا بر عکس.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>واژگان</em></span> تونل</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					اینترنت، و اکثر شبکه‌های محلی متصل به آن، در حالت بسته‌ای کار می‌کنند نه متصل، به این معنی که بسته ارسال شده از یک رایانه در مسیر خود چندین رایانه دیگر (مسیریاب) را طی می‌کند تا در نهایت به مقصد برسد. می‌توانید عملیات اتصال را طوری شبیه‌سازی کنید که در آن جریان داده در بسته‌های نرمال IP ذخیره شده باشد. این بسته‌ها از مسیرهای خود طبعیت می‌کنند، اما جریان داده در انتهای مسیر بدون تغییر باقی می‌ماند. ما به این فرآیند یک “تونل” می‌گوییم، مشابه با یک تونل در دنیای واقعی که در آن خودروها از سمت ورودی (input) به خروجی (output) حرکت می‌کنند بدون اینکه مسیرشان تغییر کند، بر خلاف یک مسیر معمولی که ممکن است شامل تقاطع‌های متفاوت باشد.
				</div><div
                class="para">
					از این موقعیت برای افزودن رمزنگاری به تونل می‌توانید استفاده کنید: با اینکار جریان داده‌ای که از تونل می‌گذرد غیر قابل تشخیص از خارج آن است اما در انتهای تونل به شیوه رمزگشایی شده قرار می‌گیرد.
				</div></div><div
              class="para">
					دستور <code
                class="command">ssh -L 8000:server:25 intermediary</code> یک نشست SSH با میزان <em
                class="replaceable">intermediary</em> برقرار کرده و به پورت محلی ۸۰۰۰ گوش می‌دهد (<a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">
      شكل 9.3, “فوروارد کردن یک پورت محلی با SSH”
    </a> را مشاهده کنید). برای هر ارتباطی که روی این پورت برقرار شود، <code
                class="command">ssh</code> یک ارتباط میانی از رایانه <em
                class="replaceable">intermediary</em> با پورت ۲۵ روی <em
                class="replaceable">server</em> برقرار کرده و هر دو ارتباط را به یکدیگر متصل می‌کند.
				</div><div
              class="para">
					دستور <code
                class="command">ssh -R 8000:server:25 intermediary</code> نیز یک نشست SSH با رایانه <em
                class="replaceable">intermediary</em> برقرار می‌کند، اما روی این رایانه است که <code
                class="command">ssh</code> به پورت ۸۰۰۰ (<a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">
      شكل 9.4, “فوروارد کردن یک پورت راه‌دور با SSH”
    </a> را مشاهده کنید) گوش می‌دهد. هر ارتباطی که روی این پورت برقرار شود <code
                class="command">ssh</code> یک ارتباط با پورت ۲۵ <em
                class="replaceable">server</em> برقرار کرده و هر دو ارتباط را به یکدیگر متصل می‌کند.
				</div><div
              class="para">
					در هر دو مورد، ارتباطات با پورت ۲۵ میزان <em
                class="replaceable">server</em> برقرار شد، که جریان داده آن از طریق تونل SSH بین سیستم محلی و سیستم <em
                class="replaceable">intermediary</em> می‌گذرد. در مورد اول، ورودی تونل پورت ۸۰۰۰ محلی است و داده قبل از اینکه به <em
                class="replaceable">server</em> در شبکه “عمومی” برسد از طریق رایانه <em
                class="replaceable">intermediary</em> می‌گذرد. در مورد دوم، ورودی و خروجی تونل برعکس شده است؛ ورودی پورت ۸۰۰۰ از رایانه <em
                class="replaceable">intermediary</em> است و خروجی روی سیستم محلی قرار دارد و جریان داده به این شکل به <em
                class="replaceable">server</em> هدایت می‌شود. در عمل، سرور همان سیستم محلی یا میانی است. به این شیوه SSH می‌تواند ارتباط امنی بین هر دو رایانه برقرار کند.
				</div><div
              class="figure"><a
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="فوروارد کردن یک پورت محلی با SSH" /></div></div><p
                class="title"><strong>
      شكل 9.3. فوروارد کردن یک پورت محلی با SSH</strong></p></div><div
              class="figure"><a
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="فوروارد کردن یک پورت راه‌دور با SSH" /></div></div><p
                class="title"><strong>
      شكل 9.4. فوروارد کردن یک پورت راه‌دور با SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.remote-desktops"></a>9.2.2. استفاده از میزکارهای گرافیکی راه‌دور</h3></div></div></div><div
            class="para">
				VNC یا Virtual Network Computing اجازه دسترسی راه‌دور به میزکارهای گرافیکی را می‌دهد.
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				این ابزار بیشتر برای راهنمایی فنی استفاده می‌شود؛ مدیرسیستم می‌تواند خطاهایی را ببیند که کاربر با آن مواجه است و به آن‌ها شیوه حل مساله را آموزش دهد.
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				ابتدا، کاربر باید اجازه اشتراک نشست خود را صادر کند. میزکار گرافیکی GNOME در <span
              class="distribution distribution">Jessie</span> این گزینه را در پنل پیکربندی خود شامل می‌شود (برخلاف نسخه‌های قبلی دبیان که کاربر می‌بایست بسته <code
              class="command">vino</code> را نصب و اجرا کند). KDE هنوز به بسته <code
              class="command">krfb</code> جهت اشتراک نشست فعلی با VNC نیاز دارد. برای سایر میزکارهای گرافیکی، دستور <code
              class="command">x11vnc</code> (در بسته دبیان با همین نام) هدف مشابهی را دنبال می‌کند؛ می‌توانید آن را با استفاده از یک نماد گرافیکی در اختیار کاربر قرار دهید.
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				زمانی که نشست گرافیکی توسط VNC آماده شود، مدیرسیستم باید با استفاده از یک کلاینت VNC به آن متصل شود. GNOME از <code
              class="command">vinagre</code> و <code
              class="command">remmina</code> به این منظور استفاده می‌کند در حالی که ابزار KDE شامل <code
              class="command">krdc</code> است (در منوی <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Remote Desktop Client</strong></span>). سایر کلاینت‌های VNC نیز وجود دارند که در خط فرمان عمل می‌کنند مانند <code
              class="command">xvnc4viewer</code> در بسته دبیان با همین نام. زمانی که ارتباط برقرار شود، مدیرسیستم می‌بیند که مشکل از کجاست، به صورت راه‌دور آن را عیب‌یابی کرده و به کاربر شیوه حل مساله را می‌آموزد.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>امنیت</em></span> VNC همراه با SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				اگر قصد استفاده از VNC در حالت امن و رمزنگاری شده را دارید، امکان ذخیره‌سازی داده در یک تونل SSH وجود دارد (<a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">
      قسمت 9.2.1.3, “ایجاد تونل‌های رمزگذاری شده با پورت فورواردینگ”
    </a> را مشاهده کنید). تنها کافی است بدانید که VNC به صورت پیش‌فرض از پورت ۵۹۰۰ برای نمایشگر اول (که “localhost:0” خوانده می‌شود)، ۵۹۰۱ برای نمایشگر دوم (که “localhost:1” خوانده می‌شود) و به همین ترتیب استفاده می‌کند.
			</div><div
              class="para">
				دستور <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">machine</em></code> یک تونل بین پورت ۵۹۰۱ محلی در رابط شبکه localhost و پورت ۵۹۰۰ از میزبان <em
                class="replaceable">machine</em> ایجاد می‌کند. اولین “localhost” به SSH می‌گوید که تنها روی این رابط شبکه از رایانه محلی متمرکز باشد. دومین “localhost” نشان‌دهنده رابط شبکه رایانه راه‌دور است که ترافیک دریافتی را از طریق “localhost:5901” می‌فرستد. بنابراین <code
                class="command">vncviewer localhost:1</code> کلایت VNC را به نمایشگر راه‌دور متصل کرده، با اینکه نام رایانه محلی را ذکر کرده‌اید.
			</div><div
              class="para">
				زمانی که نشست VNC به پایان رسید به یاد داشته باشید که باید نشست SSH مربوط به آن را نیز خاتمه دهید.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>بازگشت به مقدمات</em></span> مدیر نمایش</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm</code>، <code
                class="command">kdm</code>، <code
                class="command">xdm</code> و <code
                class="command">lightdm</code> مدیر نمایش هستند. آن‌ها وظیفه کنترل کردن رابط گرافیکی بعد از راه‌اندازی اولیه سیستم به منظور فراهم کردن صفحه ورودی برای کاربر را به عهده دارند. زمانی که کاربر وارد سیستم شود برنامه‌ای را اجرا می‌کنند که میزکار گرافیکی را فراهم می‌آورد.
			</div></div><div
            class="para">
				VNC همچنین برای کاربران یک شرکت، مانند مدیران اجرایی، که نیاز به دسترسی به رایانه شرکت از خانه خود را دارند بکار می‌رود. پیکربندی چنین سرویسی کمی پیچیده‌تر است: ابتدا بسته <span
              class="pkg pkg">vnc4server</span> را نصب می‌کنید، پیکربندی مدیر نمایش را به منظور قبول درخواست‌های <code
              class="literal">XDMCP Query</code> تغییر می‌دهید (برای <code
              class="command">gdm3</code>، اینکار با افزودن <code
              class="literal">Enable=true</code> در قسمت “xdmcp” از فایل <code
              class="filename">/etc/gdm3/daemon.conf</code> صورت می‌گیرد) و در نهایت سرور VNC را با استفاده از <code
              class="command">inetd</code> آغاز می‌کنید به طوری که هر زمان کاربر درخواست داد نشست مربوطه آغاز گردد. برای نمونه، می‌توانید این خط را به فایل <code
              class="filename">/etc/inetd.conf</code> بیفزایید:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				هدایت ارتباطات ورودی به مدیر نمایش مشکل احراز هویت را حل می‌کند، چرا که تنها کاربران با حساب‌های کاربری محلی می‌توانند از صفحه <code
              class="command">gdm3</code> عبور کنند (یا معادل <code
              class="command">kdm</code>، <code
              class="command">xdm</code> و از این قبیل). از آنجا که این عملیات امکان چندین ورودی مختلف را فراه می‌کند (در صورت قوی بودن سرور)، می‌تواند برای ارائه میزکارهای گرافیکی برای کاربران سیار (یا برای سیستم‌های رومیزی ضعیف‌تر) استفاده شود. کاربران تنها کافی است با استفاده از <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code> به سرور متصل شوند، چرا که پورت مورد استفاده ۵۹۵۰ است.
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>قبلی</strong>
      فصل 9. سرویس‌های یونیکس</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>بعدی</strong>9.3. مدیریت دسترسی</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.remote-login.html">ar-MA</a></li><li><a
              href="../da-DK/sect.remote-login.html">da-DK</a></li><li><a
              href="../de-DE/sect.remote-login.html">de-DE</a></li><li><a
              href="../el-GR/sect.remote-login.html">el-GR</a></li><li><a
              href="../en-US/sect.remote-login.html">en-US</a></li><li><a
              href="../es-ES/sect.remote-login.html">es-ES</a></li><li><a
              href="../fa-IR/sect.remote-login.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.remote-login.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.remote-login.html">hr-HR</a></li><li><a
              href="../id-ID/sect.remote-login.html">id-ID</a></li><li><a
              href="../it-IT/sect.remote-login.html">it-IT</a></li><li><a
              href="../ja-JP/sect.remote-login.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.remote-login.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.remote-login.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.remote-login.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.remote-login.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.remote-login.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.remote-login.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.remote-login.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.remote-login.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.remote-login.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.remote-login.html">zh-TW</a></li></ul></div></body></html>
