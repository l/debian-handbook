<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">فصل 9. سرویس‌های یونیکس</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="راه‌اندازی سیستم, اسکریپت‌های init, SSH, Telnet, حقوق, مجوزها, نظارت, Inetd, Cron, پشتیبان‌گیری, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. نصب یک کرنل" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. دسترسی از راه‌دور" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/fa-IR/unix-services.html" /></head><body
      dir="rtl"><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>بعدی</strong></a></li></ul><div
        xml:lang="fa-IR"
        class="chapter"
        lang="fa-IR"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>
      فصل 9. سرویس‌های یونیکس</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. راه‌اندازی سیستم</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. سیستم راه‌انداز systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. سیستم راه‌انداز System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. دسترسی از راه‌دور</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. ورود امن از راه‌دور: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. استفاده از میزکارهای گرافیکی راه‌دور</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. مدیریت دسترسی</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. رابط‌های مدیریتی</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. مدیریت سیستم با استفاده از یک رابط تحت-وب: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. پیکربندی بسته‌ها: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> رویدادهای سیستمی</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. اصل و مکانیزم</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. فایل پیکربندی</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. ابر-سرور <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. زمان‌بندی وظیفه‌ها با <code
                    class="command">cron</code> و <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. قالب یک فایل <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. استفاده از دستور <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. زمان‌بندی وظیفه‌های غیرهمزمان: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. سهمیه‌بندی</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. پشتیبان‌گیری</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. پشتیبان‌گیری با استفاده از <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. بازیابی رایانه‌هایی که فایل پشتیبان ندارند</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. اتصال سریع: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. مقدمه</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. مشکل نامگذاری</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. چگونگی کارکرد <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. یک مثال کامل</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. مدیریت نیرو؛ پیکربندی پیشرفته و رابط کار با نیرو (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		این فصل به پوشش سرویس‌های پایه‌ای می‌پردازد که در بسیاری از سیستم‌های یونیکس متداول هستند. تمام مدیرسیستم‌ها باید با آن‌ها آشنا باشند.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. راه‌اندازی سیستم</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			زمانی که رایانه را راه‌اندازی می‌کنید، پیام‌های زیادی که در کنسول به شما نمایش داده می‌شوند نشان‌دهنده عملیات خودکار راه‌اندازی و پیکربندی سیستم هستند. شاید بعضی وقت‌ها بخواهید تغییری در این مرحله ایجاد کنید، که به معنای درک اولیه صحیح از آن است. هدف این قسمت نیز همین است.
		</div><div
            class="para">
			ابتدا، BIOS کنترل رایانه را بر عهده می‌گیرد، دیسک‌ها را شناسایی کرده، <span
              class="emphasis"><em>Master Boot Record</em></span> را بارگیری می‌کند و به اجرای راه‌اندازسیستم می‌پردازد. راه‌اندازسیستم کنترل را بدست گرفته، کرنل را روی دیسک پیدا می‌کند، آن را بارگیری کرده سپس اجرا می‌کند. کرنل در این مرحله راه‌اندازی شده و به جستجو پارتیشن شامل فایل‌سیستم روت می‌پردازد سپس آن را متصل کرده و اولین برنامه یعنی <code
              class="command">init</code> را اجرا می‌کند. به طور معمول، این “پارتیشن روت” و این برنامه <code
              class="command">init</code>، در حفیقت درون یک فایل‌سیستم مجازی در حافظه اصلی به نام “initramfs”، (که سابق بر این با نام “initrd” که مخفف “Initial Ram Disk” است)، قرار دارند. این فایل‌سیستم توسط راه‌اندازسیستم درون حافظه اصلی قرار می‌گیرد، که اغلب از طریق یک فایل روی هارد درایو یا شبکه قابل دسترس است. شامل حداقل امکانات لازم برای کرنل جهت راه‌اندازی فایل‌سیستم روت “حقیقی” است: ممکن است شامل ماژول‌های درایور مورد نیاز هارد درایو، یا دستگا‌ه‌های دیگری که سیستم قادر به راه‌اندازی آن‌ها نیست، یا به طور متداول، اسکریپت‌های راه‌اندازی و ماژول‌های مورد نیاز برای پیکربندی آرایه‌های RAID، بازکردن پارتیشن‌های رمزگذاری شده، فعال‌سازی LVM و مواردی از این دست باشد. زمانی که پارتیشن روت متصل گردید، initramfs کنترل را به init حقیقی می‌سپارد و ماشین به فرآیند راه‌اندازی استاندارد خود باز می‌گردد.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="ترتیب اجرای عملیات راه‌اندازی در لینوکس به همراه systemd" /></div></div><p
              class="title"><strong>
      شكل 9.1. ترتیب اجرای عملیات راه‌اندازی در لینوکس به همراه systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. سیستم راه‌انداز systemd</h3></div></div></div><div
              class="para">
				“init حقیقی” توسط <span
                class="pkg pkg">systemd</span> ارائه شده است که این قسمت به بررسی آن می‌پردازد.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>فرهنگ</em></span> قبل از <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> یک “سیستم راه‌انداز” جدید به حساب می‌آید، با اینکه در محیط‌های گوناگونی از قبل وجود داشته است مانند <span
                  class="distribution distribution">Wheezy</span>، در نسخه <span
                  class="distribution distribution">Jessie</span> از دبیان بود که به عنوان پیش‌فرض انتخاب شد. انتشارهای سابق آن، به صورت پیش‌فرض، بر اساس “System V init” بودند (در بسته <span
                  class="pkg pkg">sysv-rc</span>)، یک سیستم قدیمی‌تر در این زمینه. در ادامه به توضیح System V init می‌پردازیم.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>جایگزین</em></span> سایر سیستم‌های راه‌انداز</strong></p></div></div></div><div
                class="para">
				این کتاب به توضیح سیستم راه‌انداز موجود در دبیان <span
                  class="distribution distribution">Jessie</span> می‌پردازد (که توسط بسته <span
                  class="pkg pkg">systemd</span> پیاده‌سازی شده است)، به همراه نسخه پیش‌فرض قبلی، <span
                  class="pkg pkg">sysvinit</span> که از سیستم‌های یونیکس <span
                  class="emphasis"><em>System V</em></span> مشتق شده است؛ گزینه‌های دیگری نیز وجود دارد.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> یک سیستم راه‌انداز با فرآیندی بسیار ساده است. بر اساس اصول runlevel کار کرده، اما دایرکتوری‌ها و پیوندهای نمادین را با یک فایل پیکربندی جایگزین می‌کند، که به <code
                  class="command">init</code> فرآیندهای مورد نیاز جهت اجرا و ترتیب اجرای هر کدام را نشان می‌دهد.
			</div><div
                class="para">
				سیستم <code
                  class="command">upstart</code> هنوز به خوبی در دبیان مورد آزمون قرار نگرفته است. این سیستم، رویدادگرا است: اسکریپت‌های راه‌انداز دیگر بر اساس ترتیب سابق اجرا نمی‌شوند بلکه در پاسخ به رویدادهایی که وضعیت سیستم را تغییر می‌دهند مانند اتمام یک اسکریپت دیگر که به آن وابسته هستند. این سیستم، که توسط اوبونتو آغاز گردید، در دبیان <span
                  class="distribution distribution">Jessie</span> موجود است، اما گزینه پیش‌فرض آن نیست؛ در حقیقت، به عنوان جایگزینی برای <span
                  class="pkg pkg">sysvinit</span> مطرح می‌شود و یکی از وظایف <code
                  class="command">upstart</code> اجرای اسکریپت‌های نوشته شده برای سیستم‌های قدیمی‌تر است، به خصوص آن‌هایی که به بسته <span
                  class="pkg pkg">sysv-rc</span> تعلق دارند.
			</div><div
                class="para">
				سیستم‌های راه‌انداز دیگری مانند <code
                  class="command">runit</code> یا <code
                  class="command">minit</code> وجود دارند، اما بسیار خاص منظوره طراحی شده‌اند و از این رو عمومیت ندارند.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مورد خاص</em></span> راه‌اندازی از طریق شبکه</strong></p></div></div></div><div
                class="para">
				در برخی پیکربندی‌ها، BIOS طوری تنظیم می‌شود که نه تنها به دنبال MBR باشد، بلکه معادل آن را از روی شبکه پیدا کند، که اینکار امکان راه‌اندازی رایانه‌های بدون هارد درایو را فراهم می‌کند یا آن‌هایی که به طور کامل در هر مرتبه راه‌اندازی از نو نصب می‌گردند. این گزینه در تمام سخت‌افزارها موجود نیست و به یک ترکیب مناسب از BIOS و کارت شبکه نیاز دارد.
			</div><div
                class="para">
				راه‌اندازی از طریق شبکه می‌تواند به اجرای <code
                  class="command">debian-installer</code> یا FAI (قسمت <a
                  class="xref"
                  href="installation.html#sect.installation-methods">
      قسمت 4.1, “روش‌های نصب”
    </a> را مشاهده کنید) ختم گردد.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>بازگشت به مقدمات</em></span> فرآیند، نمونه یک برنامه</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				یک فرآیند نماد اجرایی یک برنامه داخل حافظه است. شامل تمام اطلاعات لازم برای اجرای صحیح نرم‌افزار می‌باشد (کد برنامه، به همراه داده‌هایی که حافظه اشغال کرده‌اند، فهرست فایل‌هایی که باز کرده است، اتصلات شبکه‌ای که برقرار کرده است و از این قبیل). یک برنامه می‌تواند شامل چندین فرآیند باشد، که الزاما توسط شناسه کاربری‌های متفاوت اجرا نمی‌شوند.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>امنیت</em></span> استفاده از پوسته‌ای مانند <code
                          class="command">init</code> به منظور دسترسی به مجوزهای root</strong></p></div></div></div><div
                class="para">
				بر اساس قرارداد، اولین برنامه‌ای که اجرا می‌شود <code
                  class="command">init</code> نام دارد (که یک پیوند نمادین به فایل <code
                  class="filename">/lib/systemd/systemd</code> است). اگرچه، امکان ارسال گزینه <code
                  class="literal">init</code> به کرنل با نام برنامه‌ای دیگر وجود دارد.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				هر فردی که قابلیت دسترسی به رایانه را دارد می‌تواند دکمه <span
                  class="keycap"><strong>Reset</strong></span> را فشار دهد و آن را راه‌اندازی مجدد نماید. آنگاه در صفحه راه‌اندازسیستم، امکان ارسال گزینه <code
                  class="literal">init=/bin/sh</code> به کرنل جهت دسترسی به حساب کاربری root بدون گذرواژه فراهم می‌آید.
			</div><div
                class="para">
				برای جلوگیری از آن، می‌توانید راه‌اندازسیستم را با یک گذرواژه محافظت کنید. همچنین ممکن است بخواهید از BIOS نیز مراقبت کنید (یک مکانیزم محافظت با گذرواژه همیشه موجود است)، که بدون آن یک عامل نفوذی می‌تواند به سادگی سیستم را از طریق یک حافظه جانبی که شامل سیستم لینوکس خودش است راه‌اندازی کند، که از طریق آن می‌تواند به اطلاعات موجود روی هارد درایوها دسترسی داشته باشد.
			</div><div
                class="para">
				در نهایت، آگاه باشید که اکثر BIOSها یک گذرواژه متداول دارند. به منظور عیب‌یابی برای افرادی که گذرواژه خود را فراموش می‌کنند، این گذزواژه‌ها عمومی بوده و در اینترنت موجود هستند (جستجوی عبارت “generic BIOS passwords” در یک موتور جستجو). تمام این عملیات محافظتی به منظور مانع شدن از دسترسی غیرمجاز به سیستم است. هیچ روش شناخته‌شده‌ای به منظور محافظت از رایانه وجود ندارد مادامی که مهاجم بتواند به آن دسترسی فیزیکی داشته باشد؛ آن‌ها می‌توانند هارد درایو را از جای خود کنده و با خود ببرند، یا حتی کل ماشین فیزیکی را بدزدند، یا جافظه BIOS را به منظور از بین رفتن گذرواژه پاک کنند.
			</div></div><div
              class="para">
				... فرآیندهای بسیاری را اجرا می‌کند، که مسئول راه‌اندازی سیستم هستند: صفحه‌کلید، درایورها، فایل‌سیستم‌ها، شبکه، سرویس‌ها. این عملیات را هنگامی که کل سیستم را تحت نظر دارد اجرا می‌کند و به بررسی پیش‌نیازهای هر یک می‌پردازد. هر جزء توسط یک “unit file” توضیح داده می‌شود (بعضی وقت‌ها بیشتر)؛ شیوه نگارش آن بر اساس قالب شناخته‌شده “*.ini files“ است، به همراه جفت مقادیر <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> که در بین سرآیندهای <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> گروه‌بندی شده‌اند. این فایل‌ها در مسیر <code
                class="filename">/lib/systemd/system/</code> و <code
                class="filename">/etc/systemd/system/</code> ذخیره‌سازی شده‌اند؛ آن‌ها به شیوه‌های گوناگونی وجود دارند که در اینجا به بررسی “سرویس‌ها” و “اهداف” می‌پردازیم.
			</div><div
              class="para">
				یک “فایل سرویس” از systemd به یک فرآیند قابل مدیریت توسط آن را توضیح می‌دهد. تقریبا همان اطلاعات اسکریپت‌های قدیمی init را دارا هستند اما به شیوه‌ای نوین و مختصر بیان شده است. systemd عمده فعالیت‌های تکراری را بر عهده می‌گیرد (آغاز و پایان یک فرآیند، بررسی وضعیت آن، گزارش‌گیری، بررسی مجوزها و از این قبیل) و فایل سرویس تنها لازم دارد موارد خاص آن فرآیند را بیان کند. برای نمونه، در اینجا نمونه‌ای از فایل سرویس مربوط به SSH را می‌بینیم:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				همانطور که مشاهده می‌کنید، کد بسیار کمی در آن وجود دارد، تنها تعریف‌های مورد نیاز. systemd مواردی از قبیل نمایش گزارش‌های پیشرفت، بررسی وضعیت فرآیندها و حتی اجرای مجددشان هر زمان لازم باشد را انجام می‌دهد.
			</div><div
              class="para">
				یک “فایل هدف” از systemd به تشریح وضعیت یک سیستم می‌پردازد، که در آن مجموعه‌ای از سرویس‌ها اعمال می‌شوند. این فایل می‌تواند به عنوان معادل قدیمی runlevel فرض شود. یکی از اهداف <code
                class="literal">local-fs.target</code> است؛ زمانی که محقق گردد، باقی سیستم می‌توانند تصور کنند که تمام فایل‌سیستم‌های محلی متصل شده و قابل دسترس هستند. سایر اهداف شامل <code
                class="literal">network-online.target</code> و <code
                class="literal">sound.target</code> می‌شوند. وابستگی‌های یک هدف می‌توانند درون فایل آن نوشته شوند (در خط <code
                class="literal">Requires=</code>) یا از یک پیوند نمادین به یک فایل سرویس در دایرکتوری <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> استفاده شوند. برای نمونه، <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> شامل پیوندی به <code
                class="filename">/lib/systemd/system/cups.service</code> است؛ systemd اطمینان می‌یابد که برای دسترسی به <code
                class="literal">printer.target</code> ابتدا CUPS باید اجرا گردد.
			</div><div
              class="para">
				از آنجا که فایل‌های واحد بر خلاف اسکریپت‌ها یا برنامه‌ها جنبه بیانی دارند، به طور مستقیم قابل اجرا نیستند و تنها توسط systemd تفسیر می‌گردند؛ برخی ابزارهای جانبی این امکان را به مدیرسیستم می‌دهند که به صورت تعاملی با systemd برخورد کرده و هر یک از اجزای آن را مدیریت کنند.
			</div><div
              class="para">
				اولین ابزار در این زمینه <code
                class="command">systemctl</code> نام دارد. زمانی که بدون هیچ پارامتری اجرا گردد، به فهرست کردن تمام فایل‌های واحد شناخته‌شده برای systemd می‌پردازد (به جز آن‌هایی که غیرفعال شده‌اند) به همراه وضعیت هر کدام. <code
                class="command">systemctl status</code> دید مناسب‌تری از سرویس‌ها را ارائه می‌دهد، به همراه فرآیندهای مربوط به هر کدام. اگر نام یک سرویس نیز داده شود (مانند <code
                class="command">systemctl status ntp.service</code>) جزئیات بیشتری نیز نمایش داده می‌شود به همراه آخرین خطوط گزارش مرتبط با آن (که بعدا به آن می‌رسیم).
			</div><div
              class="para">
				شروع یک سرویس به صورت دستی به سادگی اجرای دستور <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code> است. همانطور که حدس زدید، توقف سرویس با استفاده از <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code> صورت می‌گیرد؛ سایر دستورات زیر-مجموعه عبارتند از <code
                class="command">reload</code> و <code
                class="command">restart</code>.
			</div><div
              class="para">
				به منظور اطلاع از فعال‌بودن یک سرویس (خواه در زمان راه‌اندازی سیستم اجرا شده باشد یا خیر) از دستور <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> استفاده کنید (یا <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> برای بررسی وضعیت سرویس بکار می‌رود.
			</div><div
              class="para">
				یک ویژگی جالب از systemd افزودن یک جزء به نام <code
                class="command">journald</code> است. به عنوان یک مکمل برای سیستم‌های گزارش‌گیری قدیمی‌تر مانند <code
                class="command">syslogd</code> به حساب می‌آید که ویژگی‌های جالبی مانند افزودن یک پیوند رسمی بین سرویس و پیام‌هایی که تولید می‌کند یا قابلیت دریافت پیام‌های خطای تولید شده توسط ترتیب اولیه آن‌ها را شامل می‌شود. پیام‌ها در ادامه می‌توانند نمایش داده شوند، با اندکی کمک از دستور <code
                class="command">journalctl</code>. بدون هیچ پارامتری، به تشریخ تمام پیام‌های لاگ که از راه‌اندازی سیستم دریافت کرده است می‌پردازد؛ البته به این شکل کمتر استفاده می‌شود. در اکثر موارد، به همراه شناسه یک سرویس بکار می‌رود:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				گزینه جالب دیگر در خط-فرمان <code
                class="command">-f</code> است که به <code
                class="command">journalctl</code> می‌گوید به نمایش پیام‌های جدید اضافه‌شده به انتهای فایل بپردازد (مانند عملکردی که <code
                class="command">tail -f <em
                  class="replaceable">file</em></code> دارد).
			</div><div
              class="para">
				اگر سرویس عملکرد مورد نظر را نداشته باشد، اولین مرحله عیب‌یابی این است که بدانیم آیا سرویس اجرا شده است یا خیر با استفاده از دستور <code
                class="command">systemctl status</code>؛ اگر اجرا نشده بود و پیام‌های دستور اول به عیب‌یابی مشکل کمکی نکرد، به بررسی گزارش‌های تهیه شده توسط journald مرتبط با آن سرویس بپردازید. برای نمونه، تصور کنید که سرویس SSH کار نمی‌کند:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				پس از بررسی وضعیت سرویس (failed)، به بررسی فایل‌های گزارش پرداختیم؛ آن‌ها نشان دادند که یک خطا در فایل پیکربندی وجود دارد. پس از ویرایش فایل پیکربندی و اصلاح خطا، سرویس را راه‌اندازی مجدد کردیم و دیدیم که به درستی کار می‌کند.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مطالعه بیشتر</em></span> سایر انواع فایل‌های واحد</strong></p></div></div></div><div
                class="para">
				در این قسمت به ساده‌ترین قابلیت‌های systemd اشاره کردیم. اما ویژگی‌های جالب دیگری را نیز ارائه می‌دهد که در اینجا فقط برخی از آن‌ها را نام می‌بریم:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						فعال‌سازی سوکت: یک فایل واحد “سوکت” می‌تواند به منظور شرح یک شبکه یا سوکت یونیکس که توسط systemd مدیریت می‌شود بکار رود؛ این بدان معناست که سوکت توسط systemd ایجاد می‌شود و سرویس حقیقی تنها زمانی که درخواستی برای آن مطرح گردد آغاز می‌شود. این عملکرد نزدیک به <code
                        class="command">inetd</code> است. <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span> را مشاهده کنید.
					</div></li><li
                    class="listitem"><div
                      class="para">
						زمانسنج‌ها: یک فایل واحد “زمانسنج” وقایعی را شرح می‌دهد که در یک بازه زمانی ثابت یا زمان‌های مشخص تکرار می‌شوند؛ زمانی که یک سرویس به چنین زمانسنجی متصل گردد، فعالیت مرتبط با آن هنگام واکنش زمانسنج آغاز می‌گردد. این عملکرد نزدیک به <code
                        class="command">cron</code> است. <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span> را مشاهده کنید.
					</div></li><li
                    class="listitem"><div
                      class="para">
						شبکه: یک فایل واحد “شبکه“ به توضیح یک رابط شبکه می‌پردازد که امکان پیکربندی چنین رابطی را فراهم آورده و همچنین بیان می‌کند کدام سرویس وابسته به این رابط خواهد بود.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. سیستم راه‌انداز System V</h3></div></div></div><div
              class="para">
				سیستم راه‌انداز System V (که به اختصار init می‌نامیم) چندین فرآیند را اجرا می‌کند، که دستورالعمل‌های آن در فایل <code
                class="filename">/etc/inittab</code> آمده است. اولین برنامه‌ای که اجرا می‌شود (که معادل با گام <span
                class="emphasis"><em>sysinit</em></span> است) برابر با <code
                class="command">/etc/init.d/rcS</code> است، اسکریپتی که سایر برنامه‌های موجود در دایرکتوری <code
                class="filename">/etc/rcS.d/</code> را اجرا می‌کند. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				در میان آن‌ها، برنامه‌های پی‌در‌پی مرتبطی پیدا خواهید کرد:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						پیکربندی صفحه‌کلید کنسول؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						بارگیری درایورها: اکثر ماژول‌های کرنل توسط خودش هنگام شناسایی سخت‌افزار بارگیری می‌شوند؛ درایورهای اضافی به صورت خودکار زمانی که ماژول مربوطه در فایل <code
                      class="filename">/etc/modules</code> قرار گیرد بارگیری می‌شوند.
					</div></li><li
                  class="listitem"><div
                    class="para">
						بررسی جامعیت فایل‌سیستم‌ها؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						متصل‌کردن پارتیشن‌های محلی؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						پیکربندی شبکه؛
					</div></li><li
                  class="listitem"><div
                    class="para">
						متصل‌کردن فایل‌سیستم‌های شبکه یا NFS.
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>بازگشت به مقدمات</em></span> ماژول‌های کرنل و گزینه‌های آن‌ها</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				ماژول‌های کرنل دارای گزینه‌هایی هستند که می‌توانند با قرار گرفتن در مسیر <code
                  class="filename">/etc/modprobe.d/</code> پیکربندی شوند. این گزینه‌ها با دستوراتی این چنین تعریف می‌شوند: <code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code>. چندین گزینه در صورت لزوم می‌توانند تنها با یک دستور تعریف شوند.
			</div><div
                class="para">
				این فایل‌های پیکربندی برای <code
                  class="command">modprobe</code> در نظر گرفته شده‌اند - برنامه‌ای که یک ماژول کرنل به همراه وابستگی‌هایش را بارگیری می‌کند (ماژول‌ها می‌توانند یکدیگر را فراخوانی کنند). این برنامه توسط بسته <span
                  class="pkg pkg">kmod</span> ارائه می‌شود.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				پس از این گام، <code
                class="command">init</code> وارد می‌شود و برنامه‌های فعال‌شده در runlevel پیش‌فرض (که معمولا شماره ۲ است) را آغاز می‌کند. به اجرای <code
                class="command">/etc/init.d/rc 2</code> می‌پردازد، اسکریپتی که تمام سرویس‌های موجود در <code
                class="filename">/etc/rc2.d/</code> که با حرف “S” شروع می‌شوند را آغاز می‌کند. عدد دو رقمی که بعد از نام هر سرویس قرار دارد ترتیب اجرای آن‌ها را مشخص می‌کند، اما امروزه سیستم راه‌انداز پیش‌فرض از <code
                class="command">insserv</code> به این منظور استفاده می‌کند، که تمام مراحل را با توجه به وابستگی‌های بین اسکریپت‌ها زمان‌بندی می‌کند. هر اسکریپت راه‌انداز شرایط مربوط به خود جهت اَغاز یا پایان سرویس را توصیف می‌کند (برای نمونه، اگر باید قبل یا بعد از یک سرویس دیگر آغاز گردد)؛ <code
                class="command">init</code> سپس به اجرای آن‌ها با توجه به شرایط موجود می‌پردازد. بنابراین شماره‌گذاری ایستا که در اسکریپت‌ها استفاده می‌شد دیگر به حساب نمی‌آید (اما آن‌ها باید نامی که با “S” شروع می‌شود به همراه عدد دو رقمی و نام حقیقی سرویس را به همراه داشته باشند). در حالت کلی، سرویس‌های پایه (مانند گزارش‌گیری با <code
                class="command">rsyslog</code> یا تخصیص پورت با <code
                class="command">portmap</code>) در ابتدا آعاز می‌گردند به همراه سرویس‌های استاندارد و رابط گرافیکی (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				این سیستم راه‌انداز مبتنی بر وابستگی‌ها امکان شماره‌گذاری مجدد را فراهم می‌کند، کاری که در حالت دستی دشواری‌های فراوانی دارد و امکان خطای انسانی را کاهش می‌دهد چرا که زمان‌بندی مختص به پارامترهای مشخص شده می‌باشد. مزیت دیگر آن این است که سرویس‌ها می‌توانند به صورت موازی آغاز شوند زمانی که به یکدیگر وابسته نیستند، که این امر به فرآیند راه‌اندازی سرعت می‌بخشد.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				... قابلیت شناسایی چندین runlevel را دارد، پس می‌تواند بین آن‌ها با استفاده از دستور <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> جابجا شود. بلافاصله، <code
                class="command">init</code> به اجرای <code
                class="command">/etc/init.d/rc</code> با runlevel جدید می‌پردازد. این اسکریپت به اجرای سرویس‌های مفقود و توقف آن‌هایی که دیگر مورد نیاز نیستند می‌پردازد. به این منظور، به محتوای موجود در مسیر <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ارجاع می‌کند (که <em
                class="replaceable">X</em> نشان‌دهنده runlevel جدید است). اسکریپت‌هایی که با “S” شروع می‌شوند (به معنای “Start”) سرویس‌هایی هستند که باید آغاز گردند؛ آن‌هایی که با “K” شروع می‌شوند (به معنای “Kill”) سرویس‌هایی هستند که باید متوقف گردند. اسکریپت به اجرای سرویس فعال در runlevel قبلی نمی‌پردازد.
			</div><div
              class="para">
				به صورت پیش‌فرض، سیستم راه‌انداز System V در دبیان از چهار runlevel متفاوت استفاده می‌کند:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						سطح ۰ هنگام خاموش شدن رایانه به صورت موقتی استفاده می‌شود. به همین دلیل شامل بسیاری اسکریپت‌های “K” است.
					</div></li><li
                  class="listitem"><div
                    class="para">
						سطح ۱، که به نام حالت تک-کاربره نیز شناخته می‌شود، مطابق با سیستم در حالت عیب‌یابی است؛ تنها شامل سرویس‌های پایه است و مناسب عملیات عیب‌یابی است که تعامل با کاربران در آن مد نظر نباشد.
					</div></li><li
                  class="listitem"><div
                    class="para">
						سطح ۲ برای عملکرد نرمال استفاده می‌شود که شامل سرویس‌های شبکه، رابط گرافیکی، ورود کاربر و از این قبیل است.
					</div></li><li
                  class="listitem"><div
                    class="para">
						سطح ۶ که به سطح ۰ مشابه است تنها با این تفاوت که برای حالت راه‌اندازی مجدد رایانه استفاده می‌گردد.
					</div></li></ul></div><div
              class="para">
				سطح‌های دیگری نیز وجود دارند، به خصوص ۳ تا ۵. به صورت پیش‌فرض آن‌ها مانند سطح ۲ عمل می‌کنند، اما مدیرسیستم می‌تواند آن‌ها را تغییر دهد (با افزودن یا حذف اسکریپت‌هایی در دایرکتوری <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>) تا آن‌ها را برای نیازهای خاص سازگار سازد.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="ترتیب اجرای عملیات راه‌اندازی در لینوکس به همراه System V" /></div></div><p
                class="title"><strong>
      شكل 9.2. ترتیب اجرای عملیات راه‌اندازی در لینوکس به همراه System V</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				تمام اسکریپت‌های موجود در دایرکتوری‌های <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> تنها پیوندهای نمادین هستند - که توسط برنامه <code
                class="command">update-rc.d</code> هنگام نصب یک بسته ایجاد می‌گردند - که به اسکریپت‌های اصلی ذخیره‌شده در <code
                class="filename">/etc/init.d/</code> اشاره می‌کنند. مدیرسیستم می‌تواند به بهینه‌سازی سرویس‌های موجود در هر runlevel با اجرای دستور <code
                class="command">update-rc.d</code> به همراه پارامترهای لازم بپردازد. صفحه راهنمای <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> به تشریح شیوه استفاده از آن پرداخته است. به یاد داشته باشید که حذف پیوندهای نمادین (با پارامتر <code
                class="literal">remove</code>) روش خوبی برای غیرفعال‌کردن یک سرویس نیست. در عوض باید طوری پیکربندی کنید که در runlevel مورد نظر اجرا نشود (به صورتی که فراخوانی‌های مربوطه به آن از runlevel قبلی متوقف گردند). از آنجا که <code
                class="command">update-rc.d</code> خود دارای رابط جداگانه‌ای است ممکن است بخواهید از <code
                class="command">rcconf</code> استفاده کنید (از بسته <span
                class="pkg pkg">rcconf</span>) که رابط کاربری بهتری فراهم کرده است.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>خط‌مشی دبیان</em></span> راه‌اندازی‌مجدد سرویس‌ها</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				اسکریپت‌های پیکربندی برای بسته‌های دبیان بعضی وقت‌ها اقدام به راه‌اندازی‌مجدد سرویس‌ها به منظور در دسترس بودن آن‌ها ای افزودن برخی گزینه‌های خاص به آن‌ها می‌کنند. دستوری که سرویس را کنترل می‌کند - <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> - runlevel را به حساب نمی‌آورد، تصور می‌کند (به صورت اشتباه) که سرویس هم اکنون استفاده شده است و از این رو عملیات اشتباهی را رقم می‌زند (آغاز سرویسی که به عمد متوقف شده بود، یا پایان سرویسی که هم اکنون متوقف است). به این منظور دبیان برنامه <code
                  class="command">invoke-rc.d</code> را معرفی کرد: این برنامه باید توسط اسکریپت‌های پیکربندی به منظور اجرای سرویس‌های اسکریپت‌های راه‌انداز و اجرای دستورات لازم استفاده گردد. نکته اینکه، بر خلاف استفاده متداول آن، پسوند <code
                  class="filename">.d</code> در اینجا در نام یک برنامه بکار رفته است و نه یک دایرکتوری.
			</div></div><div
              class="para">
				در نهایت، <code
                class="command">init</code> به اجرای برنامه‌های کنترلی مرتبط با کنسول‌های مجازی (<code
                class="command">getty</code>) می‌پردازد. یک صفحه خالی که نام‌کاربری را درخواست می‌کند نمایش می‌یابد، سپس برای برپایی یک نشست به اجرای <code
                class="command">login <em
                  class="replaceable">user</em></code> می‌پردازد.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>واژگان</em></span> کنسول و ترمینال</strong></p></div></div></div><div
                class="para">
				اولین رایانه‌ها به قسمت‌های بسیار بزرگی تقسیم شده بودند: فضای ذخیره‌سازی و واحد پردازش مرکری از دستگا‌ه‌های جانبی که توسط اپراتورها استفاده می‌شدند جدا بودند. این‌ها قسمتی از یک چیدمان جداگانه بودند یعنی “کنسول”. این عبارت اکنون حفظ شده ولی معنای آن تغییر یافته است. بیشتر با “ترمینال” مترادف است که به معنای صفحه‌کلید و نمایشگر است.
			</div><div
                class="para">
				با توسعه رایانه‌ها، سیستم‌عامل‌ها امکان استفاده از چندین کنسول مجازی که توسط چندین نشست جداگانه اجرا می‌شوند را فراهم آوردند، حتی اگر یک صفحه‌کلید و نمایشگر وجود داشته باشد. اکثر سیستم‌های گنو/لینوکس دارای شش کنسول مجازی هستند (در حالت متنی) که از طریق کلید‌های <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> تا <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> قابل دسترس می‌باشند.
			</div><div
                class="para">
				عبارت‌های “کنسول” و “ترمینال” می‌توانند به یک شبیه‌ساز ترمینال در محیط گرافی X11 اشاره کنند (مانند <code
                  class="command">xterm</code>، <code
                  class="command">gnome-terminal</code> یا <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>قبلی</strong>8.11. نصب یک کرنل</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>بعدی</strong>9.2. دسترسی از راه‌دور</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../ko-KR/unix-services.html">ko-KR</a></li><li><a
              href="../nb-NO/unix-services.html">nb-NO</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../vi-VN/unix-services.html">vi-VN</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li><li><a
              href="../zh-TW/unix-services.html">zh-TW</a></li></ul></div></body></html>
