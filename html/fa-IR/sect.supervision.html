<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. نظارت: پیشگیری، شناسایی، بازدارندگی</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="فایروال, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="security.html"
        title="فصل 14. امنیت" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. فایروال یا فیلترینگ بسته" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. مقدمه‌ای بر AppArmor" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/fa-IR/sect.supervision.html" /></head><body
      dir="rtl"><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.supervision"></a>14.3. نظارت: پیشگیری، شناسایی، بازدارندگی</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			مانیتورینگ، بنا بر دلایل مختلف، یک بخش جدایی ناپذیر از هر خط مشی امنیتی به حساب می‌آید. از میان آن‌ها، نه تنها هدف امنیت محدود به ضمانت از محرمانگی داده نیست، بلکه شامل دسترسی به سرویس‌ها نیز می‌باشد. پس ضروری است که از عملکرد صحیح اجزا اطلاع داشته و بتوان در گذر زمان هر گونه انحراف یا تغییر در کیفیت خدمات را تشخیص دهیم. مانیتورینگ می‌تواند به شناسایی تلاش به نفوذ و فعال‌سازی یک اقدام سریع قبل از اینکه عواقب جبران ناپذیر اتفاق بیفتد، کمک کند. این قسمت به بررسی چندین ابزار می‌پردازد که جنبه‌های مختلف مانیتورینگ در یک سیستم دبیان را شامل می‌شوند. از این رو، کامل کننده <a
            class="xref"
            href="sect.monitoring.html">
      قسمت 12.4, “مانیتورینگ”
    </a> به حساب می‌آید.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.logcheck"></a>14.3.1. مانیتورینگ گزارش‌ها با استفاده از <code
                    class="command">logcheck</code></h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				برنامه <code
              class="command">logcheck</code> به صورت پیشفرض در هر ساعت به فایل‌های گزارش نظارت کرده و پیام‌های گزارش غیر معمول را از طریق ایمیل به مدیر سیستم برای تحلیل بیشتر ارسال می‌کند.
			</div><div
            class="para">
				فهرستی از فایل‌های نظارت شده در <code
              class="filename">/etc/logcheck/logcheck.logfiles</code> ذخیره‌سازی می‌گردد؛ مقادیر پیشفرض در صورتی کار می‌کنند که فایل <code
              class="filename">/etc/rsyslog.conf</code> به صورت کامل بازسازی نشده باشد.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> می‌تواند در یکی از سه حالت موجود کار کند: <span
              class="emphasis"><em>paranoid</em></span>، <span
              class="emphasis"><em>server</em></span> و <span
              class="emphasis"><em>workstation</em></span>. حالت اول شامل جزئیات <span
              class="emphasis"><em>بسیاری</em></span> است که تنها باید در مورد سرورهایی نظیر فایروال استفاده گردد. حالت دوم (و پیشفرض) برای اکثر سرورها توصیه می‌شود. حالت آخر نیز در مورد رایانه‌های رومیزی کاربرد دارد که شامل جزئیات کمتری می‌شود (پیام‌های بیشتری را فیلتر می‌کند).
			</div><div
            class="para">
				در هر سه مورد، <code
              class="command">logcheck</code> به منظور پیشگیری از پیام‌های اضافی باید سفارشی‌سازی گردد (مبتنی بر سرویس‌های نصب شده)، مگر اینکه مدیر سیستم بخواهد به صورت ساعتی فهرستی از ایمیل‌های طولانی و ناخواسته را مشاهده کند. از آنجا که مکانیزم انتخاب پیام به قدری پیچیده است، مطالعه <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> به شدت توصیه می‌شود.
			</div><div
            class="para">
				قوانین اعمال شده می‌توانند به چندین نوع تقسیم شوند:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						آن‌هایی که صلاحیت یک پیام را به عنوان تلاش برای نفوذ در نظر می‌گیرند (که در دایرکتوری <code
                    class="filename">/etc/logcheck/cracking.d/</code> ذخیره‌سازی می‌شوند)؛
					</div></li><li
                class="listitem"><div
                  class="para">
						آن‌هایی که این صلاحیت را نادیده می‌گیرند (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>)؛
					</div></li><li
                class="listitem"><div
                  class="para">
						آن‌هایی که یک پیام را به عنوان هشدار امنیتی طبقه‌بندی می‌کنند (<code
                    class="filename">/etc/logcheck/violations.d/</code>)؛
					</div></li><li
                class="listitem"><div
                  class="para">
						آن‌هایی که این طبقه‌بندی را نادیده می‌گیرند (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>)؛
					</div></li><li
                class="listitem"><div
                  class="para">
						در نهایت، آن‌هایی که به پیام‌های باقیمانده اعمال می‌شوند (که به عنوان <span
                    class="emphasis"><em>رویدادهای سیستمی</em></span> شناخته می‌شوند).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>احتیاط</em></span> نادیده گرفتن یک پیام</strong></p></div></div></div><div
              class="para">
				هر پیامی که به عنوان تلاش برای نفوذ یا هشدار امنیتی برچسب‌گذاری شده باشد (همراه با یک قانون موجود در فایل <code
                class="filename">/etc/logcheck/violations.d/myfile</code>) تنها می‌تواند با استفاده از یک قانون در فایل <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> یا <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">extension</em></code> نادیده گرفته شود.
			</div></div><div
            class="para">
				یک رویداد سیستمی همیشه ارسال می‌شود مگر یکی از قوانین موجود در دایرکتوری‌های <code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> بگوید که این رویداد نادیده گرفته شود. البته، تنها دایرکتوری‌هایی به حساب می‌آیند که سطح گزارش برابر یا بیشتر از حالت عملیاتی انتخابی داشته باشند.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.monitoring-activity"></a>14.3.2. فعالیت مانیتورینگ</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.real-time-monitoring"></a>14.3.2.1. در زمان حقیقی</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> یک ابزار تعاملی است که فهرستی از فرآیندهای در حال اجرا را نمایش می‌دهد. مرتب‌سازی پیشفرض آن مبتنی بر میزان استفاده فعلی از پردازنده است که می‌تواند با کلید <span
                class="keycap"><strong>P</strong></span> مشخص گردد. سایر انواع مرتب‌سازی شامل حافظه مصرفی (کلید <span
                class="keycap"><strong>M</strong></span>)، زمان کلی پردازنده (کلید <span
                class="keycap"><strong>T</strong></span>) و شناسه فرآیند (کلید <span
                class="keycap"><strong>N</strong></span>) می‌باشند. کلید <span
                class="keycap"><strong>k</strong></span> اجازه نابودی یک فرآیند با وارد کردن شناسه‌اش را فراهم می‌کند. کلید <span
                class="keycap"><strong>r</strong></span> امکان <span
                class="emphasis"><em>renice</em></span> یک فرآیند را فراهم می‌کند، که همان تغییر اولویت در اجرا است.
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					زمانی که سیستم به نظر سنگین می‌‌آید، <code
                class="command">top</code> ابزار مناسبی برای شناسایی فرآیندهایی است که بیشترین زمان پردازنده یا بیشترین حافظه مصرفی را دارا می‌باشند. به طور مشخص، اغلب بررسی اینکه آیا فرآیندهای موجود با سرویس‌های متناظر در ماشین سازگاری دارند یا خیر کار جالبی است. یک فرآیند ناشناخته که به عنوان کاربر www-data اجرا شده است باید مورد بررسی و تحلیل قرار گیرد، چرا که به احتمال زیاد یک نمونه از نرم‌افزاری است که توسط آسیب‌پذیری موجود در یک برنامه وب نصب شده است.
				</div><div
              class="para">
					<code
                class="command">top</code> ابزار بسیار منعطفی است و صفحه راهنمای آن جزئیات بیشتری را درباره سفارشی‌کردن برای نیازهای خاص کاربر نمایش می‌دهد.
				</div><div
              class="para">
					ابزار گرافیکی <code
                class="command">gnome-system-monitor</code> مشابه با <code
                class="command">top</code> بوده که تقریبا همان ویژگی‌ها را فراهم می‌کند.
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.monitoring-history"></a>14.3.2.2. تاریخچه</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					بار پردازنده، ترافیک شبکه و فضای آزاد دیسک اطلاعاتی هستند که به صورت مداوم در حال تغییر می‌باشند. نگهداری تاریخچه‌ای از میزان مصرف آن‌ها درک خوبی از چگونگی کارکرد رایانه را در اختیار ما قرار می‌دهد.
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					ابزار اختصاصی متفاوتی برای این منظور وجود دارد. اغلب آن‌ها می‌توانند با استفاده از SNMP یا <span
                class="emphasis"><em>Simple Network Management Protocol</em></span> اطلاعات را به صورت مرکزی دریافت کنند. یک مزیت اینکار دریافت داده از عناصر شبکه‌ای است که رایانه‌های همه منظوره به حساب نمی‌آیند، از جمله مسیریاب‌ها یا سوئیچ‌های شبکه.
				</div><div
              class="para">
					این کتاب به Munin و برخی جزئیات آن (<a
                class="xref"
                href="sect.monitoring.html#sect.munin">
      قسمت 12.4.1, “راه‌اندازی Munin”
    </a> را مشاهده کنید) که قسمتی از <a
                class="xref"
                href="advanced-administration.html">
      فصل 12: “<em>مدیریت پیشرفته</em>”</a> است می‌پردازد. دبیان نیز ابزار مشابهی فراهم کرده است، <span
                class="pkg pkg">cacti</span>. توسعه آن پیچیدگی خاص خود را دارد، چرا که به طور انحصاری بر اساس SNMP کار می‌کند. بر خلاف وجود رابط وب، درک مفاهیم موجود در پیکربندی آن به تلاش زیادی نیاز دارد. از این رو مطالعه مستندات آن (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) یک پیشنیاز به حساب می‌آید.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>جایگزین</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (در بسته‌ای با همین نام) ابزاری قدیمی‌تر به حساب می‌آید. بر خلاف برخی جنبه‌های دشوار آن، می‌تواند داده تاریخچه را گردآوری کرده و به صورت نمودار نمایش دهد. این ابزار شامل برخی اسکریپت‌های اختصاصی برای گردآوری متداول‌ترین داده‌های مانیتورینگ از جمله بار پردازنده، ترافیک شبکه، صفحه وب و از این قبیل می‌باشد.
				</div><div
                class="para">
					بسته‌های <span
                  class="pkg pkg">mrtg-contrib</span> و <span
                  class="pkg pkg">mrtgutils</span> شامل نمونه اسکریپت‌هایی هستند که می‌توان بلافاصله از آن‌ها استفاده کرد.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="id-1.17.6.6"></a>14.3.3. تشخیص تغییرات</h3></div></div></div><div
            class="para">
				زمانی که سیستم نصب و پیکربندی می‌شود، با در نظر گرفتن بروزرسانی‌های امنیتی، دلیلی برای تغییر اکثر فایل‌ها و دایرکتوری‌ها، بجز آن‌ها که از نوع داده‌ای هستند، وجود ندارد. پس اطمینان حاصل کردن از اینکه فایل‌ها تغییر نمی‌کنند امری جالب است: هر تغییر ناخواسته باید مورد بررسی و تحقیق قرار بگیرد. این بخش برخی ابزار کاربردی را برای مانیتور کردن فایل‌ها و هشدار به مدیر سیستم در صورت تغییر ناگهانی آن‌ها معرفی می‌کند.
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.dpkg-verify"></a>14.3.3.1. بازرسی بسته‌ها با استفاده از <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مطالعه بیشتر</em></span> محافظت مقابل تغییرات بالادستی</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> در مورد تغییرات انجام شده از یک بسته دبیان کاربرد دارد، اما اگر خود بسته مورد نفوذ گرفته باشد کاربردی ندارد، برای نمونه در حالتی که mirror دبیان ایمن نباشد. محافظت مقابل این کلاس از حملات شامل سیستم تایید امضای دیجیتال APT (<a
                  class="xref"
                  href="sect.package-authentication.html">
      قسمت 6.5, “بررسی صحت بسته‌ها”
    </a> را مشاهده کنید) می‌شود، که اینکار تنها بسته‌های قابل اعتماد را نصب خواهد کرد.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> یا <code
                class="command">dpkg -V</code> ابزار جالبی است چرا که امکان جستجوی فایل‌های تغییر یافته از زمان نصب را فراهم می‌کند (که احتمالا توسط مهاجم تغییر یافته‌اند) اما اینکار باید با احتیاط بیشتری صورت پذیرد. برای اینکه بتواند کار خود را انجام دهد نیازمند checksum ذخیره‌سازی شده در پایگاه‌داده dpkg روی هارد دیسک می‌باشد (این فایل‌ها می‌توانند در <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code> پیدا شوند)؛ یک مهاجم بالقوه با بروزرسانی این فایل‌ها از تشخیص فایل‌های تغییر یافته جلوگیری بعمل می‌آورد.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>بازگشت به مقدمات</em></span> اثرانگشت فایل</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					به عنوان یادآوری: یک اثرانگشت شامل مقدار عددی (معمولا به صورت هگزادسیمال) است که شامل نوعی امضا برای محتویات فایل می‌باشد. این امضا توسط یک الگوریتم (از جمله MD5 یا SHA1 که شناخته شده‌اند) محاسبه می‌شود که تضمین می‌کند کوچک‌ترین تغییر در محتویات فایل موجب تغییر اثرانگشت می‌شود؛ این عمل بنام “avalanche effect” شناخته می‌شود. اینکار باعث می‌شود که یک اثرانگشت ساده به عنوان شیوه‌ای برای آزمون صحت محتویات فایل استفاده شود. این الگوریتم‌ها قابل بازگشت نیستند؛ به عبارت دیگر، برای اغلب آن‌ها، دانستن یک اثرانگشت امکان محتوای متناظر با آن را فراهم نمی‌کند. پیشرفت‌های اخیر که در علوم ریاضی بدست آمده است بنظر می‌رسد که قاطعیت این اصول را کاهش داده است، اما کارکرد آن‌ها زیر سوال نرفته است، چرا که تولید محتوای متفاوت که اثرانگشت یکسانی داشته باشند همچنان کار بسیار دشواری است.
				</div></div><div
              class="para">
					اجرای <code
                class="command">dpkg -V</code> تمام بسته‌های نصب شده را مورد بررسی قرار داده و به ازای هر کدام که در این آزمون شکست بخورند در خط جداگانه‌ای نمایش داده می‌شود. قالب خروجی مشابه با <code
                class="command">rpm -V</code> است که در آن هر کاراکتر بیانگر یک آزمون روی اطلاعات جانبی بسته است. متاسفانه <code
                class="command">dpkg</code> اطلاعات جانبی مورد نیاز بسته را ذخیره‌سازی نمی‌کند و آن‌ها را به صورت علامت سوال در خروجی نمایش می‌دهد. در حال حاضر تنها آزمون checksum منجر به تولید "5" در سومین کاراکتر آن (زمانی که شکست بخورد) می‌شود.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					در نمونه بالا، dpkg یک تغییر در فایل سرویس SSH را گزارش می‌دهد که مدیر سیستم در مورد فایل بسته اعمال کرده است بجای تغییر در فایل پیکربندی آن واقع در <code
                class="filename">/etc/systemd/system/ssh.service</code> (که مانند هر فایل پیکربندی دیگر در <code
                class="filename">/etc</code> ذخیره‌سازی می‌شود). همچنین فهرستی از فایل‌های پیکربندی دیگر که به صورت قانونی تغییر یافته‌اند را با حرف "c" در فیلد دوم نمایش می‌دهد.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.debsums"></a>14.3.3.2. بازرسی بسته‌ها: <code
                      class="command">debsums</code> و محدودیت‌های آن</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> جد <code
                class="command">dpkg -V</code> به حساب می‌آید و از این رو منسوخ شده است. از همان محدودیت‌های dpkg نیز رنج می‌برد. خوشبختانه می‌توان به برخی محدودیت‌های آن غلبه کرد، با اینکه dpkg راهکاری برای آن‌ها ندارد.
				</div><div
              class="para">
					از آنجا که نمی‌توان به داده روی دیسک اعتماد کرد، <code
                class="command">debsums</code> پیشنهاد می‌کند که بجای پایگاه‌داده dpkg از فایل‌های <code
                class="filename">.deb</code> به منظور آزمون استفاده شود. برای دانلود فایل‌های <code
                class="filename">.deb</code> بسته‌های نصب شده، می‌توان روی مکانیزم احرازهویت APT حساب باز کرد. این عملیات می‌تواند کند و خسته‌کننده باشد، پس نباید به عنوان تکنیکی موثر به صورت روزانه مورد استفاده قرار گیرد.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					به یاد داشته باشید که در این مثال از دستور <code
                class="command">grep-status</code> واقع در بسته <span
                class="pkg pkg">dctrl-tools</span> استفاده شده است، که به صورت پیشفرض نصب نمی‌باشد.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="id-1.17.6.6.5"></a>14.3.3.3. مانیتورینگ فایل‌ها: AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					ابزار AIDE یا <span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span> امکان بررسی جامعیت فایل را فراهم می‌کند و هرگونه تغییر مقابل image نسخه پیشین از سیستم معتبر را تشخیص می‌دهد. این image به عنوان یک پایگاه‌داده ذخیره‌سازی می‌شود (<code
                class="filename">/var/lib/aide/aide.db</code>) که شامل اطلاعات مرتبط درباره تمام فایل‌های سیستم است (اثرانگشت‌ّها، مجوزها، بازه‌های زمانی و از این قبیل). این پایگاه‌داده ابتدا توسط <code
                class="command">aideinit</code> راه‌اندازی می‌شود؛ سپس به صورت روزانه توسط اسکریپت <code
                class="filename">/etc/cron.daily/aide</code> به منظور بررسی برای عدم تغییر فایل‌های مرتبط استفاده می‌گردد. زمانی که تغییر تشخیص داده شود، AIDE آن‌ها را در فایل‌های گزارش (<code
                class="filename">/var/log/aide/*.log</code>) ثبت کرده و مشاهدات خود ار از طریق ایمیل برای مدیر سیستم ارسال می‌کند.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>در عمل</em></span> محافظت از پایگاه‌داده</strong></p></div></div></div><div
                class="para">
					از آنجا که AIDE از یک پایگاه‌داده محلی برای مقایسه حالت‌های یک فایل استفاده می‌کند، اعتبار نتایج آن به طور مستقیم در گرو اعتبار پایگاه‌داده می‌باشد. اگر مهاجم بتواند مجوز root سیستم نفوذ شده را کسب نماید، می‌تواند پایگاه‌داده را جایگزین کرده و رد خود را از بین ببرد. یک راهکار احتمالی ذخیره‌سازی داده مرجع در یک رسانه فقط-خواندنی است.
				</div></div><div
              class="para">
					گزینه‌های بسیاری در <code
                class="filename">/etc/default/aide</code> وجود دارد که می‌تواند برای تغییر عملکرد بسته <span
                class="pkg pkg">aide</span> مورد استفاده قرار گیرد. فایل‌های پیکربندی AIDE در <code
                class="filename">/etc/aide/aide.conf</code> و <code
                class="filename">/etc/aide/aide.conf.d/</code> ذخیره‌سازی شده‌اند (در حقیقت، این فایل‌ها تنها توسط <code
                class="command">update-aide.conf</code> برای تولید <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code> مورد استفاده قرار می‌گیرند). پیکربندی شامل ویژگی‌های خاص هر فایل می‌باشد که باید مورد بررسی قرار گیرند. برای نمونه، محتوای فایل‌های گزارش به صورت مداوم تغییر می‌یابد و اینگونه تغییرات مادامی که مجوزهای این فایل‌ها تغییر نکند می‌توانند نادیده گرفته شوند، اما هر دو محتوا و مجوزهای برنامه‌های اجرایی باید ثابت باقی بمانند. با اینکه ساختار پیچیده‌ای ندارد، شیوه نگارش پیکربندی آن نیز ساده نیست و مطالعه صفحه راهنمای <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> توصیه می‌گردد.
				</div><div
              class="para">
					یک نسخه جدید از پایگاه‌داده به صورت روزانه در <code
                class="filename">/var/lib/aide/aide.db.new</code> تولید می‌شود؛ اگر تمام تغییرات ثبت شده قانونی باشند، می‌تواند جایگزین پایگاه‌داده مرجع شود.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>جایگزین</em></span> Tripwire و Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire بسیار مشابه با AIDE عمل می‌کند؛ حتی شیوه نگارش فایل پیکربندی آن نیز تقریبا یکسان است. قابلیت اضافه‌ای که در <span
                  class="pkg pkg">tripwire</span> وجود دارد مکانیزم امضای فایل پیکربندی است، تا یک مهاجم نتواند آن را به نسخه‌ای دیگر از پایگاه‌داده مرجع اشاره دهد.
				</div><div
                class="para">
					Samhain نیز برخی ویژگی‌های مشابه را فراهم می‌کند، همراه با برخی توابع که می‌توانند در تشخیص rootkitها یاری رسانند (قسمت <a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"><span
                    class="emphasis"><em>نگاه سریع</em></span> بسته‌های <span
                    class="pkg pkg">checksecurity</span> و <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span></a> را مشاهده کنید). همچنین می‌تواند به صورت سراسری روی شبکه توزیع گردد و مشاهدات خود را در یک سرور مرکزی ذخیره‌سازی نماید (همراه با یک امضا).
				</div></div><div
              class="sidebar"><a
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>نگاه سریع</em></span> بسته‌های <span
                          class="pkg pkg">checksecurity</span> و <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span></strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					اولین بسته شامل چندین اسکریپت کوچک است که با بررسی سیستم (گذرواژه‌های خالی، فایل‌های جدید setuid و از این قبیل) در زمان مناسب به مدیر سیستم هشدار می‌دهد. بر خلاف نام آن، مدیر سیستم نباید برای ایمنی سیستم لینوکس تنها به این بسته متکی باشد.
				</div><div
                class="para">
					بسته‌های <span
                  class="pkg pkg">chkrootkit</span> و <span
                  class="pkg pkg">rkhunter</span> امکان بررسی <span
                  class="emphasis"><em>rootkit</em></span> احتمالی نصب شده روی سیستم را می‌دهند. به عنوان یادآوری، این‌ها برنامه‌هایی هستند که با مخفی نگاه داشتن حضور خود از دید سیستم نسبت به کنترل کامل ماشین اقدام می‌کنند. این آزمون‌ها ۱۰۰٪ قابل اطمینان نبوده ولی نقطه شروع مناسبی برای کاوش بین مشکلات احتمالی را برای مدیر سیستم نشان می‌دهند.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.intrusion-detection"></a>14.3.4. تشخیص نفوذ (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>بازگشت به مقدمات</em></span> Denial of Service</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				یک حمله “Denial of Service” تنها یک هدف دارد: خارج کردن یک سرویس از دسترسی. خواه این حمله با بارگذاری پرس و جوهای سنگین روی سرور یا آسیب‌پذیری یک باگ صورت گیرد، نتیجه یکسان خواهد بود: سرویس دیگر عملیاتی نخواهد بود. کاربران عادی ناراضی می‌شوند و موجودیتی که از شبکه هدف میزبانی می‌کند اعتبار خود را از دست رفته می‌بیند (و احتمالا سود خود را، در صورتی که یک سایت فروشگاهی آنلاین مد نظر باشد).
			</div><div
              class="para">
				چنین حمله‌ای بعضی وقت‌ها به صورت “distributed” انجام می‌شود؛ اینکار با استفاده از منابع مختلف که پرس و جوهای سنگین را روی سرور بارگذاری می‌کنند انجام شده تا سرور نتواند به پرس و جوهای مجاز پاسخ دهد. این گونه حملات عبارت‌های مترادفی را همراه خود دارند: <acronym
                class="acronym">DDoS</acronym> و <acronym
                class="acronym">DoS</acronym> (بر اساس اینکه حمله به صورت توزیع شده انجام شده است یا خیر).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (در بسته‌ای با همین نام) یک NIDS که مخفف <span
              class="emphasis"><em>Network Intrusion Detection System</em></span> است یا سیستم تشخیص نفوذ شبکه‌ای به حساب می‌آید. وظیفه آن گوش دادن به شبکه و تشخیص تلاش‌های نفوذ احتمالی و/یا اقدامات خرابکارانه است (از جمله حملات DoS). تمام این رویدادها در فایل‌های گوناگون موجود در <code
              class="filename">/var/log/suricata</code> به صورت گزارش ذخیره‌سازی می‌شوند. ابزار شخص ثالث دیگری مانند Kibana یا logstash وجود دارد که برای پیمایش بهتر این داده‌ها بکار می‌روند. <div
              class="url">→ <a
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              class="url">→ <a
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>احتیاط</em></span> محدوده عملیات</strong></p></div></div></div><div
              class="para">
				میزان اثرگذاری <code
                class="command">suricata</code> محدود به ترافیک مشاهده شده در رابط شبکه مانیتورینگ است. اگر نتواند ترافیک واقعی را مشاهده کند نمی‌تواند تشخیص مناسبی را انجام دهد. زمان که به یک سوئیچ شبکه متصل می‌شود، تنها حملاتی را مانیتور می‌کند که یکی از ماشین‌های شبکه را هدف قرار گیرند که این مورد مطلوب نظر نیست. ماشینی که از <code
                class="command">suricata</code> میزبانی می‌کند باید به درگاه “mirror” از سوئیچ متصل شود، که معمولا این درگاه برای تعویض سوئیچ‌ها اختصاص می‌یابد و از این رو می‌تواند تمام ترافیک شبکه را مشاهده کند.
			</div></div><div
            class="para">
				پیکربندی suricata شامل بازبینی و ویرایش فایل <code
              class="filename">/etc/suricata/suricata-debian.yaml</code> است، که بسیار طولانی بوده و هر پارامتر آن به صورت مفصل توضیح داده شده است. یک پیکربندی حداقلی نیازمند محدوده نشانی‌هایی است که شبکه محلی آن‌ها را پوشش می‌دهد (پارامتر <code
              class="literal">HOME_NET</code>). در عمل، این به معنی مجموعه اهداف قابل حمله است. اما استفاده از آن نیازمند درک کامل ویژگی‌ها و منطبق ساختن با وضعیت محلی است.
			</div><div
            class="para">
				قبل از آن، باید فایل <code
              class="filename">/etc/default/suricata</code> را برای تعریف رابط شبکه به منظور مانیتورینگ ویرایش کرده و اسکریپت راه‌اندازی آن را فعال کنید (با تنظیم <code
              class="literal">RUN=yes</code>). البته شاید بخواهید <code
              class="literal">LISTENMODE=pcap</code> را انجام دهید چرا که تنظیم پیشفرض <code
              class="literal">LISTENMODE=nfqueue</code> نیازمند پیکربندی پیچیده‌تری است (فایروال netfilter باید طوری پیکربندی شود که بسته‌های فضای کاربر از طرف suricata و با استفاده از <code
              class="literal">NFQUEUE</code> مدیریت شوند).
			</div><div
            class="para">
				برای تشخیص عملکرد بد، <code
              class="command">suricata</code> نیازمند مجموعه‌ای از قوانین مانیتورینگ است: چنین قوانینی را می‌توانید در بسته <span
              class="pkg pkg">snort-rules-default</span> پیدا کنید. <code
              class="command">snort</code> مرجع تاریخی در اکوسیستم IDS به حساب می‌آید و <code
              class="command">suricata</code> می‌تواند از قوانین موجود آن استفاده کند. متاسفانه این بسته در نسخه <span
              class="distribution distribution">Jessie</span> از دبیان وجود نداشته و باید از طریق انتشار <span
              class="distribution distribution">Testing</span> یا <span
              class="distribution distribution">Unstable</span> بدست آید.
			</div><div
            class="para">
				به صورت جایگزین از <code
              class="command">oinkmaster</code> (در بسته‌ای با همین نام) می‌توان برای دانلود مجموعه قوانین Snort از منابع خارجی استفاده کرد.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>مطالعه بیشتر</em></span> یکپارچگی با <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude امکان مانیتورینگ مرکزی از اطلاعات امنیتی را بوجود می‌آورد. معماری ماژولار آن شامل یک سرور (<span
                class="emphasis"><em>manager</em></span> در بسته <span
                class="pkg pkg">prelude-manager</span>) است که هشدارهای تولید شده توسط <span
                class="emphasis"><em>سنسورهای</em></span> گوناگون را دریافت می‌کند.
			</div><div
              class="para">
				Suricata می‌تواند به عنوان چنین سنسوری پیکربندی شود. سایر احتمالات شامل <span
                class="emphasis"><em>prelude-lml</em></span> (یا <span
                class="emphasis"><em>Log Monitor Lackey</em></span>) می‌شود که می‌تواند فایل‌های گزارش را مانیتور کند (به شیوه‌ای مشابه با <code
                class="command">logcheck</code> که در قسمت <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">
      قسمت 14.3.1, “مانیتورینگ گزارش‌ها با استفاده از <code
                  class="command">logcheck</code>”
    </a> توضیح داده شده است).
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>قبلی</strong>14.2. فایروال یا فیلترینگ بسته</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>بعدی</strong>14.4. مقدمه‌ای بر AppArmor</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.supervision.html">ar-MA</a></li><li><a
              href="../da-DK/sect.supervision.html">da-DK</a></li><li><a
              href="../de-DE/sect.supervision.html">de-DE</a></li><li><a
              href="../el-GR/sect.supervision.html">el-GR</a></li><li><a
              href="../en-US/sect.supervision.html">en-US</a></li><li><a
              href="../es-ES/sect.supervision.html">es-ES</a></li><li><a
              href="../fa-IR/sect.supervision.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.supervision.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.supervision.html">hr-HR</a></li><li><a
              href="../id-ID/sect.supervision.html">id-ID</a></li><li><a
              href="../it-IT/sect.supervision.html">it-IT</a></li><li><a
              href="../ja-JP/sect.supervision.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.supervision.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.supervision.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.supervision.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.supervision.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.supervision.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.supervision.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.supervision.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.supervision.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.supervision.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.supervision.html">zh-TW</a></li></ul></div></body></html>
