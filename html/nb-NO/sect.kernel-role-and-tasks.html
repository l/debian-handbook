<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Noen oppgaver som håndteres av kjernen</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-nb-NO-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kjerne, Unix, Prosess, Hierarki, Grunnleggende kommandoer" /><link
        rel="home"
        href="index.html"
        title="Håndbok for Debian-administratoren" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Tillegg B. Kort støttekurs" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Datamaskinens indre arbeid: de forskjellige involverte lagene" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. Brukerrommet" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/nb-NO/sect.kernel-role-and-tasks.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Forrige</strong></a></li><li
          class="home">Håndbok for Debian-administratoren</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Neste</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Noen oppgaver som håndteres av kjernen</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Å drifte maskinvaren</h3></div></div></div><div
            class="para">
				Kjernen har først og fremst som oppgave å kontrollere maskinvaretilbehøret, oppdage det, slå det på når datamaskinen blir slått på, og så videre. Det gjør dem også tilgjengelige på et høyere nivå programvare med et forenklet programmeringsgrensesnitt, slik at programmene kan dra nytte av enheter uten å måtte bekymre seg om detaljer, slik som hvilken kortplass det valgte kortet er satt inn i. Programgrensesnittet gir også et abstraksjonslag; det tillater for eksempel at programvare for videokonferanser kan bruke et nettkamera uavhengig av merke og modell. Programvaren kan bare bruke grensesnittet <span
              class="emphasis"><em>Video for Linux</em></span> (V4L), og kjernen oversetter funksjonspåkallingene i dette grensesnittet til de aktuelle maskinvarekommandoene som trengs når nettkameraet brukes.
			</div><div
            class="para">
				<a
              id="id-1.21.7.2.3.1"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.2"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.3"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.4"
              class="indexterm"></a> Kjernen eksporterer mange detaljer om programvare den finner med <code
              class="filename">/proc/</code> og <code
              class="filename">/sys/</code>-virtuelle filsystemer. Flere verktøy oppsummerer disse detaljene. Blant dem,<code
              class="command">lspci</code> (i <span
              class="pkg pkg">pciutils</span> -pakken) lister PCI-enheter, <code
              class="command">lsusb</code> (i <span
              class="pkg pkg">usbutils</span>-pakke) lister USB-enheter, og <code
              class="command">lspcmcia</code> (i <span
              class="pkg pkg">pcmciautils</span>-pakken) lister PCMCIA-kort. Disse verktøyene er meget nyttige til å identifisere den eksakte modellen for enheten. Denne identifikasjonen gir også mer presise søk på nettet, noe som i sin tur fører til mer relevant dokumentasjon.
			</div><div
            class="example"><a
              id="id-1.21.7.2.4"></a><p
              class="title"><strong>Eksempel B.1. Eksempel på informasjon fra <code
                  class="command">lspci</code> og <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Disse programmene har et <code
              class="literal">-v</code>-valg som lister mye mer detaljert (men vanligvis ikke nødvendig) informasjon. Til slutt¸ <code
              class="command">lsdev</code>-kommandoen (i <span
              class="pkg pkg">procinfo</span>-pakken) lister kommunikasjonsressurser som enhetene bruker.
			</div><div
            class="para">
				Programmer kobler seg ofte til enheter ved hjelp av spesielle filer som er opprettet innenfor <code
              class="filename">/dev/</code> (se sidestolpe <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>DET GRUNNLEGGENDE</em></span> Tilgangstillatelser for enheter</a>). Dette er spesielle filer som representerer platelager (for eksempel, <code
              class="filename">/dev/hda</code> og <code
              class="filename">/dev/sdc</code>), partisjoner (<code
              class="filename">/dev/hda1</code> eller <code
              class="filename">/dev/sdc3</code>), mus (<code
              class="filename">/dev/input/mouse0</code>), tastatur (<code
              class="filename">/dev/input/event0</code>), lydkort (<code
              class="filename">/dev/snd/*</code>), serieporter (<code
              class="filename">/dev/ttyS*</code>), og så videre.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Filsystemer</h3></div></div></div><a
            id="id-1.21.7.3.2"
            class="indexterm"></a><a
            id="id-1.21.7.3.3"
            class="indexterm"></a><div
            class="para">
				Filsystemer er en av kjernens mest fremtredende aspekter. Unix-systemer fletter alle fillagre inn i et enkelt hierarki, som gir brukere (og programmer) tilgang til data ved å kjenne til plasseringen i det hierarkiet.
			</div><div
            class="para">
				Startpunktet til dette hierarkiske treet kalles roten, <code
              class="filename">/</code>. Denne katalogen kan inneholde navngitte underkataloger. For eksempel, <code
              class="literal">home</code>-underkatalog i <code
              class="filename">/</code> kalles <code
              class="filename">/home/</code>. Denne underkatalogen kan i sin tur inneholde andre underkataloger, og så videre. Hver katalog kan også inneholde filer, hvor de faktiske dataene blir lagret. Dermed refererer <code
              class="filename">/home/rmas/Desktop/hello.txt</code>-navnet til en fil med navnet <code
              class="literal">hello.txt</code> lagret i <code
              class="literal">Desktop</code>-underkatalog i <code
              class="literal">rmas</code>-underkatalogen i <code
              class="literal">home</code>-katalogen i roten. Kjernen oversetter mellom dette navnesystemet og den faktiske, fysiske lagring på en disk.
			</div><div
            class="para">
				I motsetning til andre systemer, er det bare ett slikt hierarki, og det kan integrere data fra flere disker. En av disse diskene anvendes som referanse, og de andre er «montert» på kataloger i hierarkiet (Unix-kommandoen er kalt <code
              class="command">mount</code>); disse andre diskene er deretter tilgjengelige under disse «monteringspunktene». Dette tillater lagring av brukernes hjemmeområder (tradisjonelt lagret i <code
              class="filename">/home/</code>) på en annen harddisk, som da vil inneholde <code
              class="literal">rhertzog</code> og <code
              class="literal">rmas</code>-katalogene. Så snart disken er montert på <code
              class="filename">/home/</code>, blir disse katalogene tilgjengelige på sine vanlige steder, og stier som <code
              class="filename">/home/rmas/Desktop/hello.txt</code> fortsetter å virke.
			</div><a
            id="id-1.21.7.3.7"
            class="indexterm"></a><div
            class="para">
				Det er mange filsystemformater, og tilsvarende mange måter å lagre data fysisk på disker. De mest kjente er <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> og <span
              class="emphasis"><em>ext4</em></span>, men også andre finnes. For eksempel er <span
              class="emphasis"><em>vfat</em></span> det systemet som historisk ble brukt av DOS og Windows-operativsystemer, som gjør det mulig å bruke harddisker under Debian så vel som under Windows. I alle fall må et filsystem være forberedt på en disk før den kan monteres, og denne operasjonen er kjent som «formatering». Kommandoer som <code
              class="command">mkfs.ext3</code> (der <code
              class="command">mkfs</code> står for <span
              class="emphasis"><em>MaKe FileSystem</em></span>) formatteringsbehandling. Disse kommandoer krever, som et parameter, en enhetsfil som representerer den partisjonen som skal formateres (f.eks <code
              class="filename">/dev/sda1</code>). Denne operasjonen er destruktiv, og bør bare kjøres en gang, bortsett fra hvis man bevisst ønsker å stryke ut et filsystem og starte på nytt.
			</div><div
            class="para">
				Det er også filsystemer i nettverk, slik som <acronym
              class="acronym">NFS</acronym>, der data ikke er lagret på en lokal disk. I stedet overføres data via nettverket til en tjener som lagrer og henter dem ved behov. Filsystemets atskillelse skjermer brukere fra å være bekymret: filer forblir tilgjengelige på sin vanlige hierarkiske måte.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Delte funksjoner</h3></div></div></div><div
            class="para">
				Siden en rekke av de samme funksjonene brukes av all programvare, er det fornuftig å sentralisere dem i kjernen. For eksempel tillater et delt filsystem at et hvilket som helst program bare kan åpne en fil etter navn, uten å trenger å bekymre seg om hvor filen er lagret fysisk. Filen kan lagres i flere forskjellige disker på en harddisk, eller delt over flere harddisker, eller til og med lagret på en ekstern filtjener. Delte kommunikasjonsfunksjoner blir brukt av programmer til å utveksle data uavhengig av måten dataene transporteres. For eksempel kan transport være over hvilken som helst kombinasjon av lokale eller trådløse nettverk, eller over en fasttelefon.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Å håndtere prosesser</h3></div></div></div><a
            id="id-1.21.7.5.2"
            class="indexterm"></a><div
            class="para">
				En prosess er en kjørende forekomst av et program. Dette krever minne til å lagre både selve programmet og dets driftsdata. Kjernen er ansvarlig for å opprette og spore dem. Når et program kjøres, setter kjernen først av litt minne, deretter laster den kjørbar kode fra filsystemet inn i det, og starter så å kjøre koden. Den tar vare på informasjon om denne prosessen, i hvilken det mest synlige er et identifikasjonsnummer som kalles <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span>).
			</div><div
            class="para">
				Unix-lignende kjerner (inkludert Linux), som de fleste andre moderne operativsystemer, er i stand til «fleroppgavekjøring». Med andre ord, de kan kjøre mange prosesser «samtidig». Det er faktisk bare en kjørende prosess til enhver tid, men kjernen forkorter tiden i små deler, og kjører hver prosess etter tur. Siden disse tidssnittene er meget korte (i millisekund-området), skaper de en illusjon av prosesser som kjører i parallell, selv om de faktisk bare er aktive i noen tidsintervall, og i tomgang resten av tiden. Kjernens jobb er å justere sine planleggingsmekanismer for å holde på denne illusjonen, og samtidig maksimere den globale systemytelsen. Dersom tidsintervallene er for lange, kan programmet ikke fremstå som så responsivt som ønskelig. For kort, og systemet mister tid på grunn av hyppig veksling mellom oppgaver. Disse beslutningene kan bli forskjøvet med prosessprioriteringer. Høyt prioriterte prosesser vil kjøre lenger, og med mer hyppige tidsintervaller enn lavt prioriterte prosesser.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTE</em></span> Flerprosessorsystemer (og varianter)</strong></p></div></div></div><div
              class="para">
				Begrensningen beskrevet ovenfor, at bare én prosess kan kjøre på ett tidspunkt, gjelder ikke alltid. Selve begrensningen er at det bare kan være en kjørende prosess <span
                class="emphasis"><em>per prosessorkjerne</em></span> om gangen. Multiprosessor, multikjerne eller «hypertrådede» systemer tillater at flere prosesser kjører parallelt. Systemet med fleroppgavekjøring er fortsatt i bruk, slik som å håndtere tilfeller der det er flere aktive prosesser enn tilgjengelige prosessorkjerner. Dette er langt fra uvanlig. Et grunnleggende system, selv et stort sett inaktivt et, har nesten alltid et titalls prosesser som kjører.
			</div></div><div
            class="para">
				Selvfølgelig tillater kjernen å kjøre flere uavhengige prosesser med det samme programmet. Men hver kan bare få tilgang til sine egne tidsperioder og sitt eget minne. Deres data forblir dermed forbli uavhengig.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Å håndtere rettigheter</h3></div></div></div><div
            class="para">
				Unix-lignende systemer er også flerbrukere. De gir et rettighetsforvaltningssystem som støtter egne brukere og grupper; det gir også kontroll over handlinger basert på tillatelser. Kjernen forvalter data for hver prosess, som tillater å kontrollere tillatelser. Mesteparten av tiden er en prosess identifisert med brukeren som startet den. Den prosessen er kun tillatt å gjøre det som er tilgjengelig for brukeren. For eksempel for å prøve å åpne en fil kreves det at kjernen kontrollerer prosessens identitet mot adgangstillatelser (for mer informasjon om dette eksempelet, se <a
              class="xref"
              href="sect.rights-management.html">Seksjon 9.3, «Å håndtere rettigheter»</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Forrige</strong>B.3. Datamaskinens indre arbeid: de forskjellige ...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Opp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hjem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Neste</strong>B.5. Brukerrommet</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.kernel-role-and-tasks.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.kernel-role-and-tasks.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.kernel-role-and-tasks.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.kernel-role-and-tasks.html">zh-TW</a></li></ul></div></body></html>
