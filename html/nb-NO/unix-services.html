<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Kapittel 9. Unix-tjenester</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-nb-NO-1.0-1" /><meta
        name="keywords"
        content="Systemoppstart, Initskript, SSH, Telnet, Rettigheter, Tillatelser, Overvåking, Inetd, Cron, Sikkerhetskopiering, Hot-plugging, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Håndbok for Debian-administratoren" /><link
        rel="up"
        href="index.html"
        title="Håndbok for Debian-administratoren" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Å installere en kjerne" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Ekstern innlogging" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/nb-NO/unix-services.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Forrige</strong></a></li><li
          class="home">Håndbok for Debian-administratoren</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Neste</strong></a></li></ul><div
        xml:lang="nb-NO"
        class="chapter"
        lang="nb-NO"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>Kapittel 9. Unix-tjenester</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Systemoppstart</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Ekstern innlogging</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Sikker ekstern innlogging: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Å bruke eksterne grafiske skrivebord</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Å håndtere rettigheter</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Administrasjonsgrensesnitt</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Å administrere med et nettbrukergrensesnitt: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Konfigurering av pakker: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Systemhendelser</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Prinsipp og mekanisme</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Konfigurasjonsfilen</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Super-server <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Planlegge oppgaver i tide med <code
                    class="command">cron</code> og <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Format til en <code
                        class="filename">crontab</code>-fil</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Å bruke <code
                        class="command">at</code>-kommandoen</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Å planlegge asynkrone oppgaver: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Kvoter (Quotas)</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Sikkerhetskopiering</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Sikkerhetskopiering med <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Å gjenopprette maskiner uten sikkerhetskopier</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Varm tilkobling: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introduksjon</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. Navneproblemet</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Hvordan <span
                        class="emphasis"><em>udev</em></span> virker</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Et konkret eksempel</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Strømstyring: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Dette kapitlet dekker en rekke grunnleggende tjenester felles for mange Unix-systemer. Alle administratorer bør være kjent med dem.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. Systemoppstart</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Når du starter datamaskinen, vises mange meldinger på konsollskjermen at mange automatiske initialiseringer og konfigurasjoner blir utført. Noen ganger kan du ønske å endre litt på hvordan dette stadiet fungerer, noe som betyr at du må forstå det godt. Det er hensikten med denne seksjonen.
		</div><div
            class="para">
			Først tar BIOS kontroll over datamaskinen, registrerer diskene, laster<span
              class="emphasis"><em>Master Boot Record</em></span>, og starter oppstartslasteren. Oppstartslasteren tar over, finner kjernen på disken, laster og kjører den. Kjernen blir så initialisert, og begynner å søke etter, og montere partisjonen som inneholder rotfilsystemet, og til slutt utfører det første programmet - <code
              class="command">init</code>. Ofte er, faktisk, denne «rotpartisjonen» og denne <code
              class="command">init</code> plassert i et virtuelt filsystem som bare finnes i RAM (derav navnet, «initramfs», tidligere kalt «initrd» for «initialisering RAM disk»). Dette filsystem er lastet inn i minnet av oppstartslasteren, ofte fra en fil på en harddisk, eller fra nettverket. Den inneholder bare et minimum som kreves av kjernen for å laste det «sanne» rotfilsystemet: Dette kan være drivermoduler for harddisken, eller andre enheter uten noe som systemet ikke kan starte opp, eller oftere, initialiseringsskript og moduler for montering av RAID matriser, åpne krypterte partisjoner, for å aktivere LVM, etc. Når rotpartisjonen er montert, overlater initramfs kontrollen til den virkelige init-en, og maskinen går tilbake til standard oppstartsprosess.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Oppstartssekvens med en datamaskin som kjører Linux med systemd" /></div></div><p
              class="title"><strong>Figur 9.1. Oppstartssekvens med en datamaskin som kjører Linux med systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. Systemd init system</h3></div></div></div><div
              class="para">
				Den «ekte init» blir nå levert av <span
                class="pkg pkg">systemd</span>, og denne seksjonen dokumenter dette init-systemet.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KULTUR</em></span> før <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> er et relativt nytt «init system», og selv om det allerede er tilgjengelig, til en viss grad, i <span
                  class="distribution distribution">Wheezy</span>, er det bare blitt standard i Debian <span
                  class="distribution distribution">Jessie</span>. Tidligere versjoner bygger, som standard, på «System V init» (i <span
                  class="pkg pkg">sysv-rc</span>-pakken), et mye mer tradisjonelt system. Vi beskriver System V init senere.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIV</em></span> Andre systemer for oppstart</strong></p></div></div></div><div
                class="para">
				Denne boken beskriver oppstartssystemet som brukes som standard i Debian <span
                  class="distribution distribution">Jessie</span> (som implementert av <span
                  class="pkg pkg">systemd</span>-pakken), så vel som den tidligere standarden, <span
                  class="pkg pkg">sysvinit</span>, som er avledet og arvet fra <span
                  class="emphasis"><em>System V</em></span> Unix-systemer; det er andre.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> er et oppstartssystem med en veldig enkel prosess. Det holder prinsippet om kjørenivå, men erstatter mapper og symbolske lenker med en konfigurasjonsfil, som viser til <code
                  class="command">init</code> - prosessene som må startes, og lanseringsrekkefølgen deres.
			</div><div
                class="para">
				<code
                  class="command">upstart</code>-systemet er fortsatt ikke testet helt ut på Debian. Det er hendelsesbasert: init-skripter utføres ikke lenger i en sekvensiell rekkefølge, men som respons til hendelser som for eksempel fullføring av et annet skript som de er avhengige av. Dette systemet, startet av Ubuntu, er med i Debian <span
                  class="distribution distribution">Jessie</span>, men er ikke i standarden. Det kommer faktisk som en erstatning for <span
                  class="pkg pkg">sysvinit</span>, og en av oppgavene kjørt av <code
                  class="command">upstart</code> er å kjøre de prosedyrer som er skrevet for tradisjonelle systemer, spesielt de fra <span
                  class="pkg pkg">sysv-rc</span>-pakken.
			</div><div
                class="para">
				Det er også andre systemer og andre driftsmodi, for eksempel <code
                  class="command">runit</code> eller <code
                  class="command">minit</code>, men de er relativt spesialiserte, og ikke utbredt.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPESIFIKK SAK</em></span> Oppstart fra nettverket</strong></p></div></div></div><div
                class="para">
				I noen konfigurasjoner kan BIOS bli konfigurert til ikke å utføre MBR, men å søke tilsvarende i nettverket, noe som gjør det mulig å bygge datamaskiner uten en harddisk, eller som blir helt reinstallert ved hver oppstart. Dette alternativet er ikke tilgjengelig for alle maskinvarer, og det krever vanligvis en egnet kombinasjon av BIOS og nettverkskort.
			</div><div
                class="para">
				Oppstart fra nettverket kan bli brukt til å kjøre <code
                  class="command">debian-installer</code> eller FAI (se <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Seksjon 4.1, «Installasjonsmetoder»</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DET GRUNNLEGGENDE</em></span> Prosessen, et programeksempel</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				En prosess er representasjonen av et program som kjører i minnet. Det inkluderer all informasjon som er nødvendig for en forsvarlig kjøring av programvaren (selve koden, men også dataene som den har i minnet, en liste over filer som den har åpnet, nettverksforbindelsene den har etablert, etc.). Et enkelt program kan startes opp i flere prosesser, som ikke nødvendigvis kjører under forskjellige bruker-ID-er.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SIKKERHET</em></span> Bruke skall som <code
                          class="command">init</code> for å få rotrettigheter</strong></p></div></div></div><div
                class="para">
				Av tradisjon; den første prosessen som starter er <code
                  class="command">init</code>-programmet (som er en symbolsk lenke til <code
                  class="filename">/lib/systemd/systemd</code> som standard). Imidlertid er det mulig å sende et <code
                  class="literal">init</code>-valg til kjernen for å indikere et annet program.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Alle som er i stand til å få tilgang til datamaskinen kan trykke på <span
                  class="keycap"><strong>Reset</strong></span>-knappen og restarte den. Så, på oppstartslasterens ledetekst, er det mulig å sende <code
                  class="literal">init=/bin/sh</code>-valget til kjernen for å få rottilgang uten å kjenne administratorens passord.
			</div><div
                class="para">
				For å unngå dette kan du beskytte oppstartslasteren med et passord. Du kan også tenke på å beskytte tilgang til BIOS (en mekanisme for passordbeskyttelse er nesten alltid tilgjengelig). Uten den kan en ondsinnet inntrenger fortsatt starte maskinen med et flyttbart medium som har sitt eget Linux-system, som de deretter kan bruke til å få tilgang til data på datamaskinens harddisker.
			</div><div
                class="para">
				Til slutt, være klar over at de fleste BIOS-er har et generisk passord tilgjengelig. I utgangspunktet er de tenkt for feilsøking for dem som har glemt passordet sitt. Disse passordene er nå offentlige og tilgjengelig på Internett (se selv ved å søke etter «generiske BIOS-passord» i en søkemotor). Alle disse beskyttelsene vil dermed hindre uautorisert tilgang til maskinen, men uten å være i stand til å fullstendig hindre det. Det er ingen pålitelig måte å beskytte en datamaskin på hvis angriperen kan få fysisk tilgang til den; de kan uansett demontere harddisker for å koble dem til en datamaskin under egen kontroll, eller stjele hele maskinen, eller slette BIOS-minnet for å tilbakestille passordet …
			</div></div><div
              class="para">
				Systemd utfører flere prosesser, som har ansvaret for å sette opp systemet: tastatur, drivere, filsystemer, nettverk, tjenester. Den gjør dette mens du holder et overordnet oppsyn på systemet som en helhet, og kravene til komponentene. Hver komponent er beskrevet av en «enhetsfil» («unit file») (noen ganger mer); den generelle syntaksen er avledet fra det mye brukte «* INI-filer» syntaks, med <code
                class="literal"><em
                  class="replaceable">nøkkel</em> = <em
                  class="replaceable">verdi</em></code> par gruppert mellom <code
                class="literal">[<em
                  class="replaceable">seksjon</em>]</code> topptekster. «Unit filer» er lagret under <code
                class="filename">/lib/systemd/system/</code>, og <code
                class="filename">/etc/systemd/system/</code>. De kommer i flere varianter, men her vil vi fokusere på «tjenester» og «mål».
			</div><div
              class="para">
				En systemd «tjenestefil» beskriver en prosess styrt av systemd. Den inneholder omtrent den samme informasjonen som i et gammelt stil init-skript, men uttrykt på en deklaratorisk (og mye mer konsis) måte. Systemd håndterer mesteparten av de repeterende oppgavene (som starter og stopper prosessen, sjekker statusen, loggingen, dropper privilegier, og så videre), og tjenestefilen trenger bare å fylle ut detaljene i prosessen. For eksempel, her er tjenestefilen for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Som du kan se, er det svært lite kode her, bare deklarasjoner. Systemd tar seg av visning av fremdriftsrapporter, holder orden på prosessene, og starter dem selv når det trengs.
			</div><div
              class="para">
				En systemd «målfil» («target file») beskriver et systems tilstand, hvor et sett av tjenester som er kjent for å være operasjonelle. Det kan sees på som å tilsvare det gammeldagse kjørenivået. Ett av målene er <code
                class="literal">local-fs.target</code>; Når det er nådd, kan resten av systemet gå ut fra at alle de lokale filsystemer er montert og tilgjengelige. Andre mål inkluderer <code
                class="literal">network-online.target</code> og <code
                class="literal">sound.target</code>. Avhengigheter for et mål kan enten være oppført i målfilen (i <code
                class="literal">Requires=</code>-linjen), eller man kan bruke en symbolsk fil i <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>-mappen. For eksempel inneholder <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> en link til <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd vil derfor sikre at CUPS kjører, for å nå <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Siden enhetsfiler er deklarative heller enn skripter eller programmer, kan de ikke kjøres direkte, og de blir bare tolket av systemd. Flere verktøy tillater derfor administratoren å samhandle med systemd for å kontrollere tilstanden til systemet, og for hver komponent.
			</div><div
              class="para">
				Det første slikt verktøy er <code
                class="command">systemctl</code>. Kjørt uten argumenter, viser den alle enhetsfiler som er kjent for systemd (bortsett fra de som er blitt deaktivert), samt deres status. <code
                class="command">systemctl status</code> gir en bedre oversikt over tjenestene, samt relaterte prosesser. Hvis navnet på en tjeneste er gitt (som i <code
                class="command">systemctl status ntp.service</code>), returnerer den enda flere detaljer, så vel som de få siste logglinjer knyttet til denne tjenesten (mer om det senere).
			</div><div
              class="para">
				Å starte en tjeneste for hånd er en enkel sak, kjør <code
                class="command">systemctl start <em
                  class="replaceable">tjenestenavn</em>.service</code>. Som man kan gjette seg til, å stoppe tjenesten gjøres med <code
                class="command">systemctl stop <em
                  class="replaceable">tjenestenavn</em>.service</code>. Andre underkommandoer inkluderer <code
                class="command">reload</code> og <code
                class="command">restart</code>.
			</div><div
              class="para">
				For å kontrollere om en tjeneste er aktiv (dvs. om den vil komme i gang automatisk ved oppstart), bruk <code
                class="command">systemctl enable <em
                  class="replaceable">tjenestnavn</em>.service</code> (eller <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> åpner for å sjekke tjenestens status.
			</div><div
              class="para">
				Et interessant trekk ved systemd er at den inneholder en loggingskomponent som heter <code
                class="command">journald</code>. Den kommer som et supplement til mer tradisjonelle loggingsystemer, for eksempel <code
                class="command">syslogd</code>, men den legger til interessante funksjoner som en formell kobling mellom en tjeneste og meldingene den genererer, og evnen til å fange opp feilmeldinger generert fra sin initialiseringsekvens. Meldingene kan vises senere, med litt hjelp fra <code
                class="command">journalctl</code>-kommandoen. Uten noen argumenter, avgir den bare alle loggmeldinger som har oppstått etter oppstart av systemet. Det vil sjelden bli brukt på den måten. Mesteparten av tiden vil den bli brukt med en tjenesteidentifikator:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				En annen nyttig kommandolinjemarkør er <code
                class="command">-f</code>, som instruerer <code
                class="command">journalctl</code> til å fortsette å vise nye meldinger etter hvert som de er sendt ut (mye på samme måte som <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				Hvis en tjeneste ikke ser ut til å virke som forventet, er første skritt for å løse problemet å kontrollere at tjenesten faktisk kjører, med <code
                class="command">systemctl status</code>. Hvis den ikke kjører, og meldingene er gitt av den første kommandoen ikke er nok til å diagnostisere problemet, sjekk loggene samlet av journald om denne tjenesten. For eksempel, anta SSH server ikke virker:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Etter å ha sjekket status på tjenesten (feilet), gikk vi videre til å sjekke loggene. De indikerer en feil i konfigurasjonsfilen. Etter å ha redigert konfigurasjonsfilen og fikset feilen, starter vi tjenesten, og kontroller så at den faktisk kjører.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GÅR VIDERE</em></span> Andre typer enhetsfiler</strong></p></div></div></div><div
                class="para">
				Vi har bare beskrevet det mest grunnleggende av systemd sine muligheter i denne seksjonen. Den tilbyr mange andre interessante funksjoner, og vi vil bare liste noen her:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket aktivering: en «socket» enhetsfil kan brukes til å beskrive et nettverk eller en Unix socket administrert av systemd. Dette betyr at socket-en vil bli opprettet av systemd, og selve tjenesten kan startes etter behov ved et faktisk tilkoblingsforsøk. Dette replikerer omtrent funksjonssettet til <code
                        class="command">inetd</code>. Se <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timere: en «timer»-enhetsfil beskriver hendelser som inntreffer med en fast frekvens eller på bestemte tider. Når en tjeneste er knyttet til en slik timer, vil den tilsvarende oppgaven bli utført når tiden er inne. Dette gjør det mulig å kopiere en del av <code
                        class="command">cron</code>s egenskaper. Se <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						nettverk: et «nettverk»s enhetsfil beskriver et nettverksgrensesnitt som gjør det mulig å konfigurere slike grensesnitt, samt uttrykke at en tjeneste er avhengig av at et bestemt grensesnitt er oppe.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. System V init system</h3></div></div></div><div
              class="para">
				System V init system (som vi kaller init for korthets skyld) utfører flere prosesser, etter anvisning fra <code
                class="filename">/etc/inittab</code>-filen. Det første program som kjøres (som tilsvarer <span
                class="emphasis"><em>sysinit</em></span> trinnet) er <code
                class="command">/etc/init.d/rcS</code>, et skript som kjører alle programene i <code
                class="filename">/etc/rcS.d/</code>-mappen. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Blant disse finner du suksessivt programmer med ansvar for:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						oppsettet av konsollets tastatur;
					</div></li><li
                  class="listitem"><div
                    class="para">
						laste drivere: de fleste av kjernemodulene er lastet av kjernen selv i takt med at maskinvaren blir oppdaget; ekstra drivere blir deretter lastet inn automatisk når de korresponderende modulene er oppført i <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						sjekke integriteten til filsystemene;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montere lokale partisjoner;
					</div></li><li
                  class="listitem"><div
                    class="para">
						sette opp nettverket;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montere nettverk filsystemer (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DET GRUNNLEGGENDE</em></span> Kildemoduler og valgmuligheter</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Kjernemoduler har også valgmuligheter som kan konfigureres ved å sette noen filer i <code
                  class="filename">/etc/modprobe.d/</code>. Disse alternativene er definert med direktiver som dette: <code
                  class="literal">options <em
                    class="replaceable">modulnavn</em> <em
                    class="replaceable">opsjonsnavn</em>=<em
                    class="replaceable">opsjonsverdi</em></code>. Flere alternativer kan spesifiseres med ett eneste direktiv om nødvendig.
			</div><div
                class="para">
				Disse konfigurasjonsfiler er beregnet for <code
                  class="command">modprobe</code> - programmet som laster en kjernemodul med dets avhengigheter (moduler kan faktisk påkalle andre moduler). Dette programmet blir levert av <span
                  class="pkg pkg">kmod</span>-pakken.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Etter dette trinnet tar <code
                class="command">init</code> over, og starter programmene aktivert i standard kjørenivå (som vanligvis er driftsnivå 2). Den utfører <code
                class="command">/etc/init.d/rc 2</code>, et skript som starter alle tjenestene som er oppført i <code
                class="filename">/etc/rc2.d/</code>, og der navnet begynner med bokstaven «S». Det tosifrede nummer som følger, har historisk blitt brukt til å definere i hvilken rekkefølge tjenestene måtte startes, men i dag brukes det standard oppstartssystemet <code
                class="command">insserv</code>, som berammer alt automatisk basert på skriptenes avhengigheter. Hvert oppstartsskript melder om betingelsene som må være oppfylt for å starte eller stoppe tjenesten (for eksempel hvis det må starte før eller etter en annen tjeneste); Så starter <code
                class="command">init</code> dem i den rekkefølgen som oppfyller disse betingelsene. Skriptenes statiske nummerering tas derfor ikke lenger i betraktning (men de må alltid ha et navn som begynner med «S» etterfulgt av to sifre, og selve navnet på skriptet som brukes for avhengighetene. Vanligvis startes basistjenester (for eksempel logger med <code
                class="command">rsyslog</code>, eller tildeling av port med <code
                class="command">portmap</code>) først, fulgt av standardtjenestene og det grafiske brukergrensesnittet (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Dette avhengighetsbaserte oppstartssystemet gjør det mulig å automatisere renummerering, som kan være ganske kjedelig hvis det må gjøres manuelt. Det begrenser risikoen for menneskelige feil, ettersom tidsrekkefølgen blir gjennomført i henhold til de parameterne som er angitt. En annen fordel er at tjenester kan startes parallelt når de er uavhengige av hverandre, noe som kan akselerere oppstartsprosessen.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> skiller mellom ulike kjørenivåer, så det kan bytte fra ett til et annet med <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code>-kommandoen. Umiddelbart vil <code
                class="command">init</code> kjøre <code
                class="command">/etc/init.d/rc</code> igjen med det nye kjørenivået. Dette skriptet vil da starte de manglende tjenestene, og stoppe de som ikke lenger er ønsket. For å gjøre dette viser det til innholdet i <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (der <em
                class="replaceable">X</em> representerer det nye kjørenivået). Skript som begynner med «S» (som i «Start») er tjenester som skal i gang; de som starter med «K» (som i «Kill») er de tjenestene som skal stoppes. Skriptet starter ikke noen tjenester som allerede var aktive med det forrige driftsnivået.
			</div><div
              class="para">
				Som standard bruker System V init i Debian fire forskjellige driftsnivåer:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Nivå 0 brukes bare midlertidig, mens maskinen slår seg av. Dermed inneholder den bare mange «K»-skripter.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivå 1, også kjent som enkeltbrukermodus, tilsvarer systemet i nedgradert modus; det inneholder bare basistjenester, og er beregnet for vedlikeholdsoperasjoner hvor samhandling med vanlige brukere ikke er ønsket.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivå 2 er nivået for normal drift, som omfatter nettverkstjenester, et grafisk grensesnitt, brukerpålogging, etc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivå 6 er lik nivå 0, bortsett fra at det brukes under nedkoblingsfasen før en omstart.
					</div></li></ul></div><div
              class="para">
				Andre nivåer finnes, spesielt 3 til 5. Som standard er de konfigurert til å operere på samme måte som nivå 2, men administratoren kan endre dem (ved å legge til eller slette skript i de tilsvarende <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> kataloger) for å tilpasse dem til spesielle behov.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Oppstartssekvens for en datamaskin som kjører Linux med System V init" /></div></div><p
                class="title"><strong>Figur 9.2. Oppstartssekvens for en datamaskin som kjører Linux med System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Alle skriptene som inngår i de ulike <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>-kataloger er egentlig bare symbolske lenker - opprettet ved pakkeinstallasjon av <code
                class="command">update-rc.d</code>-programmet - som peker til selve skriptet som er lagret i<code
                class="filename">/etc/init.d/</code>. Administratoren kan finjustere tjenestene som er tilgjengelige i hvert kjørenivå ved å kjøre <code
                class="command">update-rc.d</code> igjen med justerte parametre. Manualsiden <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> beskriver syntaksen i detalj. Vær oppmerksom på at å fjerne alle symbolske lenker (med <code
                class="literal">remove</code>-parameteret) ikke er noen god metode for å deaktivere en tjeneste. I stedet bør du bare konfigurere den til ikke å starte i det ønskede kjørenivået (mens man skjermer de samsvarende påkallinger for å stoppe den i det tilfelle tjenesten bruker det forrige kjørenivået. Siden <code
                class="command">update-rc.d</code> har et noe innfløkt grensesnitt, kan du foretrekke å bruke <code
                class="command">rcconf</code> (fra <span
                class="pkg pkg">rcconf</span>-pakken som gir et mer brukervennlig grensesnitt.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> Å restarte tjenester</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Vedlikeholdsskripter for Debian-pakker vil noen ganger restarte visse tjenester for å sikre at de er tilgjengelige, eller få dem til å ta hensyn til visse valgmuligheter. Kommandoen som styrer en tjeneste - <code
                  class="command">tjeneste <em
                    class="replaceable">tjeneste</em> <em
                    class="replaceable">operasjon</em></code> - tar ikke driftsnivå i betraktning, forutsetter (feilaktig) at tjenesten brukes for øyeblikket, og kan dermed iverksette uriktige operasjoner (starter en tjeneste som bevisst var bevisst, eller stoppe en tjeneste som allerede er stanset, etc.). Debian introduserte derfor <code
                  class="command">invoke-rc.d</code>-programmet: Dette programmet må benyttes av vedlikeholdsskripter til å kjøre skripter for å ta initiativet til tjenester, og det vil bare utføre de nødvendige kommandoer. Legg merke til at, i motsetning til vanlig bruk, er <code
                  class="filename">.d</code>-suffikset her brukt i et programnavn, og ikke i en katalog.
			</div></div><div
              class="para">
				Til slutt, <code
                class="command">init</code> starter kontrollprogrammer for ulike virtuelle konsoller (<code
                class="command">getty</code>). Den viser en ledetekst, venter på et brukernavn, og så kjører <code
                class="command">login <em
                  class="replaceable">bruker</em></code> for å starte en økt.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ORDFORRÅD</em></span> Konsoll og terminal</strong></p></div></div></div><div
                class="para">
				De første datamaskinene besto vanligvis av flere, svært store deler: Lagringskabinett og den sentrale prosessenheten var atskilt fra eksterne enheter som ble brukt av operatørene til å kontrollere maskinene. Dette var deler i et eget møbel, «konsollet». Dette begrepet ble beholdt, men betydningen har endret seg. Det har blitt mer eller mindre synonymt med «terminal», som er et tastatur og en skjerm.
			</div><div
                class="para">
				Med utviklingen av datamaskiner, tilbyr operativsystemer flere virtuelle konsoller for å muliggjøre flere uavhengige sesjoner på samme tid, selv om det er bare ett tastatur og en skjerm. De fleste GNU/Linux-systemer tilbyr seks virtuelle konsoller (i tekstmodus), som er tilgjengelige ved å skrive inn tastekombinasjonene <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> til <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				I forlengelsen av dette, kan begrepene «konsoll» og «terminal» også referere til en terminalemulator i en grafisk X11 sesjon (for eksempel <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code>, eller <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Forrige</strong>8.11. Å installere en kjerne</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Opp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hjem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Neste</strong>9.2. Ekstern innlogging</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../ko-KR/unix-services.html">ko-KR</a></li><li><a
              href="../nb-NO/unix-services.html">nb-NO</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../vi-VN/unix-services.html">vi-VN</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li><li><a
              href="../zh-TW/unix-services.html">zh-TW</a></li></ul></div></body></html>
