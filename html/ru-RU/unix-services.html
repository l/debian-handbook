<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Глава 9. Сервисы Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ru-RU-1.0-1" /><meta
        name="keywords"
        content="Загрузка системы, Сценарии инициализации, SSH, Telnet, Права, Привилегии, Инспектирование, Inetd, Cron, Резервное копирование, Горячее подключение, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="up"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installing a Kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Удалённый вход" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ru-RU/unix-services.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Пред.</strong></a></li><li
          class="home">Настольная книга администратора Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>След.</strong></a></li></ul><div
        xml:lang="ru-RU"
        class="chapter"
        lang="ru-RU"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>Глава 9. Сервисы Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Загрузка системы</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Система инициализации systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Удалённый вход</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Защищённый удалённый вход: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Использование удалённых графических рабочих столов</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Управление правами</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Интерфейсы для администрирования</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Администрирование через веб-интерфейс: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Настройка пакетов: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. Системные события <code
                    class="command">syslog</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Принципы и механизм</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Конфигурационный файл</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Суперсервер <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Планирование задач с помощью <code
                    class="command">cron</code> и <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Формат файла <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Использование команды <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Планирование асинхронных задач: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Квоты</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Резервное копирование</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Резервное копирование с помощью <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Восстановление машин без резервных копий</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Горячее подключение: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Введение</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. Проблема именования</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Как работает <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Конкретный пример</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Управление питанием: ACPI</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Эта глава посвящена нескольким основным сервисам, общим для многих Unix-систем. Все администраторы должны быть хорошо знакомы с ними.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. Загрузка системы</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			При загрузке компьютера множество сообщений, пробегающих на консоли, отображает выполнение многочисленных автоматических начальных инициализаций и настроек. Иногда может возникнуть желание несколько изменить работу этого этапа, а значит, необходимо хорошо её понимать. Помочь в этом — назначение данного раздела.
		</div><div
            class="para">
			Сначала BIOS получает контроль над компьютером, определяет диски, считывает <span
              class="emphasis"><em>главную загрузочную запись</em></span> и запускает загрузчик. Загрузчик принимает управление, находит ядро на диске, считывает и запускает его. Затем ядро инициализируется и начинает поиск и монтирование корневой файловой системы и, наконец, запускает первую программу — <code
              class="command">init</code>. Зачастую эти «корневой раздел» и <code
              class="command">init</code> на самом деле находятся на виртуальной файловой системе, существующей только в ОЗУ (отсюда её название — initramfs, ранее — initrd, от <span
              class="foreignphrase"><em
                class="foreignphrase">initialization RAM disk</em></span>). Эта файловая система загружается в память загрузчиком, часто из файла на жёстком диске или по сети. Он содержит самый минимум, необходимый для того, чтобы ядро загрузило «настоящую» корневую файловую систему: сюда могут входить модуля ядра для жёсткого диска или других устройств, без которых система не способна загрузиться, или, чаще, сценарии инициализации и модули для сборки массивов RAID, открытия зашифрованных разделов, активации томов LVM и т. п. Когда корневой раздел примонтирован, initramfs передаёт управление настоящему <code
              class="command">init</code>, и система возвращается к стандартному процессу загрузки.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Порядок загрузки компьютера с Linux и systemd" /></div></div><p
              class="title"><strong>Рисунок 9.1. Порядок загрузки компьютера с Linux и systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. Система инициализации systemd</h3></div></div></div><div
              class="para">
				«Настоящий init» сейчас предоставляется <span
                class="pkg pkg">systemd</span>, и в данном разделе описывается эта система инициализации.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>КУЛЬТУРА</em></span> До <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span
                  class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span
                  class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the System V init later on.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>АЛЬТЕРНАТИВА</em></span> Другие системы загрузки</strong></p></div></div></div><div
                class="para">
				This book describes the boot system used by default in Debian <span
                  class="distribution distribution">Jessie</span> (as implemented by the <span
                  class="pkg pkg">systemd</span> package), as well as the previous default, <span
                  class="pkg pkg">sysvinit</span>, which is derived and inherited from <span
                  class="emphasis"><em>System V</em></span> Unix systems; there are others.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> — это очень просто устроенная система загрузки. Она сохраняет принцип уровней запуска, но заменяет каталоги и символьные ссылки конфигурационным файлом, указывающим <code
                  class="command">init</code>, какие процессы и в каком порядке должны быть запущены.
			</div><div
                class="para">
				The <code
                  class="command">upstart</code> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span
                  class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span
                  class="pkg pkg">sysvinit</span>, and one of the tasks launched by <code
                  class="command">upstart</code> is to launch the scripts written for traditional systems, especially those from the <span
                  class="pkg pkg">sysv-rc</span> package.
			</div><div
                class="para">
				There are also other systems and other operating modes, such as <code
                  class="command">runit</code> or <code
                  class="command">minit</code>, but they are relatively specialized and not widespread.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ОСОБЫЙ СЛУЧАЙ</em></span> Загрузка по сети</strong></p></div></div></div><div
                class="para">
				В некоторых конфигурациях BIOS может быть настроен не на загрузку MBR, а на поиск её эквивалента в сети, что делает возможным собирать компьютеры без жёсткого диска или полностью переустанавливаемые при каждой загрузке. Такая опция есть не у любого оборудования, и для неё обычно необходимо определённое сочетание BIOS и сетевой карты.
			</div><div
                class="para">
				Загрузка по сети может использоваться для запуска <code
                  class="command">debian-installer</code> или FAI (см. <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Раздел 4.1, «Способы Установки»</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>К ОСНОВАМ</em></span> Процесс — экземпляр программы</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Процесс является отображением запущенной программы в памяти. Он содержит всю информацию, необходимую для корректной работы программы (сам код, а также данные, хранимые ей в памяти, список открытых ей файлов, установленных ей сетевых соединений и т. п.). Одна программа может быть представлена несколькими процессами, необязательно запущенными от имени разных пользователей.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>БЕЗОПАСНОСТЬ</em></span> Использование командной оболочки в качестве <code
                          class="command">init</code> для получения привилегий root</strong></p></div></div></div><div
                class="para">
				By convention, the first process that is booted is the <code
                  class="command">init</code> program (which is a symbolic link to <code
                  class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code
                  class="literal">init</code> option to the kernel indicating a different program.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Любой человек, способный получить доступ к компьютеру, может нажать кнопку <span
                  class="keycap"><strong>Reset</strong></span> и перезагрузить его. Потом, в приглашении загрузчика, можно передать ядру опцию <code
                  class="literal">init=/bin/sh</code>, чтобы получить доступ root, не зная пароля администратора.
			</div><div
                class="para">
				Чтобы предотвратить это, можно защитить паролем сам загрузчик. Следует также задуматься о защите доступа к BIOS (механизм защиты паролем почти всегда доступен), без которой злоумышленник всё равно сможет загрузить машину с переносного накопителя c собственной системой Linux, которую он сможет использовать для доступа к данным на жёстком диске компьютера.
			</div><div
                class="para">
				Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…
			</div></div><div
              class="para">
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> pairs grouped between <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit files are stored under <code
                class="filename">/lib/systemd/system/</code> and <code
                class="filename">/etc/systemd/system/</code>; they come in several flavours, but we will focus on “services” and “targets” here.
			</div><div
              class="para">
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</div><div
              class="para">
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code
                class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code
                class="literal">network-online.target</code> and <code
                class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code
                class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</div><div
              class="para">
				The first such utility is <code
                class="command">systemctl</code>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <code
                class="command">systemctl status</code> gives a better view of the services, as well as the related processes. If given the name of a service (as in <code
                class="command">systemctl status ntp.service</code>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</div><div
              class="para">
				Starting a service by hand is a simple matter of running <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. As one can guess, stopping the service is done with <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>; other subcommands include <code
                class="command">reload</code> and <code
                class="command">restart</code>.
			</div><div
              class="para">
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (or <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> allows checking the status of the service.
			</div><div
              class="para">
				An interesting feature of systemd is that it includes a logging component named <code
                class="command">journald</code>. It comes as a complement to more traditional logging systems such as <code
                class="command">syslogd</code>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <code
                class="command">journalctl</code> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Another useful command-line flag is <code
                class="command">-f</code>, which instructs <code
                class="command">journalctl</code> to keep displaying new messages as they are emitted (much in the manner of <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <code
                class="command">systemctl status</code>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div><div
                class="para">
				We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>. See <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <code
                        class="command">cron</code> features. See <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Среди них можно найти последовательность программ, отвечающих за:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						настройку клавиатуры в консоли;
					</div></li><li
                  class="listitem"><div
                    class="para">
						загрузку драйверов: большая часть модулей ядра загружается самим ядром при обнаружении оборудования; дополнительные драйверы затем загружаются автоматически, если соответствующие модули указаны в <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						проверку целостности файловых систем;
					</div></li><li
                  class="listitem"><div
                    class="para">
						монтирование локальных разделов;
					</div></li><li
                  class="listitem"><div
                    class="para">
						настройку сети;
					</div></li><li
                  class="listitem"><div
                    class="para">
						монтирование сетевых файловых систем (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>К ОСНОВАМ</em></span> Опции модулей ядра</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				У модулей ядра тоже есть опции, которые можно настроить, поместив некоторые файлы в <code
                  class="filename">/etc/modprobe.d/</code>. Эти опции определяются с помощью таких директив: <code
                  class="literal">options <em
                    class="replaceable">имя-модуля</em> <em
                    class="replaceable">имя-опции</em>=<em
                    class="replaceable">значение-опции</em></code>. При необходимости в одной директиве можно указывать несколько опций.
			</div><div
                class="para">
				Эти конфигурационные файлы предназначены для <code
                  class="command">modprobe</code> — программы, которая загружает модуль ядра вместе с его зависимостями (модули могут на самом деле вызывать другие модули). Эта программа предоставляется пакетом <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Такая основанная на зависимостях система загрузки делает возможной автоматизацию смены нумерации, которая была бы весьма утомительной, если бы её приходилось выполнять вручную, и снижает риск человеческой ошибки, поскольку планирование выполняется в соответствии с формальными параметрами. Другим преимуществом является возможность параллельного запуска сервисов, независимых друг от друга, что может ускорить процесс загрузки.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> различает несколько уровней запуска, так что она может переключаться с одного на другой при посредстве команды <code
                class="command">telinit <em
                  class="replaceable">новый-уровень</em></code>. <code
                class="command">init</code> сразу же запускает <code
                class="command">/etc/init.d/rc</code> заново с новым уровнем запуска. Этот сценарий после этого запускает недостающие сервисы и останавливает те, которые более не нужны. Для этого он руководствуется содержимым <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (где <em
                class="replaceable">X</em> означает новый уровень запуска). Сценарии, начинающиеся с «S» (как в слове «Start») — это сервисы, которые должны быть запущены; те, что начинаются с «K» (как в слове «Kill») — сервисы, которые должны быть остановлены. Сценарий не запускает никаких сервисов, которые уже были активированы на прежнем уровне запуска.
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Уровень 0 используется только временно, при выключении питания компьютера. Поэтому он содержит только «K»-сценарии.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Уровень 1, также известный как однопользовательский режим, соответствует системе с урезанной функциональностью; он включает только основные сервисы и предназначается для операций по обслуживанию, когда взаимодействие с обычными пользователями нежелательно.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Уровень 2 — уровень для нормальной работы, включающий сетевые сервисы, графический интерфейс, вход пользователей и т. п.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Уровень 6 похож на уровень 0 с той разницей, что он используется во время остановки системы перед перезагрузкой.
					</div></li></ul></div><div
              class="para">
				Есть и другие уровни, в частности с 3 по 5. По умолчанию они настроены, чтобы работать точно так же, как уровень 2, но администратор может изменить их (путём добавления или удаления сценариев в соответствующие каталоги <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>), чтобы приспособить их под свои специфические нужды.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>Рисунок 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Все сценарии, содержащиеся в различных каталогах <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> на самом деле являются лишь символьными ссылками — созданными при установке пакета программой <code
                class="command">update-rc.d</code> — указывающими на сами сценарии, хранящиеся в <code
                class="filename">/etc/init.d/</code>. Администратор может настроить доступность сервисов на каждом уровне запуска путём повторного запуска <code
                class="command">update-rc.d</code> с изменёнными параметрами. На странице руководства <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(8)</span> подробно описан синтаксис. Обратите внимание, что удаление всех символьных ссылок (с помощью параметра <code
                class="literal">remove</code>) — не лучший метод отключения сервиса. Вместо этого следует просто настроить, чтобы он не запускался на нужном уровне запуска (сохранив соответствующие вызовы для остановки его в случае, если сервис работал на предыдущем уровне запуска). Поскольку интерфейс <code
                class="command">update-rc.d</code> несколько запутанный, может оказаться более удобным использовать <code
                class="command">rcconf</code> (из пакета <span
                class="pkg pkg">rcconf</span>), интерфейс которой более дружествен к пользователю.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ПОЛИТИКА DEBIAN</em></span> Перезапуск сервисов</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <code
                  class="command">invoke-rc.d</code> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <code
                  class="filename">.d</code> suffix is used here in a program name, and not in a directory.
			</div></div><div
              class="para">
				Наконец, <code
                class="command">init</code> запускает программу управления виртуальными консолями (<code
                class="command">getty</code>). Она выводит приглашение, ожидает ввода имени пользователя, а затем выполняет <code
                class="command">login <em
                  class="replaceable">пользователь</em></code>, чтобы начать сессию.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>СЛОВАРЬ</em></span> Консоль и терминал</strong></p></div></div></div><div
                class="para">
				Первые компьютеры обычно состояли из нескольких очень больших частей: устройство хранения данных и вычислительный модуль размещались отдельно от периферийных устройств, используемых операторами для управления. Часть этой оснастки называлась «консоль». Этот термин остался, но смысл его изменился. Он стал синонимом «терминала» — клавиатуры и дисплея.
			</div><div
                class="para">
				С развитием компьютеров операционные системы стали предлагать несколько виртуальных консолей, чтобы сделать возможной одновременную работу нескольких сессий даже при наличии только одной клавиатуры и дисплея. В большинстве систем GNU/Linux шесть виртуальных консолей (в текстовом режиме), доступных путём нажатия сочетаний клавиш с <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> по <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Также термины «консоль» и «терминал» могут означать эмулятор терминала в графической сессии X11 (например <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> или <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Пред.</strong>8.11. Installing a Kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Наверх</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Начало</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>След.</strong>9.2. Удалённый вход</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../ko-KR/unix-services.html">ko-KR</a></li><li><a
              href="../nb-NO/unix-services.html">nb-NO</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../vi-VN/unix-services.html">vi-VN</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li><li><a
              href="../zh-TW/unix-services.html">zh-TW</a></li></ul></div></body></html>
