<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.9. Другие настройки: Синхронизация времени, Журналы, Разделение Доступа…</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-ru-RU-1.0-1" /><meta
        name="keywords"
        content="Конфигурация, Локализация, Локали, Сеть, Разрешение имён, Пользователи, Группы, Аккаунты, Интерпретатор командной строки, Оболочка, Печать, Загрузчик, Компиляция ядра" /><link
        rel="home"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="up"
        href="basic-configuration.html"
        title="Глава 8. Базовая конфигурация: Сеть, Аккаунты, Печать..." /><link
        rel="prev"
        href="sect.config-bootloader.html"
        title="8.8. Настройка Загрузчика" /><link
        rel="next"
        href="sect.kernel-compilation.html"
        title="8.10. Компиляция Ядра" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/ru-RU/sect.config-misc.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>Пред.</strong></a></li><li
          class="home">Настольная книга администратора Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>След.</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.config-misc"></a>8.9. Другие настройки: Синхронизация времени, Журналы, Разделение Доступа…</h2></div></div></div><div
          class="para">
			Многие элементы, перечисленные в данной главе, полезно знать тем, кто хочет освоить все стороны настройки систем GNU/Linux. Однако, они описаны кратко, а за подробной информацией рекомендуется обратиться к документации.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.timezone"></a>8.9.1. Timezone (Часовой пояс)</h3></div></div></div><a
            id="id-1.11.13.3.2"
            class="indexterm"></a><div
            class="sidebar"><a
              id="sidebar.symbolic-link"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>К ОСНОВАМ</em></span> Символические ссылки</strong></p></div></div></div><a
              id="id-1.11.13.3.3.2"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.3"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.4"
              class="indexterm"></a><div
              class="para">
				Символическая ссылка является указателем на другой файл. Когда вы обращаетесь к ссылке, то открывается тот файл, на который она указывает. При удалении ссылки, сам файл, на который она указывает, не удаляется. Более того, ссылка не имеет своих прав доступа, а получает права доступа (в момент своего создания) как бы "в наследство" от файла, на который она ссылается. Кроме того, ссылка может указывать на любой файл: на каталоги, на специальные файлы (сокеты, именованные каналы, файлы устройств, и т.д.), даже на другие символические ссылки.
			</div><div
              class="para">
				Команда <code
                class="command">ln -s <em
                  class="replaceable">target</em> <em
                  class="replaceable">link-name</em></code> создаст символическую ссылку (параметр "s" - "мягкую"), называемую <em
                class="replaceable">link-name</em>, и указывающую на существующий файл (каталог и т.д., target - цель) <em
                class="replaceable">target</em>.
			</div><div
              class="para">
				Если файл, на который указывает ссылка, не существует, то ссылка считается “бúтой”. При попытке получить доступ к ней будет получен результат с ошибками, сообщающими, что файл, на который она ссылается, не существует. Если ссылка указывает на другую ссылку, вы будете иметь "цепочку" ссылок, которая превратится в "цикл" (cycle), если в этой цепочке ссылок хотя бы одна из них показывает на один из предыдущих файлов (ссылок, по цепочке). То есть вся цепочка закольцована. В этом случае, при попытке получить доступ к одному звену (ссылке, файлу) этой цепочки будет выдана особая ошибка (“слишком много уровней символических ссылок”). Значит ядро отказалось делать далее бессмысленную (с его точки зрения) работу (после нескольких неудачных попыток разобраться с круговыми цепочками).
			</div></div><div
            class="para">
				Часовой пояс определяется в процессе установки дистибутива на машину, входит в пакет <span
              class="pkg pkg">tzdata</span>. При возникновении необходимости изменить часовой пояс запустите команду <code
              class="command">dpkg-reconfigure tzdata</code>. Ответив на несколько вопросов в интерактивном режиме, программа установит новый часовой пояс на вашей машине, который будет использоваться в дальнейшем. Эти настройки сохраняются в файле <code
              class="filename">/etc/timezone</code>. Кроме этого будет скопирован соответствующий файл из каталога <code
              class="filename">/usr/share/zoneinfo</code> в <code
              class="filename">/etc/localtime</code>. Он содержит правила, каким образом переводится время на летний (зимний) период в той или иной стране, для стран, использующих такой порядок (в Debian 9.2 создана мягкая ссылка).
			</div><a
            id="id-1.11.13.3.5"
            class="indexterm"></a><a
            id="id-1.11.13.3.6"
            class="indexterm"></a><a
            id="id-1.11.13.3.7"
            class="indexterm"></a><a
            id="id-1.11.13.3.8"
            class="indexterm"></a><a
            id="id-1.11.13.3.9"
            class="indexterm"></a><a
            id="id-1.11.13.3.10"
            class="indexterm"></a><div
            class="para">
				Если вам понадобится временно изменить часовой пояс, используйте переменную окружения <code
              class="varname">TZ</code>, которая будет иметь приоритет над настройками окружения, которые обычно используются "по умолчанию":
			</div><a
            id="id-1.11.13.3.12"
            class="indexterm"></a><a
            id="screen.tz"></a><pre
            class="screen">
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>date</code></strong>
<code
              class="computeroutput">Thu Feb 19 11:25:18 CET 2015</code>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>TZ="Pacific/Honolulu" date</code></strong>
<code
              class="computeroutput">Thu Feb 19 00:25:21  HST 2015</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ЗАМЕТКА</em></span> Системные часы, аппаратные часы</strong></p></div></div></div><div
              class="para">
				На компьютере часы представлены в двух вариантах. Часы установленные на материнской плате (в BIOS) являются аппаратными и называются “CMOS часы”. Эти часы не очень точные, и обеспечивает довольно медленное время доступа к ним. Ядро операционной системы имеет свои, внутренние, часы, реализованные как маленькая программа. Эти программные часы самостоятельно рассчитывает время и сохраняют его между перезагрузками системы (возможно с помощью серверов времени, смотри <a
                class="xref"
                href="sect.config-misc.html#sect.time-synchronization">Раздел 8.9.2, «Синхронизация Времени»</a>). Эти системные часы обычно более точные, особенно потому, что им не надо получать доступ к аппаратным переменным. Однако, поскольку программные системные часы существуют только в "живой" памяти (то есть в "работающей" системе), они обнуляются каждый раз как только машина загружается (перегружается). Часы CMOS, напротив, имеют аккумулятор и поэтому они “выживают” при перезагрузке или остановке машины. Поэтому во время загрузки компьютера системные часы установлены по данным из CMOS (то есть аппаратно), в момент работы системы - работают программные системные часы в ядре, а в момент выключения компьютера часы в CMOS обновляются по данным из системных программных часов (для того, чтобы учесть возможные изменения или исправления, если аппаратные часы неправильно отрегулированы).
			</div><div
              class="para">
				На практике часто встречается проблема: поскольку CMOS часы не более чем простой счётчик времени, то они не содержат информацию о часовом поясе. Следовательно установленное в CMOS время система может толковать двояко: установлены часы в режиме мирового времени (UTC, бывшее GMT), или в режиме местного времени. Казалось бы, что можно просто изменить время в CMOS, когда понадобится и всё. Однако в действительности это немного сложнее: в частности смещение времени из-за переключения на летнее время не является постоянной величиной. В результате нет универсального способа дать понять системе как ей, ежегодно два раза в год, переключать часы на летнее время и обратно. Описываемая проблема касается случаев, когда в CMOS установлено местное время. Поэтому, поскольку всегда есть возможность воссоздать местное время путём суммирования информации из двух источников: всемирного времени и информации о часовом поясе на локальном компьютере, настоятельно рекомендуем устанавливать в CMOS часах мировое время (если на компьютере не установлены отличные от Linux операционные системы).
			</div><div
              class="para">
				К сожаленью, операционные системы Windows игнорируют эту рекомендацию в настройках по умолчанию. Они контролируют, чтобы часы CMOS всегда были установлены в местное время. При этом, каждый раз во время загрузки (перегрузки), они просматривают часы CMOS, определяя были ли внесены изменения в настройку часов, и если были - то сами, не спрашивая пользователя, опять устанавливают (в CMOS) местное время. Это работает довольно хорошо для случаев, когда только одна из упомянутых операционных систем запущена на компьютере (или несколько из одного семейства Windows, например Windows XP на разделе sda1, Windows Vista на разделе sda2 и тд, то есть "двойная и более" загрузка этих систем). Но в случаях, когда компьютер имеет несколько установленных систем от разных производителей (в режиме "мультизагрузки") происходит хаос ("образно говоря") на компьютере при попытке самих систем определить - установлено ли время корректно (это варианты с “двойной-и-более загрузкой” или запуск другой системы через виртуальную машину). Если вам (по какой-то причине) невозможно обойтись без установленной Windows на компьютере, то немного подкорректируйте её настройки следующим образом. В частности, чтобы установленные в UTC часы CMOS не переустанавливались снова и снова этими операционными системами, в настройках реестра введите параметр "1" и "DWORD" в ключ <code
                class="literal">HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</code>. Другой вариант решения данной проблемы (для Debian систем) - это выполнить в консоле такую команду <code
                class="command">hwclock --localtime --set</code> (и добавить --date "ввести время и дату"), чтобы установить аппаратные часы в нужное вам время и пометить, чтобы система отслеживала местное время (не забудьте вручную иногда контролировать летнее и зимнее время).
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.time-synchronization"></a>8.9.2. Синхронизация Времени</h3></div></div></div><a
            id="id-1.11.13.4.2"
            class="indexterm"></a><a
            id="id-1.11.13.4.3"
            class="indexterm"></a><div
            class="para">
				Синхронизация времени может показаться излишней для отдельно взятого компьютера, однако её выполнение крайне важно для локальных сетей. Чтобы не происходила путаница, простым пользователям запрещено изменять время и дату. В локальной сети, где регулярно выполняется синхронизация времени всех компьютеров в системе, делать перекрёстный анализ информации из журналов событий, полученных с разных машин в сети, гораздо удобнее. К тому же, в случае нападения на сеть извне, можно будет быстро реконструировать хронологическую цепочку событий, предшествующую этому: определить какие машины и в какое время подвергались атаке и, как следствие этого, они могли быть скомпрометированы. Собираемые с разных машин в сети данные для статистических целей, не имеют большого смысла, если все эти машины не синхронизированы между собой по времени.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>К ОСНОВАМ</em></span> NTP</strong></p></div></div></div><a
              id="id-1.11.13.4.5.2"
              class="indexterm"></a><a
              id="id-1.11.13.4.5.3"
              class="indexterm"></a><div
              class="para">
				NTP (Сетевой Протокол Времени) позволяет машине синхронизироваться с другими (машинами) довольно точно, учитывая задержки, вызванные передачей информации по сети (интернет) или другие возможные отклонения.
			</div><div
              class="para">
				Хотя существует множество серверов NTP в Интернете, наиболее популярные из них могут быть перегружены. Именно по этой причине мы рекомендуем использовать NTP сервер <span
                class="emphasis"><em>pool.ntp.org</em></span>. Под данным адресам работает на самом деле группа машин, которые согласились предоставлять услуги (неограниченному кругу пользователей) в качестве публичных серверов NTP. Вы можете конкретизировать и выбрать для данных целей именно свою страну. Например <span
                class="emphasis"><em>us.pool.ntp.org</em></span> можно использовать для США, или <span
                class="emphasis"><em>ca.pool.ntp.org</em></span> для Канада и т.д.
			</div><div
              class="para">
				Однако, если вы управляете большой сетью, рекомендуется установить ваш собственный NTP сервер (в пакете с похожим именем), который будет синхронизироваться с публичными серверами (дата и время). В этом случае, все другие машины вашей сети могут использовать ваш внутренний NTP сервер вместо того, чтобы увеличивать нагрузку на публичные сервера. Из за того, что все ваши машины будут синхронизированы по дате и времени с одним внутренним источником, разбалансировка по времени на всех машинах в локальной сети будет минимальна. Уменьшается время прохождения информации по сети (каждый пакет проходит более короткий путь).
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ntp-on-workstations"></a>8.9.2.1. Для Рабочих Станций</h4></div></div></div><div
              class="para">
					Поскольку рабочие станции регулярно перезагружаются (или выключаются иногда даже, только для сохранения электричества), то синхронизации их по NTP в момент загрузки бывает обычно достаточно. Для этого надо просто установить пакет <span
                class="pkg pkg">ntpdate</span>. Можно также изменить NTP сервер, который будет использоваться, отредактировав файл <code
                class="filename">/etc/default/ntpdate</code>.
				</div><a
              id="id-1.11.13.4.6.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.6.4"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ntp-on-servers"></a>8.9.2.2. Для Серверов</h4></div></div></div><div
              class="para">
					Сервера крайне редко перезагружаются, поэтому очень важно, чтобы их системное время всегда было корректно установлено. Чтобы постоянно поддерживать правильное время, установите локальный NTP сервер. Данная возможность включена в пакет <span
                class="pkg pkg">ntp</span>. В настройках по умолчанию сервер, с одной стороны, будет синхронизироваться с внешним публичным сервером <span
                class="emphasis"><em>pool.ntp.org</em></span> и, с другой стороны, будет предоставлять данные о дате и времени в ответ на запросы, поступающие из локальной сети. Вы можете редактировать файл <code
                class="filename">/etc/ntp.conf</code>, изменив в нем NTP сервер, который будет использоваться для синхронизации (наиболее часто изменяемая опция). Если в сети много серверов, то вас может заинтересовать вариант с локальным сервером времени, синхронизирующимся с публичным сервером. Он же будет использоваться в качестве источника для других серверов сети.
				</div><a
              id="id-1.11.13.4.7.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.4"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.5"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>УГЛУБЛЯЕМСЯ</em></span> GPS модули и другие источники времени</strong></p></div></div></div><a
                id="id-1.11.13.4.7.6.2"
                class="indexterm"></a><a
                id="id-1.11.13.4.7.6.3"
                class="indexterm"></a><div
                class="para">
					Если синхронизация времени имеет особо важное значение для вашей сети, то можно оборудовать сервер GPS модулем (который будет использовать время со спутников GPS) или DCF-77 модулем (который будет синхронизировать время с атомными часами недалеко от Франкфурта, Германия). В этом случае, настройка NTP сервера немного сложнее, и предварительное изучение документации (руководства и т.д.) по ntp является абсолютной необходимостью.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.rotation-logs"></a>8.9.3. Смена Журналов Событий</h3></div></div></div><a
            id="id-1.11.13.5.2"
            class="indexterm"></a><a
            id="id-1.11.13.5.3"
            class="indexterm"></a><a
            id="id-1.11.13.5.4"
            class="indexterm"></a><a
            id="id-1.11.13.5.5"
            class="indexterm"></a><div
            class="para">
				Так как со временем журналы событий могут увеличиваться, иногда очень быстро, возникает необходимость архивирования их время от времени. Наиболее распространённой схемой является чередование архивов: журнал событий регулярно архивируется, и только последний <em
              class="replaceable">X</em> архив сохраняется. Программа <code
              class="command">logrotate</code> является инициатором этих чередований, она руководствуется правилами, прописанными в: файле <code
              class="filename">/etc/logrotate.conf</code> и во всех файлах, расположенных в каталоге <code
              class="filename">/etc/logrotate.d/</code>. Администратор может модифицировать эти файлы, если желает приспособить политику чередования событий, определённую в Debian, к своим нуждам. Страница руководства <span
              class="citerefentry"><span
                class="refentrytitle">logrotate</span>(1)</span> описывает все параметры, доступные в тех конфигурационных файлах. Возможно вы захотите: увеличить количество файлов, сохраняемых при чередовании журналов событий, или переместить журналы событий в особенный каталог, предназначенный для их архивирования (предпочтитая не удалять старые журналы). Вы можете также послать их по e-mail для архивирования где-нибудь в другом месте.
			</div><div
            class="para">
				Программа <code
              class="command">logrotate</code> выполняется ежедневно, её запуск выполняет планировщик задач <code
              class="command">cron</code> (смотри раздел <a
              class="xref"
              href="sect.task-scheduling-cron-atd.html">Раздел 9.7, «Планирование задач с помощью <code
                class="command">cron</code> и <code
                class="command">atd</code>»</a>).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.sharing-admin-rights"></a>8.9.4. Разделение Прав Администратора (делегирование части полномочий другому пользователю или старшему администратору)</h3></div></div></div><a
            id="id-1.11.13.6.2"
            class="indexterm"></a><a
            id="id-1.11.13.6.3"
            class="indexterm"></a><a
            id="id-1.11.13.6.4"
            class="indexterm"></a><div
            class="para">
				Часто несколько администраторов работают в одной и той же сети. Первый самый простой способ для обеспечения возможности им совместно работать - вариант, при котором все администраторы имеют право работать в этой сети под одним и тем же паролем администратора. Такое решение не является наилучшим, та как открывает лазейки для выполнения кем-то из них недопустимых действий, а из-за анонимности - избежать ответственности в дальнейшем. Решением данной проблемы является программа <code
              class="command">sudo</code>, которая позволяет определённым пользователям выполнять оговоренные команды со специальными правами. В наиболее распространённом случае её использования (применяемом часто из-за простоты а не из-за того, что это наилучшее решение), <code
              class="command">sudo</code> позволяет доверить пользователю выполнение любой команды от лица администратора. Для этого пользователь просто выполняет <code
              class="command">sudo <em
                class="replaceable">command</em></code> и для проверки подлинности использует свой персональный пароль (при этом, что очень важно, все действия такого пользователя записываются в специальный журнал событий и в дальнейшем можно легко отследить кто и что сделал).
			</div><div
            class="para">
				После установки пакета <span
              class="pkg pkg">sudo</span>, во вновь созданную Unix группу <code
              class="literal">sudo</code> будут добавлены новые участники - пользователи, которым разрешается работать с полными правами администратора. Для перераспределения других прав (делегирование полномочий) администратор должен использовать команду <code
              class="command">visudo</code>, которая позволит ему модифицировать файлы настройки <code
              class="filename">/etc/sudoers</code> (в данном примере "visudo" - это запуск текстового редактора <code
              class="command">vi</code> с правами "sudo" для редактирования упомянутого файла. Вы можете использовать свой редактор, тот, что установлен у вас как переменная окружения <code
              class="varname">EDITOR</code>). Добавление строки <code
              class="literal"><em
                class="replaceable">username</em> ALL=(ALL) ALL</code> позволит пользователю, о котором идёт речь, выполнить любую команду как администратор.
			</div><a
            id="id-1.11.13.6.7"
            class="indexterm"></a><a
            id="id-1.11.13.6.8"
            class="indexterm"></a><a
            id="id-1.11.13.6.9"
            class="indexterm"></a><div
            class="para">
				Более тонкие настройки дают возможность наделить определёнными полномочиями оговоренных пользователей, то есть уполномочить их на выполнение тех или иных действий, не давая им при этом полных прав администратора, даже под "sudo". Детальную информацию вы можете получить на страницах руководства <span
              class="citerefentry"><span
                class="refentrytitle">sudoers</span>(5)</span>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.fstab-mount-points"></a>8.9.5. Список Точек Монтирования</h3></div></div></div><a
            id="id-1.11.13.7.2"
            class="indexterm"></a><a
            id="id-1.11.13.7.3"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>К ОСНОВАМ</em></span> Монтирование и размонтирование (устройств)</strong></p></div></div></div><div
              class="para">
				В Unix-подобной системе, такой как Debian, файлы организованы в единую древовидную структуру каталогов. Каталог <code
                class="filename">/</code> называется “корневым каталогом”; все дополнительные каталоги (имеющиеся в системе, кроме корневого) являются подкаталогами внутри этого "корневого" каталога. “Монтирование” - это действие, подключающее содержимое периферийного устройства (часто жёсткого диска) к системному общему каталогу файлов в качестве подкаталога. Следовательно, если вы используете отдельный жёсткий диск для размещения персональных данных пользователей, этот диск должен быть “смонтирован” в каталоге <code
                class="filename">/home/</code>. Корневая файловая система всегда монтируется ядром на старте системы; другие устройства часто монтируются позднее, в процессе выполнения последовательности сценариев загрузки системы (например подключается файл подкачки) или вручную с командой <code
                class="command">mount</code>.
			</div><a
              id="id-1.11.13.7.4.3"
              class="indexterm"></a><div
              class="para">
				Некоторые съёмные устроства автоматически монтируются сразу после физического подсоединения, особенно при использовании графических оболочек GNOME, KDE или других окружений рабочего стола. Другие монтируются пользователями вручную. Но и в том и в другом случае они должны быть размонтированы до того, как будут физически отсоединены от компьютера (в этом случае из каталога файлов, после размонтирования, исчезнут эти отмонтированные подкаталоги). Рядовые пользователи обычно не имеют прав на выполнение команд <code
                class="command">mount</code> и <code
                class="command">umount</code>. Однако, администратор может разрешить им выполнение данных действий (конкретно для каждой точки монтирования) включив параметр <code
                class="literal">user</code> в файл <code
                class="filename">/etc/fstab</code>.
			</div><div
              class="para">
				Команда <code
                class="command">mount</code> может быть использована без аргументов (тогда она просмотрит и отобразит все смонтированные в настоящее время файловые системы). Добавление в строку с командой параметров необходимо для монтирования или размонтирования устройств (которые не перечислены в файле "/etc/fstab"). Для детальной информации, пожалуйста, обратитесь к страницам руководства, <span
                class="citerefentry"><span
                  class="refentrytitle">mount</span>(8)</span> и <span
                class="citerefentry"><span
                  class="refentrytitle">umount</span>(8)</span>. Для рядовых случаев, синтаксис достаточно прост: для примера, монтировать раздел <code
                class="filename">/dev/sdc1</code>, с файловой системой ext3, в точку монтирования каталог <code
                class="filename">/mnt/tmp/</code> вы можете просто - выполнив команду <code
                class="command">mount -t ext3 /dev/sdc1 /mnt/tmp/</code>. (Чтобы определить, как ядро опознало ваш USB-диск например, сделайте до этого "dmesg". Вы увидите "/dev/sdc1" или другое имя вашего устройства, которое и надо будет смонтировать).
			</div></div><div
            class="para">
				В файле <code
              class="filename">/etc/fstab</code> перечислены все возможные варианты монтирования (разрешённые администратором на данной системе): которые выполняются автоматически при загрузке системы и позволенные опции для монтирования в дальнейшем вручную для съёмных запоминающих устройств (например CDROM). Каждой точке монтирования выделена одна строка. Она содержит несколько полей, используя в качестве разделителей пробелы: <a
              id="id-1.11.13.7.5.2"
              class="indexterm"></a> <a
              id="id-1.11.13.7.5.3"
              class="indexterm"></a>
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</div><div
                  class="para">
						Это поле часто заменяется записью с указанием уникального ID файловой системы (который вы можете определить выполнив команду <code
                    class="command">blkid <strong
                      class="userinput"><code>device</code></strong></code>), введя в качестве префикса <code
                    class="literal">UUID=</code> (то есть вы указываете что нужно смонтировать не в привычном нам виде, как например "/dev/sdc1", а в виде "mount UUID=8e9cb4e1-5aa0-4340-b43e-a489741299fa1 /mnt/point"). Такой подход предотвращает возникновение путаницы с присвоением имён подсоединяемым устройствам (поскольку ядро нумерует все присоединяемые физически к компьютеру устройства по мере их подключения. К примеру ранее опознанное устройство как sdc1 через два-три дня может быть опознано как sdf1, смотрите "dmesg"). Чтобы этого избежать и рекомендуется при монтировании указывать ID устройства в явной, то есть конкретной форме (UUID=8e9cb4e1-5aa0-4340-b43e-a489741299fa1) Таким образом это ID устройство будет одно и то же и через день и через месяц.
					</div></li><li
                class="listitem"><div
                  class="para">
						точка монтирования: это точка (местоположение в вашей системе каталогов), в которую будет присоединено (примонтировано) устройство, удалённая система, раздел диска и т.д.
					</div></li><li
                class="listitem"><div
                  class="para">
						тип: это поле описывает, какая файловая система используется на монтируемом устройстве. К примеру: <code
                    class="literal">ext4</code>, <code
                    class="literal">ext3</code>, <code
                    class="literal">vfat</code>, <code
                    class="literal">ntfs</code>, <code
                    class="literal">btrfs</code>, <code
                    class="literal">xfs</code> и другие.
					</div><div
                  class="sidebar"><div
                    class="titlepage"><div><div><p
                          class="title"><strong><span
                              class="emphasis"><em>К ОСНОВАМ</em></span> NFS, сетевая файловая система</strong></p></div></div></div><div
                    class="para">
						NFS является сетевой файловой системой; под Linux-ом она позволяет прозрачно получить доступ к удалённым файлам, включая их в локальную файловую систему.
					</div></div><div
                  class="para">
						С полным перечнем, известных программе "mount (unmount)" файловых систем, можно ознакомиться в руководстве <span
                    class="citerefentry"><span
                      class="refentrytitle">mount</span>(8)</span>. Специальный тип файловой системы <code
                    class="literal">swap</code> предназначен для раздела подкачки (виртуальная память); специальный параметр <code
                    class="literal">auto</code> сообщит программе <code
                    class="command">mount</code>, что ей нужно попытаться самой автоматически определить тип файловой системы (данная опция особенно полезна при использовании различных приспособлений, в которые всталяются диски и USB-устройства, так как каждое из них может иметь свою собственную файловую систему);
					</div></li><li
                class="listitem"><div
                  class="para">
						параметры: их имеется много, все они разные и зависят от особенностей той или иной файловой системы, для более детальной информации читаете руководства в <code
                    class="command">mount</code>. Наиболее известные из них
					</div><div
                  class="itemizedlist"><ul><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">rw</code> или <code
                          class="literal">ro</code> - эти параметры сообщают программе с какими правами доступа надо смотрировать устройство: в режиме "чтения-записи" ("rw" - read/write) или в режиме "только для чтения" ("ro" - read only).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">noauto</code> - отключает автоматическое монтирование устройства в процессе выполнения загрузки системы (в нижерасположенном примере можно заменить scd0 на sr0 для CDROM/DVD, если dmesg таким образом опознаёт его).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">nofail</code> - позволит выполнять далее загрузку, несмотря на то, что какое-то внешнее устройство не представлено в настоящий момент в системе. Убедитесь, что включили этот параметр именно для того дополнительного устройства, которое, так может случиться, будет отсоединено физически от компьютера в момент загрузки системы. Команда <code
                          class="command">systemd</code> действительно гарантирует то, что всё, что должно было быть смонтировано в системе, будет сделано своевременно, присвоив им до этого наименования, и далее процесс загрузки нормально дойдёт до конца. Обратите внимание, что вы можете скомбинировать этот параметр с <code
                          class="literal">x-systemd.device-timeout=5s</code>, чтобы сказать <code
                          class="command">systemd</code> не ожидать более чем 5 сек появления внешнего устройства в системе (смотрите руководство <span
                          class="citerefentry"><span
                            class="refentrytitle">systemd.mount</span>(5)</span>).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">user</code> - разрешает всем пользователям монтировать эту файловую систему (а например записанное в этом поле "root" - напротив позволяет делать это только администратору).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">defaults</code> - значит применить группу параметров по умолчанию, включающих в себя: <code
                          class="literal">rw</code>, <code
                          class="literal">suid</code>, <code
                          class="literal">dev</code>, <code
                          class="literal">exec</code>, <code
                          class="literal">auto</code>, <code
                          class="literal">nouser</code> и <code
                          class="literal">async</code>. Каждый из них может быть отлючён индивидуально добавлением после <code
                          class="literal">defaults</code> следующих записей - <code
                          class="literal">nosuid</code>, <code
                          class="literal">nodev</code>, которые исключат тот или иной параметр из группы по умолчанию (в данном примере исключаются <code
                          class="literal">suid</code>, <code
                          class="literal">dev</code>). При добавлении после "defaults" слова <code
                          class="literal">user</code> будет выполнено противоположное по смыслу действие - то есть отключение "группы параметров по умолчанию", поскольку <code
                          class="literal">defaults</code> сам в своём перечне уже включает <code
                          class="literal">nouser</code>.
							</div></li></ul></div></li><li
                class="listitem"><div
                  class="para">
						dump: this field is almost always set to <code
                    class="literal">0</code>. When it is <code
                    class="literal">1</code>, it tells the <code
                    class="command">dump</code> tool that the partition contains data that is to be backed up.
					</div></li><li
                class="listitem"><div
                  class="para">
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <code
                    class="literal">0</code>, no check is conducted. The root filesystem should have the value <code
                    class="literal">1</code>, while other permanent filesystems get the value <code
                    class="literal">2</code>.
					</div></li></ul></div><div
            class="example"><a
              id="example.fstab"></a><p
              class="title"><strong>Пример 8.6. Пример файла <code
                  class="filename">/etc/fstab</code></strong></p><div
              class="example-contents"><pre
                class="programlisting">
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
#  swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</pre></div></div><div
            class="para">
				В нижерасположенном примере последней записью подключается каталог сетевой файловой системы (NFS): каталог <code
              class="filename">/shared/</code>, размещённый физически на сервере <span
              class="emphasis"><em>arrakis</em></span> будет присоединён в точку монтирования <code
              class="filename">/shared/</code> на локальной машине. Формат файла <code
              class="filename">/etc/fstab</code> задокументирован в руководстве <span
              class="citerefentry"><span
                class="refentrytitle">fstab</span>(5)</span>.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>УГЛУБЛЯЕМСЯ</em></span> Автомонтирование</strong></p></div></div></div><div
              class="para">
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</div><div
              class="para">
				Like most concepts in systemd, automount points are managed with dedicated units (using the <code
                class="literal">.automount</code> suffix). See <span
                class="citerefentry"><span
                  class="refentrytitle">systemd.automount</span>(5)</span> for their precise syntax.
			</div><a
              id="id-1.11.13.7.9.4"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.5"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.6"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.7"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.8"
              class="indexterm"></a><div
              class="para">
				Other auto-mounting utilities exist, such as <code
                class="command">automount</code> in the <span
                class="pkg pkg">autofs</span> package or <code
                class="command">amd</code> in the <span
                class="pkg pkg">am-utils</span>.
			</div><div
              class="para">
				Заметим также, что GNOME, KDE, и другие графические окружения рабочего стол работают совместно с <span
                class="emphasis"><em>udisks</em></span>, и могут автоматически монтировать съёмные устройства после их подключения (физически) к машине.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.locate-updatedb"></a>8.9.6. <code
                    class="command">locate</code> и <code
                    class="command">updatedb</code></h3></div></div></div><a
            id="id-1.11.13.8.2"
            class="indexterm"></a><a
            id="id-1.11.13.8.3"
            class="indexterm"></a><a
            id="id-1.11.13.8.4"
            class="indexterm"></a><div
            class="para">
				Команда <code
              class="command">locate</code> может найти месторасположение файла даже если вы знаете только часть его имени. Она выдаёт результат почти мгновенно, сначала лишь проконсультировавшись с базой данных, которая сохраняет месторасположение всех файлов, имеющихся в системе. Эта база данных обновляется ежедневно командой <code
              class="command">updatedb</code>. Существует несколько разновидностей (вариантов) команды <code
              class="command">locate</code>. Для включения в стандартную систему Debian выбрана её разновидность, называемая <span
              class="pkg pkg">mlocate</span> (входит в пакет с похожим именем).
			</div><div
            class="para">
				Команда <code
              class="command">mlocate</code> достаточно умна - при выдаче результата она учитывает права доступа и выдаёт лишь те файлы, что доступны запустившему её пользователю. несмотря на то, что она знает про все файлы, имеющиеся в системе (поскольку реализация этой программы <code
              class="command">updatedb</code> запускается с правами администратора). Для дополнительной безопасности администратор может использовать <code
              class="varname">PRUNEDPATHS</code> в файле <code
              class="filename">/etc/updatedb.conf</code> для исключения из индексирования некоторых каталогов.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>Пред.</strong>8.8. Настройка Загрузчика</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Наверх</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Начало</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>След.</strong>8.10. Компиляция Ядра</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.config-misc.html">ar-MA</a></li><li><a
              href="../da-DK/sect.config-misc.html">da-DK</a></li><li><a
              href="../de-DE/sect.config-misc.html">de-DE</a></li><li><a
              href="../el-GR/sect.config-misc.html">el-GR</a></li><li><a
              href="../en-US/sect.config-misc.html">en-US</a></li><li><a
              href="../es-ES/sect.config-misc.html">es-ES</a></li><li><a
              href="../fa-IR/sect.config-misc.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.config-misc.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.config-misc.html">hr-HR</a></li><li><a
              href="../id-ID/sect.config-misc.html">id-ID</a></li><li><a
              href="../it-IT/sect.config-misc.html">it-IT</a></li><li><a
              href="../ja-JP/sect.config-misc.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.config-misc.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.config-misc.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.config-misc.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.config-misc.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.config-misc.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.config-misc.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.config-misc.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.config-misc.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.config-misc.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.config-misc.html">zh-TW</a></li></ul></div></body></html>
