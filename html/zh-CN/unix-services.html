<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">第 9 章 Unix 服务</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-zh-CN-1.0-1" /><meta
        name="keywords"
        content="系统启动, 启动脚本, SSH, Telnet, 权限, 许可, 管理, Inetd, Cron, 备份, 热插拔, PCMCIA接口, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian 管理员手册" /><link
        rel="up"
        href="index.html"
        title="Debian 管理员手册" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installing a Kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. 远程登录" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/zh-CN/unix-services.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>上一页</strong></a></li><li
          class="home">Debian 管理员手册</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>下一页</strong></a></li></ul><div
        xml:lang="zh-CN"
        class="chapter"
        lang="zh-CN"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>第 9 章 Unix 服务</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. 系统启动</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. The systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. 远程登录</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. 安全远程登录：SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. 使用远程图形桌面</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. 管理权限</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. 管理员介面</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrating on a Web Interface: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. 用于管理配置的软件包： <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> 系统事件</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. 原则和机制</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. 配置文件</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6.  <code
                    class="command">inetd</code> 超级服务</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. 使用 <code
                    class="command">cron</code> 和 <code
                    class="command">atd</code>运行计划任务</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1.  <code
                        class="filename">crontab</code> 文件的格式</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. 使用 <code
                        class="command">at</code> 命令</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. 调度异步任务：<code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. 配额</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. 备份</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140476752326608">9.10.1. 使用 <code
                        class="command">rsync</code>备份</a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#idm140476752282496">9.10.2. 不使用备份恢复系统</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. 热插拔： <span
                    class="emphasis"><em>热插拔</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140476752262304">9.11.1. 介绍</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140476752251856">9.11.2. 命名问题</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140476752237376">9.11.3.  <span
                        class="emphasis"><em>udev</em></span> 如何工作</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#idm140476746538672">9.11.4. 一个具体例子</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Power Management: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		本章涵盖一些Unix系统共通的服务。管理员应当熟悉他们。
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. 系统启动</h2></div></div></div><a
            id="idm140476764920320"
            class="indexterm"></a><div
            class="para">
			当启动计算机时，控制台上滚动的大量信息显示许多初始化和配置工作自动正在执行。有时候你可能稍稍的改变这一阶段的操作，就要求你需要很好的理解他们。这正是本章节的目的所在。
		</div><div
            class="para">
			First, the BIOS takes control of the computer, detects the disks, loads the <span
              class="emphasis"><em>Master Boot Record</em></span>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <code
              class="command">init</code>. Frequently, this “root partition” and this <code
              class="command">init</code> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Boot sequence of a computer running Linux with systemd" /></div></div><p
              class="title"><strong>图 9.1. Boot sequence of a computer running Linux with systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. The systemd init system</h3></div></div></div><div
              class="para">
				The “real init” is currently provided by <span
                class="pkg pkg">systemd</span> and this section documents this init system.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Before <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span
                  class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span
                  class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the SysV init later on.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>选择</em></span> 其他启动系统 </strong></p></div></div></div><div
                class="para">
				This book describes the boot system used by default in Debian <span
                  class="distribution distribution">Jessie</span> (as implemented by the <span
                  class="pkg pkg">systemd</span> package), as well as the previous default, <span
                  class="pkg pkg">sysvinit</span>, which is derived and inherited from <span
                  class="emphasis"><em>System_V</em></span> Unix systems; there are others.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> is a boot system with a very simple process. It keeps the principle of runlevels, but replaces the directories and symbolic links with a configuration file, which indicates to <code
                  class="command">init</code> the processes that must be started and their launch order.
			</div><div
                class="para">
				The <code
                  class="command">upstart</code> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span
                  class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span
                  class="pkg pkg">sysvinit</span>, and one of the tasks launched by <code
                  class="command">upstart</code> is to launch the scripts written for traditional systems, especially those from the <span
                  class="pkg pkg">sysv-rc</span> package.
			</div><div
                class="para">
				也有其他的系统和操作模式，例如：<code
                  class="command">runit</code>， <code
                  class="command">minit</code>， 或者 <code
                  class="command">initng</code>，但是他们应用相对特殊没有那么普遍。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>特例</em></span> 从网络启动</strong></p></div></div></div><div
                class="para">
				在某些配置中，BIOS 可以配置为不执行 MBR，而是在网络上寻找类似的东西，这样就可以制作不需要硬盘的电脑，在每次启动后可以完全重装。不是所有的硬件都支持该选项，它需要 BIOS 和网卡很好的配合。
			</div><div
                class="para">
				从网络启动可以用于执行 <code
                  class="command">debian-installer</code> or FAI （参考 <a
                  class="xref"
                  href="installation.html#sect.installation-methods">第 4.1 节 “安装方式”</a>）。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>回到基础</em></span>进程，一个程序实例</strong></p></div></div></div><a
                id="idm140476754713360"
                class="indexterm"></a><div
                class="para">
				一个进程代表一个在内存中运行的程序。它包含了需要正确执行软件的所有必要信息（代码本身，内存数据，打开的文件清单，建立的网络连接，等等）。一个程序可能初始化为几个进程，而没必要使用不同的用户 ID 。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>安全</em></span> 使用 shell 作为 <code
                          class="command">init</code> 获取超级用户权限</strong></p></div></div></div><div
                class="para">
				By convention, the first process that is booted is the <code
                  class="command">init</code> program (which is a symbolic link to <code
                  class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code
                  class="literal">init</code> option to the kernel indicating a different program.
			</div><a
                id="idm140476754708032"
                class="indexterm"></a><div
                class="para">
				任何可以接近电脑的人都能按下<span
                  class="keycap"><strong>复位</strong></span> 按，并重新启动。然后，在启动提示下，传递<code
                  class="literal">init=/bin/sh</code>选项给内核，无需知道密码而获取超级用户权限。
			</div><div
                class="para">
				为了防止此类事件，可以给加载器设定密码。你也许会考虑保护 BIOS （密码保护总是可行的），这样可以防止侵入者使用包含自己的 Linux 系统的移动介质启动电脑，使用该系统他们可以读取硬盘上的数据。
			</div><div
                class="para">
				最后，应该知道大多数 BIOS 有一个通用的密码。最初用于让那些忘记自己密码的人解决问题，这些密码现在是公开的并且可以在网上找到（通过搜索引擎搜索“通用 BIOS 密码”）。所有这些保护措施都不太可能完全阻止非授权用户操作机器。如果攻击者能直接接触电脑，就没有可靠的方法保护电脑；他们可以拆下硬盘连到自己的电脑上，甚至是偷走整个机器，或者擦除 BIOS 来重置密码…
			</div></div><div
              class="para">
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> pairs grouped between <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit files are stored under <code
                class="filename">/lib/systemd/system/</code> and <code
                class="filename">/etc/systemd/system/</code>; they come in several flavours, but we'll focus on “services” and “targets” here.
			</div><div
              class="para">
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory way (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here's the service file for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre><div
              class="para">
				As you can see, there's very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</div><div
              class="para">
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code
                class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code
                class="literal">network-online.target</code> and <code
                class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code
                class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</div><div
              class="para">
				The first such utility is <code
                class="command">systemctl</code>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <code
                class="command">systemctl status</code> gives a better view of the services, as well as the related processes. If given the name of a service (as in <code
                class="command">systemctl status ntp.service</code>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</div><div
              class="para">
				Starting a service by hand is a simple matter of running <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. As one can guess, stopping the service is done with <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>; other subcommands include <code
                class="command">reload</code> and <code
                class="command">restart</code>.
			</div><div
              class="para">
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (or <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> allows checking the status of the service.
			</div><div
              class="para">
				An interesting feature of systemd is that it includes a logging component named <code
                class="command">journald</code>. It comes as a complement to more traditional logging systems such as <code
                class="command">syslogd</code>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <code
                class="command">journalctl</code> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Another useful command-line flag is <code
                class="command">-f</code>, which instructs <code
                class="command">journalctl</code> to keep displaying new messages as they are emitted (much in the manner of <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				If a service doesn't seem to be working as expected, the first step to debug the problem are to check that the service is actually running with <code
                class="command">systemctl status</code>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div><div
                class="para">
				We've only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we'll only list a few here:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. In a similar fashion, a “time” unit file describes events that occur on specific times. This allows replicating part of the <code
                        class="command">cron</code> features.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="idm140476750797408"
                class="indexterm"></a> <a
                id="idm140476750796608"
                class="indexterm"></a> <a
                id="idm140476750795808"
                class="indexterm"></a> <a
                id="idm140476750795008"
                class="indexterm"></a>
			</div><div
              class="para">
				其中，你会发现相继的程序会负责：
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						配置控制台键盘；
					</div></li><li
                  class="listitem"><div
                    class="para">
						加载驱动：当探测到硬件，大部分内核模块通过内核自身加载；然后，自动加载 <code
                      class="filename">/etc/modules</code> 中列出的模块；
					</div></li><li
                  class="listitem"><div
                    class="para">
						检查文件系统的完整性；
					</div></li><li
                  class="listitem"><div
                    class="para">
						挂载本地分区；
					</div></li><li
                  class="listitem"><div
                    class="para">
						配置网络；
					</div></li><li
                  class="listitem"><div
                    class="para">
						挂载网络文件系统（NFS）。
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>回到基础</em></span> 内核模块和选项</strong></p></div></div></div><a
                id="idm140476750785776"
                class="indexterm"></a><div
                class="para">
				内核模块也有一些选项，可以通过在 <code
                  class="filename">/etc/modprobe.d/</code> 中放置一些文件配置。这些选项通过诸如此类的语法定义：<code
                  class="literal">选项 <em
                    class="replaceable">模块名字</em> <em
                    class="replaceable">选项名字</em>=<em
                    class="replaceable">选项值</em></code>。如果有必要，一些选项可以通过单独的定向命令指示。
			</div><div
                class="para">
				These configuration files are intended for <code
                  class="command">modprobe</code> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <span
                  class="pkg pkg">kmod</span> package.
			</div><a
                id="idm140476750779984"
                class="indexterm"></a><a
                id="idm140476750778864"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				这种以依赖为基础的启动系统使自动排序成为可能，如果要手工完成则显得冗长乏味，由于调度根据明确给出的参数进行，这样就避免了人为错误。另一个好处是如果两个服务彼此独立，则可以并行启动，进而加速启动过程
			</div><a
              id="idm140476750771488"
              class="indexterm"></a><a
              id="idm140476750770528"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code>分几个运行等级，它可以通过<code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> 命令，从一个等级切换到另一个等级。马上就会在新等级下重新执行<code
                class="command">init</code> executes <code
                class="command">/etc/init.d/rc</code>。这个脚本会启动漏掉的服务并中止不再需要的服务。为了做到这一点，它读取<code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> 文件的内容（此处 <em
                class="replaceable">X</em> 代表新的运行等级）。以“S"（Start的首字母）开头的服务脚本要启动；以“K"（Kill的首字母）开头的服务要停止。脚本不会启动在之前运行等级已经生效的服务。
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						等级０仅作电脑关机时的临时应用。这样，它只包含许多“K”脚本。
					</div></li><li
                  class="listitem"><div
                    class="para">
						等级１，也被称为单用户模式，对应于降级的系统模式；它仅包含基本服务，用于维护，此时不需要与一般用户交互。
					</div></li><li
                  class="listitem"><div
                    class="para">
						等级２用于正常运行，包含网络服务，图形界面，用户登陆，等等。
					</div></li><li
                  class="listitem"><div
                    class="para">
						等级６和等级０类似，不同在于它用于系统重启之前的关机。
					</div></li></ul></div><div
              class="para">
				也存在其他等级，从３到５。默认情况，他们配置为和等级２相同，但是管理员可以修改（通过添加和删除对应<code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>目录下的脚本）它们来适应不同的需求。
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>图 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="idm140476750755424"
              class="indexterm"></a><div
              class="para">
				所有包含在<code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>目录下的脚本都只是符号联接－有<code
                class="command">update-rc.d</code>程序在安装时创建－指向存储在<code
                class="filename">/etc/init.d/</code>中的实际脚本。管理员可以使用调整后的参数重新运行 <code
                class="command">update-rc.d</code> 来微调每个运行等级的服务。<span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span>手册详细介绍了语法。请注意，使用<code
                class="literal">remove</code> 参数移除所有的符号连接不是停用服务的好办法。取而代之的方法是，你可以在特定的运行等级将其配置为不启动（而保留先前等级对应事件的停止调用）。由于<code
                class="command">update-rc.d</code>的接口有些绕，可以考虑使用<code
                class="command">rcconf</code>（出自<span
                class="pkg pkg">rcconf</span> 软件包），它提供了更加友好的界面。
			</div><a
              id="idm140476750748304"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN 策略</em></span> 重启服务</strong></p></div></div></div><a
                id="idm140476750746064"
                class="indexterm"></a><a
                id="idm140476750744944"
                class="indexterm"></a><a
                id="idm140476750743504"
                class="indexterm"></a><div
                class="para">
				Debian 软件包的一些维护脚本有时会重启某些服务以确保其有效并采取某些措施。服务控制命令－ <code
                  class="command">/etc/init.d/<em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code>－不会考虑运行等级，假定（错误地）服务正在使用中，并因此产生错误操作（启动一个有意终止的服务，或者停止已经停止的服务，等等）。因此 Debian 引入了<code
                  class="command">invoke-rc.d</code>程序：该程序只能用于维护脚本启动初始化脚本，而且仅执行必要的命令。注意，与一般应用不同，此处<code
                  class="filename">.d</code> 后缀用于程序名，而不是目录名。
			</div></div><div
              class="para">
				最后，<code
                class="command">init</code>启动各种虚拟控制台的控制程序（<code
                class="command">getty</code>）。显示提示符，等待输入用户名，然后执行<code
                class="command">login <em
                  class="replaceable">user</em></code>发起会话。
			</div><a
              id="idm140476750737008"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>词汇</em></span> 控制台和终端</strong></p></div></div></div><div
                class="para">
				早期的计算机通常被分成几个很大的部分：存储箱和中央处理单元与外围操作员的控制设备相分离。这些部件是单独的装置，即“控制台”。该术语被保留下来，但是其意义改变了。或多或少它已经和“终端”同义，代表键盘和屏幕。
			</div><div
                class="para">
				随着计算机的发展，操作系统提供了许多虚拟终端，从而允许同时存在几个独立的会话，即使是只有一套键盘和屏幕。大部分 GNU/Linux 系统提供六个虚拟终端（在文本模式），通过组合键 <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> 到 <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> 开启。
			</div><div
                class="para">
				推而广之，术语“控制台”和“终端”也代表在X11图形会话中的终端模拟器（类似<code
                  class="command">xterm</code>，<code
                  class="command">gnome-terminal</code> 或者 <code
                  class="command">konsole</code>）。
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>上一页</strong>8.11. Installing a Kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上一级</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>起始页</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>下一页</strong>9.2. 远程登录</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li></ul></div></body></html>
