<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Quelques fonctions remplies par le noyau</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-fr-FR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Noyau, Unix, Processus, Arborescence, Commandes de base" /><link
        rel="home"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Annexe B. Petit cours de rattrapage" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Fonctionnement d'un ordinateur : les différentes couches en jeu" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. L'espace utilisateur" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/fr-FR/sect.kernel-role-and-tasks.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Précédent</strong></a></li><li
          class="home">Le cahier de l'administrateur Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Suivant</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Quelques fonctions remplies par le noyau</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Pilotage du matériel</h3></div></div></div><div
            class="para">
				Le noyau sert d'abord à contrôler les différents composants matériels, les recenser, les mettre en marche lors de l'initialisation de l'ordinateur, etc. Il les rend également disponibles pour les applications de plus haut niveau, avec une interface de programmation simplifiée : les logiciels peuvent ainsi utiliser les périphériques sans se préoccuper de détails de très bas niveau comme l'emplacement dans lequel est enfichée la carte-fille. L'interface de programmation offre également une couche d'abstraction qui sert par exemple à un logiciel de visiophonie pour tirer parti d'une webcam de la même manière quels que soient sa marque et son modèle ; ce logiciel utilise simplement l'interface de programmation V4L (<span
              class="foreignphrase"><em
                class="foreignphrase">Video for Linux</em></span>, le quatre se prononçant comme <span
              class="foreignphrase"><em
                class="foreignphrase">for</em></span> en anglais) et c'est le noyau qui traduira les appels de fonction de cette interface en commandes spécifiques au type de webcam réellement utilisé.
			</div><div
            class="para">
				<a
              id="idm140565663248960"
              class="indexterm"></a> <a
              id="idm140565663248160"
              class="indexterm"></a> <a
              id="idm140565663247360"
              class="indexterm"></a> <a
              id="idm140565663246560"
              class="indexterm"></a> Le noyau exporte de nombreuses informations sur le matériel qu'il a détecté par l'intermédiaire des systèmes de fichiers virtuels <code
              class="filename">/proc/</code> et <code
              class="filename">/sys/</code>. Plusieurs utilitaires synthétisent certaines de ces informations : citons <code
              class="command">lspci</code> (du paquet <span
              class="pkg pkg">pciutils</span>) qui affiche la liste des périphériques PCI connectés, <code
              class="command">lsusb</code> (du paquet <span
              class="pkg pkg">usbutils</span>) qui fait de même avec les périphériques USB et <code
              class="command">lspcmcia</code> (du paquet <span
              class="pkg pkg">pcmciautils</span>) pour les cartes PCMCIA. Ces programmes sont très utiles quand il faut pouvoir identifier de manière certaine le modèle d'un périphérique. En outre, cette identification unique permet de mieux cibler les recherches sur Internet et de trouver plus facilement des documents pertinents.
			</div><div
            class="example"><a
              id="idm140565663240880"></a><p
              class="title"><strong>Exemple B.1. Exemple d'informations fournies par <code
                  class="command">lspci</code> et <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen"><code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Les options <code
              class="literal">-v</code> de ces programmes permettent d'obtenir des informations beaucoup plus détaillées qui ne seront généralement pas nécessaires. Enfin, la commande <code
              class="command">lsdev</code> (du paquet <span
              class="pkg pkg">procinfo</span>) liste les différentes ressources de communication exploitées par les périphériques présents.
			</div><div
            class="para">
				Bien souvent, les applications accèdent aux périphériques par le biais de fichiers spéciaux qui sont créés dans <code
              class="filename">/dev/</code> (voir encadré <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>B.A.-BA</em></span> Droits d'accès à un périphérique</a>). Il existe des fichiers spéciaux qui représentent les disques (par exemple <code
              class="filename">/dev/hda</code> et <code
              class="filename">/dev/sdc</code>), les partitions (<code
              class="filename">/dev/hda1</code> ou <code
              class="filename">/dev/sdc3</code>), la souris (<code
              class="filename">/dev/input/mouse0</code>), le clavier (<code
              class="filename">/dev/input/event0</code>), la carte son (<code
              class="filename">/dev/snd/*</code>), les ports série (<code
              class="filename">/dev/ttyS*</code>), etc.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Systèmes de fichiers</h3></div></div></div><a
            id="idm140565663227312"
            class="indexterm"></a><a
            id="idm140565663226352"
            class="indexterm"></a><div
            class="para">
				Un des aspects les plus visibles du noyau est celui des systèmes de fichiers. Les systèmes Unix intègrent en effet les différentes méthodes de stockage de fichiers dans une arborescence unique, ce qui permet aux utilisateurs (et aux applications) de stocker ou retrouver des données simplement grâce à leur emplacement dans cette arborescence.
			</div><div
            class="para">
				Le point de départ de cette arborescence est la racine, <code
              class="filename">/</code>. Il s'agit d'un répertoire pouvant contenir des sous-répertoires, chacun étant identifié par son nom. Par exemple, le sous-répertoire <code
              class="literal">home</code> de <code
              class="filename">/</code> est noté <code
              class="filename">/home/</code> ; ce sous-répertoire peut à son tour contenir d'autres sous-répertoires et ainsi de suite. Chaque répertoire peut également contenir des fichiers, qui contiendront les données réellement stockées. Le nom de fichier <code
              class="filename">/home/rmas/Bureau/hello.txt</code> désigne ainsi un fichier appelé <code
              class="literal">hello.txt</code>, stocké dans le sous-répertoire <code
              class="literal">Bureau</code> du sous-répertoire <code
              class="literal">rmas</code> du répertoire <code
              class="literal">home</code> présent à la racine. Le noyau fait alors la traduction entre ce système de nommage de fichiers et leur format de stockage physique sur disque.
			</div><div
            class="para">
				Contrairement à d'autres systèmes, cette arborescence est unique et peut intégrer les données de plusieurs disques. L'un de ces disques est alors utilisé comme racine, les autres étant « montés » dans des répertoires de l'arborescence (la commande Unix qui réalise cela est <code
              class="command">mount</code>) ; ces autres disques sont alors accessibles sous ces « points de montage ». On peut ainsi déporter sur un deuxième disque dur les données personnelles des utilisateurs (qui sont traditionnellement stockées dans <code
              class="filename">/home/</code>). Ce disque contiendra alors les répertoires <code
              class="literal">rhertzog</code> et <code
              class="literal">rmas</code>. Une fois le disque monté dans <code
              class="filename">/home/</code>, ces répertoires deviendront accessibles aux emplacements habituels, et on pourra retrouver <code
              class="filename">/home/rmas/Bureau/hello.txt</code>.
			</div><a
            id="idm140565663215712"
            class="indexterm"></a><div
            class="para">
				There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> and <span
              class="emphasis"><em>ext4</em></span>, but others exist. For instance, <span
              class="emphasis"><em>vfat</em></span> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <code
              class="command">mkfs.ext3</code> (where <code
              class="command">mkfs</code> stands for <span
              class="emphasis"><em>MaKe FileSystem</em></span>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <code
              class="filename">/dev/sda1</code>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</div><div
            class="para">
				There are also network filesystems, such as <acronym
              class="acronym">NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Fonctions partagées</h3></div></div></div><div
            class="para">
				Le noyau est également responsable de fonctions utilisées par tous les logiciels et qu'il est judicieux de centraliser ainsi. Ces fonctions incluent notamment la gestion des systèmes de fichiers, permettant à une application d'ouvrir simplement un fichier en fonction de son nom, sans avoir à se préoccuper de l'emplacement physique du fichier (qui peut se trouver morcelé en plusieurs emplacements d'un disque dur, voire entre plusieurs disques durs, ou stocké à distance sur un serveur de fichiers). Il s'agit également de fonctions de communication, que les applications pourront appeler pour échanger des informations à travers le réseau sans se soucier du mode de transport des données (qui pourront transiter sur un réseau local, ou une ligne téléphonique, ou un réseau sans fil, ou une combinaison de tout cela).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Gestion des processus</h3></div></div></div><a
            id="idm140565663204752"
            class="indexterm"></a><div
            class="para">
				Un processus correspond à un programme en cours d'exécution. Ceci inclut une zone de mémoire dans laquelle est stocké le programme lui-même, mais également l'ensemble des données sur lesquelles le programme travaille. Le noyau est responsable de la création des processus et de leur suivi : lorsqu'un programme est lancé, le noyau met de côté cette zone de mémoire qu'il réserve au processus, y charge (depuis le disque) le code du programme et lance l'exécution. Il garde également des informations qui concernent ce processus, notamment un numéro d'identification (<span
              class="foreignphrase"><em
                class="foreignphrase">pid</em></span>, pour <span
              class="foreignphrase"><em
                class="foreignphrase">process identifier</em></span>).
			</div><div
            class="para">
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There's actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they're actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTE</em></span> Systèmes multi-processeurs et assimilés</strong></p></div></div></div><div
              class="para">
				The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <span
                class="emphasis"><em>per processor core</em></span> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes.
			</div></div><div
            class="para">
				Bien entendu, le noyau autorise l'exécution en parallèle de plusieurs processus correspondant au même programme : chacun dispose alors de ses propres intervalles de temps pour s'exécuter, ainsi que de sa zone de mémoire réservée. Comme un processus n'a accès qu'à sa propre zone de mémoire, les données de chacun restent indépendantes.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Gestion des permissions</h3></div></div></div><div
            class="para">
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started the process. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a
              class="xref"
              href="sect.rights-management.html">Section 9.3, « Gestion des droits »</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Précédent</strong>B.3. Fonctionnement d'un ordinateur : les différe...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Niveau supérieur</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Sommaire</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Suivant</strong>B.5. L'espace utilisateur</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li></ul></div></body></html>
