<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. O Espaço de Usuário</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-pt-BR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Processo, Hierarquia, Comandos Básicos" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apêndice B. Curso Rápido de Reparação" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Algumas Tarefas realizadas pelo Núcleo" /><link
        rel="next"
        href="backcover.html"
        title="Apêndice C. O Manual do Administrador Debian" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/sect.user-space.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.user-space"></a>B.5. O Espaço de Usuário</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			"Espaço de usuário" refere-se ao ambiente de execução de processos normais (em oposição aos do núcleo). Isso não significa necessariamente que esses processos foram realmente iniciados por usuários, pois um sistema padrão normalmente tem vários processos "daemon" (serviços) (ou em segundo plano) em execução antes mesmo do usuário abrir uma sessão. Processos daemon também são considerados processos no espaço do usuário.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-basics"></a>B.5.1. Processo</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Quando o núcleo passa por sua fase de inicialização, ele inicia o primeiro de todos os processos, o <code
              class="command">init</code>. O processo #1 sozinho, raramente é útil por si só, e em sistemas similares ao Unix rodam com muitos processos adicionais.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Em primeiro lugar, um processo pode se clonar (isto é conhecido como <span
              class="emphasis"><em>fork</em></span>). O núcleo aloca um novo (mas idêntico) espaço de memória do processo, e um outro processo para usá-lo. Neste momento, a única diferença entre esses dois processos é o <span
              class="emphasis"><em>pid</em></span>. O novo processo é normalmente chamado de processo filho, e o processo original cujo <span
              class="emphasis"><em>pid</em></span> não muda, é chamado de processo pai.
			</div><div
            class="para">
				Às vezes, o processo filho continua a viver de forma independente de seu pai, com os seus próprios dados copiados do processo pai. Em muitos casos, porém, este processo filho executa outro programa. Com poucas exceções, sua memória é simplesmente substituída pela do novo programa, e a execução deste novo programa começa. Esse é o mecanismo usado pelo processo init (com processo número 1) para iniciar serviços adicionais e executar toda a sequência de inicialização. Em algum momento, um dos processos descendentes do <code
              class="command">init</code> inicia uma interface gráfica para os usuários iniciarem sua sessão (a sequência dos eventos é descrita em mais detalhes no <a
              class="xref"
              href="unix-services.html#sect.system-boot">Seção 9.1, “Inicialização do Sistema”</a>).
			</div><div
            class="para">
				Quando um processo termina a tarefa para a qual ele foi iniciado, ele termina. O núcleo então recupera a memória designada para este processo, e pára de dar porções de tempo de execução. O processo pai é avisado de que seu processo filho que está sendo encerrado, o que permite que um processo aguarde a conclusão de uma tarefa delegada a um processo filho. Este comportamento é claramente visível nos interpretadores de linha de comando (conhecidos como <span
              class="emphasis"><em>shells</em></span>). Quando um comando é digitado em um shell, o prompt só volta quando a execução do comando é concluída. A maioria dos shells permite a execução do comando em segundo plano simplesmente adicionando um <strong
              class="userinput"><code>&amp;</code></strong> no final do comando. O prompt volta a ser exibido imediatamente, o que pode ser um problema se o comando deve exibir dados.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.daemons"></a>B.5.2. Daemons</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				Um "daemon" (serviço) é um processo iniciado automaticamente pela sequência de inicialização. Ele continua em execução (em segundo plano) para executar as tarefas de manutenção ou prover serviços a outros processos. Esta "tarefa em segundo plano" é realmente arbitrária e não tem uma importância especial do ponto de vista do sistema. Eles são simplesmente processos, bastante semelhantes a outros processos, que executam quando está em sua porção de tempo. A distinção é apenas na língua humana: dizemos que um processo que é executado sem interação com o usuário (em particular, sem qualquer interface gráfica) está em execução "em segundo plano" ou "como um serviço".
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULÁRIO</em></span> Daemon, demon, um termo depreciativo?</strong></p></div></div></div><div
              class="para">
				Em inglês, utiliza-se o termo <span
                class="emphasis"><em>daemon</em></span> compartilhando sua etimologia grega com <span
                class="emphasis"><em>demônio</em></span>, o que não implica formalmente mal diabólico, ao contrário, deve ser entendido como uma espécie de espírito ajudante. Esta distinção é sutil o suficiente em inglês; é ainda pior em outras línguas em que a mesma palavra é usada para ambos os significados.
			</div></div><div
            class="para">
				Vários desses daemons são descritos em detalhes em <a
              class="xref"
              href="unix-services.html">Capítulo 9, <em>Serviços Unix</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ipc"></a>B.5.3. Comunicação Inter Processos</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				Um processo isolado, seja um daemon ou um aplicativo interativo, raramente é útil por si só, e é por isso que existem vários métodos que permitem a comunicação entre os processos separados, seja para troca de dados ou para controlar um ao outro. O termo genérico que se refere a isso é <span
              class="emphasis"><em>comunicação entre processos</em></span>, ou IPC (Inter-Process Communication) para abreviar.
			</div><div
            class="para">
				O sistema IPC mais simples é utilizar arquivos. O processo que deseja enviar dados escreve-os em um arquivo (com um nome já conhecido), enquanto o destinatário só precisa abrir o arquivo e ler seu conteúdo.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				No caso de você não desejar armazenar dados em disco, você pode usar um <span
              class="emphasis"><em>pipe</em></span> (conexão), que é simplesmente um objeto com duas extremidades; bytes escritos em uma extremidade são legíveis na outra. Se as extremidades são controladas por processos separados, ela se converte em um canal de comunicação entre processos simples e conveniente. Pipes podem ser classificados em duas categorias: pipes nomeados e pipes anônimos. Um pipe nomeado é representado por uma entrada no sistema de arquivos (embora os dados transmitidos não são armazenados lá), para que ambos os processos posam abri-lo de forma independente desde que a localização do pipe nomeado seja conhecida antecipadamente. Nos casos em que os processos se comunicando sejam relacionados (por exemplo, um pai e seu processo filho), o processo pai também pode criar um pipe anônimo antes da bifurcação (fork), e o filho o herda. Assim, ambos os processos serão capazes de trocar dados através do pipe sem a necessidade do sistema de arquivos.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NA PRÁTICA</em></span> Um exemplo concreto</strong></p></div></div></div><div
              class="para">
				Vamos descrever em detalhes o que acontece quando um comando complexo (um <span
                class="emphasis"><em>pipeline</em></span>) é executado a partir de um shell. Vamos assumir que temos um processo <code
                class="command">bash</code> (o shell do usuário padrão no Debian), com <span
                class="emphasis"><em>pid</em></span> 4374; neste shell podemos digitar o comando: <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				O shell primeiro interpreta o comando digitado nele. No nosso caso, ele entende que existem dois programas (<code
                class="command">ls</code> e <code
                class="command">sort</code>), com um fluxo de dados que flui de um para o outro (denotado pelo caractere <strong
                class="userinput"><code>|</code></strong>, conhecido como <span
                class="emphasis"><em>pipe</em></span>). O <code
                class="command">bash</code> primeiro cria um pipe sem nome (que inicialmente só existe dentro do processo <code
                class="command">bash</code> em si).
			</div><div
              class="para">
				Então o shell se clona; isso leva a um novo processo <code
                class="command">bash</code> com <span
                class="emphasis"><em>pid</em></span> #4521 (<span
                class="emphasis"><em>pids</em></span> são números abstratos e geralmente não têm significado particular). O processo #4521 herda o pipe, o que significa que é capaz de escrever em seu lado de "entrada"; o <code
                class="command">bash</code> redireciona seu fluxo de saída padrão para a entrada deste pipe. Em seguida, ele executa (e substitui-se com) o <code
                class="command">ls</code> do programa, que lista o conteúdo do diretório atual. Como o <code
                class="command">ls</code> escreve em sua saída padrão, e anteriormente se direcionou esta saída, seus resultados são efetivamente enviados para o pipe.
			</div><div
              class="para">
				Uma operação similar acontece para o segundo comando: o<code
                class="command">bash</code> se clona novamente, levando a um novo processo <code
                class="command">bash</code> com pid #4522. Como também é um processo filho do #4374, também herda o pipe; em seguida o <code
                class="command">bash</code> conecta sua entrada padrão com a saída do pipe, então executa (e substitui a si mesmo com) o comando <code
                class="command">sort</code>, que classifica sua entrada e exibe os resultados.
			</div><div
              class="para">
				Todas as peças do quebra-cabeça agora estão definidas: o <code
                class="command">ls</code> lê o diretório atual e escreve a lista de arquivos dentro do pipe; o <code
                class="command">sort</code> lê esta lista, classifica-a em ordem alfabética e exibe os resultados. Os processos números #4521 e #4522 encerram, e o #4374 (que estava esperando por eles durante a operação), retoma o controle e exibe o prompt permitindo que o usuário digite um novo comando.
			</div></div><div
            class="para">
				No entanto, nem todas as comunicações entre processos são usadas para mover dados. Em muitas situações, a única informação que deve ser transmitida são mensagens de controle tais como "execução em pausa" ou "retomar execução". O Unix (e Linux) fornece um mecanismo conhecido como <span
              class="emphasis"><em>sinais</em></span>, através do qual um processo pode simplesmente enviar um sinal específico (escolhido dentro de uma lista pré-definida de sinais) para outro processo. O único requisito é saber o <span
              class="emphasis"><em>pid</em></span> do alvo.
			</div><div
            class="para">
				Para comunicações mais complexas também existem mecanismos que permitem que um processo abra o acesso, ou compartilhe, parte da memória alocada para outros processos. A memória agora compartilhada entre eles pode ser usada para mover dados entre os processos.
			</div><div
            class="para">
				Finalmente, as conexões de rede também podem ajudar a comunicação de processos; esses processos podem até ser executados em diferentes computadores, possivelmente a milhares de quilômetros de distância.
			</div><div
            class="para">
				É bastante normal para um típico sistema similar ao Unix fazer uso de todos esses mecanismos em vários graus.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.libraries"></a>B.5.4. Bibliotecas</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Bibliotecas de funções desempenham um papel crucial em um sistema operacional similar ao Unix. Elas não são programas propriamente ditos, uma vez que não podem ser executadas por si próprias, mas coleções de fragmentos de código que podem ser utilizados pelos programas normais. Entre as bibliotecas comuns, você pode encontrar:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						a biblioteca padrão C (<span
                    class="emphasis"><em>glibc</em></span>), que contém as funções básicas como aquelas para abrir arquivos ou conexões de rede, e outras que facilitam as interações com o kernel;
					</div></li><li
                class="listitem"><div
                  class="para">
						toolkits gráficos, como Gtk+ e Qt, permitindo que muitos programas reutilizem os objetos gráficos que eles fornecem;
					</div></li><li
                class="listitem"><div
                  class="para">
						a biblioteca <span
                    class="emphasis"><em>libpng</em></span> que permite carregar, interpretar e salvar imagens no formato PNG.
					</div></li></ul></div><div
            class="para">
				Graças a essas bibliotecas, as aplicações podem reutilizar o código existente. O desenvolvimento de aplicações é simplificado já que muitas aplicações podem reutilizar as mesmas funções. Como as bibliotecas são geralmente desenvolvidas por pessoas diferentes, o desenvolvimento global do sistema está mais perto da filosofia histórica do Unix.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> O Estilo Unix: uma coisa de cada vez</strong></p></div></div></div><div
              class="para">
				Um dos conceitos fundamentais da família de sistemas operacionais Unix é que cada ferramenta deve fazer uma coisa, e fazê-lo bem; aplicações podem reutilizar essas ferramentas para criar uma lógica mais avançada sobre elas. Essa filosofia pode ser vista em muitas encarnações. Shell scripts podem ser o melhor exemplo: eles montam sequências complexas de ferramentas muito simples (como <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code> e assim por diante). Outra implementação dessa filosofia pode ser vista em bibliotecas de código: a biblioteca <span
                class="emphasis"><em>libpng</em></span> permite ler e escrever imagens PNG, com diferentes opções e de maneiras diferentes, mas ela faz só isso; nenhuma questão de incluir funções que exibem ou editam imagens.
			</div></div><div
            class="para">
				Além disso, essas bibliotecas muitas vezes são chamadas de "bibliotecas compartilhadas", já que o núcleo pode carregá-las apenas uma vez para a memória, mesmo se vários processos utilizam a mesma biblioteca ao mesmo tempo. Isso permite economia de memória, quando comparado com a situação oposta (hipotética), onde o código para uma biblioteca seria carregado tantas vezes quantos os processos que a utilizam.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Anterior</strong>B.4. Algumas Tarefas realizadas pelo Núcleo</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Próxima</strong>Apêndice C. O Manual do Administrador Debian</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.user-space.html">ar-MA</a></li><li><a
              href="../da-DK/sect.user-space.html">da-DK</a></li><li><a
              href="../de-DE/sect.user-space.html">de-DE</a></li><li><a
              href="../el-GR/sect.user-space.html">el-GR</a></li><li><a
              href="../en-US/sect.user-space.html">en-US</a></li><li><a
              href="../es-ES/sect.user-space.html">es-ES</a></li><li><a
              href="../fa-IR/sect.user-space.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.user-space.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.user-space.html">hr-HR</a></li><li><a
              href="../id-ID/sect.user-space.html">id-ID</a></li><li><a
              href="../it-IT/sect.user-space.html">it-IT</a></li><li><a
              href="../ja-JP/sect.user-space.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.user-space.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.user-space.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.user-space.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.user-space.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.user-space.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.user-space.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.user-space.html">tr-TR</a></li><li><a
              href="../vi-VN/sect.user-space.html">vi-VN</a></li><li><a
              href="../zh-CN/sect.user-space.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.user-space.html">zh-TW</a></li></ul></div></body></html>
