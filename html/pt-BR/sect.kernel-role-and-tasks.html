<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Algumas Tarefas realizadas pelo Núcleo</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Processo, Hierarquia, Comandos Básicos" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apêndice B. Curso Rápido de Reparação" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Funcionamento Interno de um Computador: as Diferentes Camadas Envolvidas" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. O Espaço de Usuário" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/sect.kernel-role-and-tasks.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Algumas Tarefas realizadas pelo Núcleo</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Controlando o Hardware</h3></div></div></div><div
            class="para">
				O kernel tem, em primeiro lugar, a tarefa de controlar as partes do hardware, detectando-os, trocando-os quando o computador é ligado, e assim por diante. Também torna disponíveis para o software de alto nível com uma interface de programação simplificada, para que os aplicativos possam tirar proveito de dispositivos sem ter que se preocupar com detalhes como qual slot de extensão a placa opcional estiver conectada. A interface de programação também fornece uma camada de abstração; isso permite que o software de videoconferência, por exemplo, usar uma webcam independentemente da sua marca e modelo. O software pode apenas usar a interface <span
              class="emphasis"><em>Vídeo for Linux</em></span> (V4L), e o kernel traduz as chamadas de função desta interface para os comandos de hardware reais necessários pela webcam específica em uso.
			</div><div
            class="para">
				<a
              id="id-1.21.7.2.3.1"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.2"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.3"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.4"
              class="indexterm"></a> O kernel exporta muitos detalhes sobre o hardware detectado através dos sistemas de arquivos virtuais <code
              class="filename">/proc/</code> e <code
              class="filename">/sys/</code>. Várias ferramentas resumem esses detalhes. Entre elas, o <code
              class="command">lspci</code> (no pacote <span
              class="pkg pkg">pciutils</span>) lista os dispositivos PCI, <code
              class="command">lsusb</code> (no pacote <span
              class="pkg pkg">usbutils</span>) lista os dispositivos USB e <code
              class="command">lspcmcia</code> (no pacote <span
              class="pkg pkg">pcmciautils</span>) lista de cartões PCMCIA. Estas ferramentas são muito úteis para a identificação do modelo exato de um dispositivo. Esta identificação permite também pesquisas mais precisas na web, que por sua vez, levam a documentos mais relevantes.
			</div><div
            class="example"><a
              id="id-1.21.7.2.4"></a><p
              class="title"><strong>Exemplo B.1. Exemplo de informação provida pelo <code
                  class="command">lspci</code> e <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Estes programas têm uma opção <code
              class="literal">-v</code>, que lista informações com muito mais detalhes (mas geralmente não é necessário). Finalmente, o comando <code
              class="command">lsdev</code> (no pacote <span
              class="pkg pkg">procinfo</span>) lista os recursos de comunicação usados pelos dispositivos.
			</div><div
            class="para">
				As aplicações acessam frequentemente os dispositivos por meio de arquivos especiais criados dentro de <code
              class="filename">/dev/</code> (veja a barra lateral <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> Permissão de acesso a dispositivos</a>). Estes são arquivos especiais que representam as unidades de disco (por exemplo, <code
              class="filename">/dev/hda</code> e <code
              class="filename">/dev/sdc</code>), partições (<code
              class="filename">/dev/hda1</code> ou <code
              class="filename">/dev/sdc3</code>), mouses (<code
              class="filename">/dev/input/mouse0</code>), teclados (<code
              class="filename">/dev/input/event0</code>), placas de som (<code
              class="filename">/dev/snd/*</code>), portas seriais (<code
              class="filename">/dev/ttyS*</code>), e assim por diante.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Sistema de Arquivos</h3></div></div></div><a
            id="id-1.21.7.3.2"
            class="indexterm"></a><a
            id="id-1.21.7.3.3"
            class="indexterm"></a><div
            class="para">
				Os sistemas de arquivos são um dos aspectos mais importantes do kernel. Sistemas Unix agrupam todos os arquivos que armazenam em uma hierarquia única, que permite aos usuários (e as aplicações) a acessar os dados simplesmente por saber a sua localização dentro dessa hierarquia.
			</div><div
            class="para">
				O ponto de partida desta árvore hierárquica é chamado de raiz, <code
              class="filename">/</code>. Este diretório pode conter subdiretórios nomeados. Por exemplo, o subdiretório <code
              class="literal">home</code> do <code
              class="filename">/</code> é chamado <code
              class="filename">/home/</code>. Este subdiretório pode, por sua vez, contêm outros subdiretórios, e assim por diante. Cada diretório também pode conter arquivos, onde os dados reais serão armazenados. Assim, o nome <code
              class="filename">/home/rmas/Desktop/hello.txt</code> refere-se a um arquivo chamado <code
              class="literal">hello.txt</code> armazenado no subdiretório <code
              class="literal">Desktop</code>, subdiretório do <code
              class="literal">rmas</code>, subdiretório de <code
              class="literal">home</code>, diretório presente na raiz. O kernel traduz entre este sistema de nomenclatura e o armazenamento real e física no disco.
			</div><div
            class="para">
				Ao contrário de outros sistemas, só há uma hierarquia deste tipo, e pode integrar dados de vários discos. Um desses discos é usado como a raiz, e os outros são "montados" em diretórios na hierarquia (o comando Unix é chamado <code
              class="command">mount</code>); esses outros discos estarão disponíveis sob estes "pontos de montagem". Isso permite o armazenamento do diretório principal dos usuários (tradicionalmente armazenados dentro de <code
              class="filename">/home/</code>) em um segundo disco rígido, que irá conter os diretórios <code
              class="literal">rhertzog</code> e <code
              class="literal">rmas</code>. Depois que o disco é montado em <code
              class="filename">/home/</code>, esses diretórios estarão disponíveis em seus locais habituais e caminhos como <code
              class="filename">/home/rmas/Desktop/hello.txt</code> continuaram funcionando.
			</div><a
            id="id-1.21.7.3.7"
            class="indexterm"></a><div
            class="para">
				Existem muitos formatos de sistemas de arquivo que corresponde a muitas formas de armazenamento físico de dados nos discos. O mais conhecido são o <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> e o <span
              class="emphasis"><em>ext4</em></span>, mas existem outros. Por exemplo, o <span
              class="emphasis"><em>vfat</em></span> é o sistema que foi historicamente usado pelos sistemas operacionais DOS e Windows, que permite utilizar os discos rígidos tanto no Debian como no Windows. Em qualquer caso, um sistema de arquivos deve ser preparado em um disco antes que ele possa ser montado e esta operação é conhecida como "formatação". Comandos como <code
              class="command">mkfs.ext3</code> (onde <code
              class="command">mkfs</code> é <span
              class="emphasis"><em>MaKe FileSystem</em></span> - criar sistema de arquivos) fazem a formatação. Estes comandos exigem, como um parâmetro, um arquivo de dispositivo que representa a partição a ser formatada (por exemplo, <code
              class="filename">/dev/sda1</code>). Esta operação é destrutiva e só deve ser executado uma vez, exceto se queira limpar deliberadamente um sistema de arquivos e começar de novo.
			</div><div
            class="para">
				Há também sistemas de arquivos de rede, como o <acronym
              class="acronym">NFS</acronym>, em que os dados não são armazenados em um disco local. Em vez disso, os dados são transmitidos através da rede para um servidor que os armazena e recupera sob demanda. A abstração de sistema de arquivos evita que os usuários de cuidar: arquivos permanecem acessíveis na sua forma hierárquica usual.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Funções Compartilhadas</h3></div></div></div><div
            class="para">
				Uma vez que uma quantidade das mesmas funções são usadas por todos os softwares, não faz sentido centralizá-las no kernel. Por exemplo, a gestão do sistema de arquivos compartilhado permite qualquer aplicativo simplesmente abrir um arquivo pelo nome, sem precisar se preocupar onde o arquivo está armazenado fisicamente. O arquivo pode ser armazenado em diferentes partes em um disco rígido, ou dividido em vários discos rígidos, ou mesmo armazenados em um servidor de arquivos remoto. As funções de comunicação compartilhadas são usadas por aplicativos para troca de dados de forma independente da forma como os dados são transportados. Por exemplo, o transporte poderia ser sobre qualquer combinação de redes locais sem fio ou através de uma linha telefônica.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Gerenciamento de Processos</h3></div></div></div><a
            id="id-1.21.7.5.2"
            class="indexterm"></a><div
            class="para">
				Um processo é uma instância em execução de um programa. Isso requer memória para armazenar tanto o próprio programa quanto seus dados operacionais. O kernel é responsável pela criação e acompanhá-los. Quando um programa é executado, o kernel primeiro reserva alguma memória, em seguida carrega o código executável do sistema de arquivos para ele, e então começa a execução do código. Ele mantém informações sobre este processo, o mais visível é um número de identificação conhecido como <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span> - identificador de processo).
			</div><div
            class="para">
				Kernels tipo Unix (incluindo o Linux), como a maioria dos outros sistemas operacionais modernos, são capazes de "multitarefa". Em outras palavras, eles permitem a execução de vários processos "ao mesmo tempo". Na verdade, há apenas um processo em execução em qualquer momento, mas o kernel divide o tempo em pequenas porções e executa cada processo de cada vez. Uma vez que estas porções de tempo são muito curtas (com intervalo em milissegundos), eles criam a ilusão de processos em execução em paralelo, embora estejam, na verdade, somente ativo durante alguns intervalos de tempo e ociosos no resto do tempo. O trabalho do kernel é ajustar seus mecanismos de agendamento para manter essa ilusão, enquanto maximiza o desempenho do sistema global. Se as porções de tempo são muito longas, o aplicativo pode não parecer responsivo como desejado. Se são muito curtas, o sistema perde tempo trocando entre as tarefas com muita frequência. Estas decisões podem ser ajustadas pelas prioridades do processo. Os processos de alta prioridade serão executados por porções de tempo mais longas e mais frequentes do que os processos de baixa prioridade.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Sistemas multiprocessados (e suas variantes)</strong></p></div></div></div><div
              class="para">
				A restrição descrita acima, de apenas um processo sendo capaz de rodar de cada vez, nem sempre é aplicável. A restrição real é que só pode haver um processo de execução <span
                class="emphasis"><em>por núcleo de processador</em></span> de cada vez. Sistemas multiprocessador, multi-core ou "hiper-thread" permitem que vários processos executem em paralelo. O mesmo sistema de divisão de tempo ainda é usado, no entanto, de forma a lidar com casos em que existem mais processos ativos do que núcleos de processador disponíveis. Isto está longe de ser incomum: um sistema básico, ainda que na maior parte inativo, quase sempre tem dezenas de processos em execução.
			</div></div><div
            class="para">
				Claro que, o núcleo permite a execução de várias instâncias independentes do mesmo programa. Mas cada um só pode acessar os seus próprios intervalos de tempo e memória. Assim seus dados se mantém independentes.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Gerenciamento de Direitos</h3></div></div></div><div
            class="para">
				Sistemas similares ao Unix também são multiusuário. Eles fornecem um sistema de gerenciamento de direitos que permite grupos e usuários separados; ele também permite controle sobre ações com base em permissões. O kernel gerencia dados de cada processo, permitindo-lhe controlar as permissões. Na maioria das vezes, um processo é identificado pelo usuário que o iniciou. Esse processo só é capaz de agir de acordo com as permissões disponíveis para seu dono. Por exemplo, tentar abrir um arquivo requer que o kernel verifique a identidade do processo em relação as permissões de acesso (para mais detalhes sobre este exemplo em particular, veja <a
              class="xref"
              href="sect.rights-management.html">Seção 9.3, “Gerenciando Direitos”</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong>B.3. Funcionamento Interno de um Computador: as D...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Próxima</strong>B.5. O Espaço de Usuário</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../ko-KR/sect.kernel-role-and-tasks.html">ko-KR</a></li><li><a
              href="../nb-NO/sect.kernel-role-and-tasks.html">nb-NO</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li><li><a
              href="../zh-TW/sect.kernel-role-and-tasks.html">zh-TW</a></li></ul></div></body></html>
