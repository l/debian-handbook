<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Algumas Tarefas Manejadas pelo Núcleo</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Processo, Hierarquia, Comandos Básicos" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apêndice B. Curso Rápido de Reparação" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Funcionamento Interno de um Computador: as Diferentes Camadas Envolvidas" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. O Espaço de Usuário" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/sect.kernel-role-and-tasks.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.kernel-role-and-tasks"></a>B.4. Algumas Tarefas Manejadas pelo Núcleo</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.hardware-drivers"></a>B.4.1. Controlando o Hardware</h3></div></div></div><div
            class="para">
				O kernel tem, em primeiro lugar, a tarefa de controlar as partes do hardware, detectando-os, trocando-os quando o computador é ligado, e assim por diante. Também torna disponíveis para o software de alto nível com uma interface de programação simplificada, para que os aplicativos possam tirar proveito de dispositivos sem ter que se preocupar com detalhes como qual slot de extensão a placa opcional estiver conectada. A interface de programação também fornece uma camada de abstração; isso permite que o software de videoconferência, por exemplo, usar uma webcam independentemente da sua marca e modelo. O software pode apenas usar a interface <span
              class="emphasis"><em>Vídeo for Linux</em></span> (V4L), e o kernel traduz as chamadas de função desta interface para os comandos de hardware reais necessários pela webcam específica em uso.
			</div><div
            class="para">
				<a
              id="idm140035049729216"
              class="indexterm"></a> <a
              id="idm140035049728416"
              class="indexterm"></a> <a
              id="idm140035049727616"
              class="indexterm"></a> <a
              id="idm140035049726816"
              class="indexterm"></a> O kernel exporta muitos detalhes sobre o hardware detectado através dos sistemas de arquivos virtuais <code
              class="filename">/proc/</code> e <code
              class="filename">/sys/</code>. Várias ferramentas resumem esses detalhes. Entre elas, o <code
              class="command">lspci</code> (no pacote <span
              class="pkg pkg">pciutils</span>) lista os dispositivos PCI, <code
              class="command">lsusb</code> (no pacote <span
              class="pkg pkg">usbutils</span>) lista os dispositivos USB e <code
              class="command">lspcmcia</code> (no pacote <span
              class="pkg pkg">pcmciautils</span>) lista de cartões PCMCIA. Estas ferramentas são muito úteis para a identificação do modelo exato de um dispositivo. Esta identificação permite também pesquisas mais precisas na web, que por sua vez, levam a documentos mais relevantes.
			</div><div
            class="example"><a
              id="idm140035049721216"></a><p
              class="title"><strong>Exemplo B.1. Exemplo de informação provida pelo <code
                  class="command">lspci</code> e <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				Estes programas têm uma opção <code
              class="literal">-v</code>, que lista informações com muito mais detalhes (mas geralmente não é necessário). Finalmente, o comando <code
              class="command">lsdev</code> (no pacote <span
              class="pkg pkg">procinfo</span>) lista os recursos de comunicação usados pelos dispositivos.
			</div><div
            class="para">
				As aplicações acessam frequentemente os dispositivos por meio de arquivos especiais criados dentro de <code
              class="filename">/dev/</code> (veja a barra lateral <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> Permissão de acesso a dispositivos</a>). Estes são arquivos especiais que representam as unidades de disco (por exemplo, <code
              class="filename">/dev/hda</code> e <code
              class="filename">/dev/sdc</code>), partições (<code
              class="filename">/dev/hda1</code> ou <code
              class="filename">/dev/sdc3</code>), mouses (<code
              class="filename">/dev/input/mouse0</code>), teclados (<code
              class="filename">/dev/input/event0</code>), placas de som (<code
              class="filename">/dev/snd/*</code>), portas seriais (<code
              class="filename">/dev/ttyS*</code>), e assim por diante.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.filesystems"></a>B.4.2. Sistema de Arquivos</h3></div></div></div><a
            id="idm140035049707600"
            class="indexterm"></a><a
            id="idm140035049706640"
            class="indexterm"></a><div
            class="para">
				Os sistemas de arquivos são um dos aspectos mais importantes do kernel. Sistemas Unix agrupam todos os arquivos que armazenam em uma hierarquia única, que permite aos usuários (e as aplicações) a acessar os dados simplesmente por saber a sua localização dentro dessa hierarquia.
			</div><div
            class="para">
				O ponto de partida desta árvore hierárquica é chamado de raiz, <code
              class="filename">/</code>. Este diretório pode conter subdiretórios nomeados. Por exemplo, o subdiretório <code
              class="literal">home</code> do <code
              class="filename">/</code> é chamado <code
              class="filename">/home/</code>. Este subdiretório pode, por sua vez, contêm outros subdiretórios, e assim por diante. Cada diretório também pode conter arquivos, onde os dados reais serão armazenados. Assim, o nome <code
              class="filename">/home/rmas/Desktop/hello.txt</code> refere-se a um arquivo chamado <code
              class="literal">hello.txt</code> armazenado no subdiretório <code
              class="literal">Desktop</code>, subdiretório do <code
              class="literal">rmas</code>, subdiretório de <code
              class="literal">home</code>, diretório presente na raiz. O kernel traduz entre este sistema de nomenclatura e o armazenamento real e física no disco.
			</div><div
            class="para">
				Ao contrário de outros sistemas, só há uma hierarquia deste tipo, e pode integrar dados de vários discos. Um desses discos é usado como a raiz, e os outros são "montados" em diretórios na hierarquia (o comando Unix é chamado <code
              class="command">mount</code>); esses outros discos estarão disponíveis sob estes "pontos de montagem". Isso permite que os diretórios de armazenamento dos usuários (tradicionalmente armazenados dentro de <code
              class="filename">/home/</code>) em um segundo disco rígido, que irá conter os diretórios <code
              class="literal">rhertzog</code> e <code
              class="literal">rmas</code>. Depois que o disco é montado em <code
              class="filename">/home/</code>, esses diretórios estarão disponíveis a seus locais habituais e os caminhos como <code
              class="filename">/home/rmas/Desktop/hello.txt</code> continuam funcionando.
			</div><a
            id="idm140035049696448"
            class="indexterm"></a><div
            class="para">
				There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> and <span
              class="emphasis"><em>ext4</em></span>, but others exist. For instance, <span
              class="emphasis"><em>vfat</em></span> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <code
              class="command">mkfs.ext3</code> (where <code
              class="command">mkfs</code> stands for <span
              class="emphasis"><em>MaKe FileSystem</em></span>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <code
              class="filename">/dev/sda1</code>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</div><div
            class="para">
				There are also network filesystems, such as <acronym
              class="acronym">NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.shared-functions"></a>B.4.3. Funções Compartilhadas</h3></div></div></div><div
            class="para">
				Uma vez que uma quantidade das mesmas funções são usadas por todos os softwares, não faz sentido centralizá-las no kernel. Por exemplo, a gestão do sistema de arquivos compartilhado permite qualquer aplicativo simplesmente abrir um arquivo pelo nome, sem precisar se preocupar onde o arquivo está armazenado fisicamente. O arquivo pode ser armazenado em diferentes partes em um disco rígido, ou dividido em vários discos rígidos, ou mesmo armazenados em um servidor de arquivos remoto. As funções de comunicação compartilhadas são usadas por aplicativos para troca de dados de forma independente da forma como os dados são transportados. Por exemplo, o transporte poderia ser sobre qualquer combinação de redes locais sem fio ou através de uma linha telefônica.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.process-management"></a>B.4.4. Gerenciamento de Processos</h3></div></div></div><a
            id="idm140035049685616"
            class="indexterm"></a><div
            class="para">
				Um processo é uma instância em execução de um programa. Isso requer memória para armazenar tanto o próprio programa quanto seus dados operacionais. O kernel é responsável pela criação e acompanhá-los. Quando um programa é executado, o kernel primeiro reserva alguma memória, em seguida carrega o código executável do sistema de arquivos para ele, e então começa a execução do código. Ele mantém informações sobre este processo, o mais visível é um número de identificação conhecido como <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span> - identificador de processo).
			</div><div
            class="para">
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There's actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they're actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Sistemas multiprocessados (e suas variantes)</strong></p></div></div></div><div
              class="para">
				The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <span
                class="emphasis"><em>per processor core</em></span> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes.
			</div></div><div
            class="para">
				Claro que, o núcleo permite a execução de várias instâncias independentes do mesmo programa. Mas cada um só pode acessar os seus próprios intervalos de tempo e memória. Assim seus dados se mantém independentes.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.permissions"></a>B.4.5. Gerenciamento de Direitos</h3></div></div></div><div
            class="para">
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started the process. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a
              class="xref"
              href="sect.rights-management.html">Seção 9.3, “Gerenciando Direitos”</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>Anterior</strong>B.3. Funcionamento Interno de um Computador: as D...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>Próxima</strong>B.5. O Espaço de Usuário</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.kernel-role-and-tasks.html">ar-MA</a></li><li><a
              href="../da-DK/sect.kernel-role-and-tasks.html">da-DK</a></li><li><a
              href="../de-DE/sect.kernel-role-and-tasks.html">de-DE</a></li><li><a
              href="../el-GR/sect.kernel-role-and-tasks.html">el-GR</a></li><li><a
              href="../en-US/sect.kernel-role-and-tasks.html">en-US</a></li><li><a
              href="../es-ES/sect.kernel-role-and-tasks.html">es-ES</a></li><li><a
              href="../fa-IR/sect.kernel-role-and-tasks.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.kernel-role-and-tasks.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.kernel-role-and-tasks.html">hr-HR</a></li><li><a
              href="../id-ID/sect.kernel-role-and-tasks.html">id-ID</a></li><li><a
              href="../it-IT/sect.kernel-role-and-tasks.html">it-IT</a></li><li><a
              href="../ja-JP/sect.kernel-role-and-tasks.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.kernel-role-and-tasks.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.kernel-role-and-tasks.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.kernel-role-and-tasks.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.kernel-role-and-tasks.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.kernel-role-and-tasks.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.kernel-role-and-tasks.html">zh-CN</a></li></ul></div></body></html>
