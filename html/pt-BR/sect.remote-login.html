<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Login remoto</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.1" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="Inicialização do Sistema, Initscripts, SSH, Telnet, Direitos, Permissões, Supervisão, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Capítulo 9. Serviços Unix" /><link
        rel="prev"
        href="unix-services.html"
        title="Capítulo 9. Serviços Unix" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Gerenciando Direitos" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/sect.remote-login.html" /></head><body
      class="draft "><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="http://debian-handbook.info"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  id="sect.remote-login"></a>9.2. Login remoto</h2></div></div></div><div
          class="para">
			É essencial para o administrador ser capaz de se conectar a um computador remotamente. Servidores, confinados em seu quarto, raramente são equipados com permanentes teclados e monitores — mas eles estão conectados à rede.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> Cliente, servidor</strong></p></div></div></div><a
            id="idm140194928359920"
            class="indexterm"></a><a
            id="idm140194928358512"
            class="indexterm"></a><div
            class="para">
			Um sistema onde vários processos comunicarem é frequentemente descrito com a metáfora de "cliente/servidor". O servidor é o programa que recebe as solicitações provenientes de um cliente e os executa. É o cliente que controla as operações, o servidor não toma qualquer iniciativa própria.
		</div></div><a
          id="idm140194928356176"
          class="indexterm"></a><a
          id="idm140194928354736"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.ssh"></a>9.2.1. Login remoto seguro: SSH</h3></div></div></div><a
            id="idm140194928352752"
            class="indexterm"></a><a
            id="idm140194928351792"
            class="indexterm"></a><div
            class="para">
				O protocolo <span
              class="emphasis"><em>SSH</em></span> (Secure SHell) foi projetado com segurança e confiabilidade em mente. Conexões usando SSH estão seguras: o parceiro é autenticado e todas as trocas de dados criptografadas.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> Telnet e RSH estão obsoletos</strong></p></div></div></div><a
              id="idm140194928348624"
              class="indexterm"></a><a
              id="idm140194928347504"
              class="indexterm"></a><div
              class="para">
				Antes do SSH, <span
                class="emphasis"><em>Telnet</em></span> e <span
                class="emphasis"><em>RSH</em></span> eram as principais ferramentas usadas para fazer login remotamente. Elas são agora totalmente obsoletas e não devem mais ser usadas, mesmo que o Debian ainda forneça elas.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULÁRIO</em></span> Autenticação, criptografia</strong></p></div></div></div><div
              class="para">
				Quando você precisar dar um cliente a capacidade de conduzir ou desencadear ações em um servidor, a segurança é importante. Você deve garantir a identidade do cliente; Esta é a autenticação. Esta identidade geralmente consiste de uma senha que deve ser mantida em segredo, ou qualquer outro cliente pode obter a senha. Este é o propósito da criptografia, que é uma forma de codificação que permite que dois sistemas de comunicação de informações confidenciais sobre um canal público, protegendo-o de ser lido por outros.
			</div><div
              class="para">
				Autenticação e criptografia, muitas vezes são mencionados juntos, porque eles são freqüentemente usados em conjunto, tanto porque eles geralmente são implementados com conceitos matemáticos semelhantes.
			</div></div><div
            class="para">
				SSH também oferece dois serviços de transferência de arquivo. <code
              class="command">scp</code> é uma ferramenta de linha de comando que pode ser usada como <code
              class="command">cp</code>, exceto que qualquer caminho a outra máquina é prefixado com o nome da máquina, seguido por dois-pontos.
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp file machine:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> é um comando interativo, semelhante ao <code
              class="command">ftp</code>. Em uma única sessão, o <code
              class="command">sftp</code> pode transferir vários arquivos, e com ele é possível manipular arquivos remotos (apagar, renomear, alterar permissões, etc.).
			</div><a
            id="idm140194928337120"
            class="indexterm"></a><a
            id="idm140194928336000"
            class="indexterm"></a><div
            class="para">
				O Debian usa o OpenSSH, uma versão livre do SSH mantido pelo projeto <code
              class="command">OpenBSD</code> (um sistema operacional livre baseado no kernel BSD, focado em segurança) e uma bifurcação do programa original SSH desenvolvido pela empresa SSH Communications Security Corp, da Finlândia. Esta empresa desenvolveu inicialmente o SSH como software livre, mas num dado momento decidiu continuar o seu desenvolvimento sob uma licença proprietária. O projeto OpenBSD criou então o OpenSSH para manter uma versão gratuita do SSH.
			</div><a
            id="idm140194928333536"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">Fork</em></span></strong></p></div></div></div><a
              id="idm140194928331136"
              class="indexterm"></a><div
              class="para">
				Uma "divisão" ("fork"), na área de software, significa um novo projeto que se inicia como um clone de um projeto existente, e que vai competir com ele. A partir daí, ambos os softwares irão divergir rapidamente em termos de novos desenvolvimentos. Uma divisão é frequentemente o resultado de divergências dentro da equipe de desenvolvimento.
			</div><div
              class="para">
				A opção de dividir um projeto é um resultado direto da própria natureza do software livre, uma divisão é um evento saudável, quando se permite a continuação de um projeto como software livre (por exemplo, em caso de alterações de licença). Uma divisão decorrente de divergências técnicas ou pessoais é muitas vezes um desperdício de recursos humanos; outra resolução seria preferível. Fusões de dois projetos que já passaram por uma divisão anterior não são desconhecidos.
			</div></div><div
            class="para">
				O OpenSSH é dividido em dois pacotes. A parte do cliente está no pacote <span
              class="pkg pkg">openssh-client</span>, e o pacote do servidor está no <span
              class="pkg pkg">openssh-server</span>. O meta-pacote <span
              class="pkg pkg">ssh</span> depende de ambas as partes e facilita a instalação de ambos (<code
              class="command">apt-get install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Autenticação Baseado em Chave</h4></div></div></div><div
              class="para">
					Cada vez que alguém se conecta por SSH, o servidor remoto pede uma senha para autenticar o usuário. Isto pode ser problemático se você quiser automatizar uma conexão, ou se você usar uma ferramenta que requer conexões frequentes com o SSH. Por este motivo que o SSH oferece um sistema de autenticação baseado em chave.
				</div><div
              class="para">
					O usuário gera um par de chaves na máquina cliente com <code
                class="command">ssh-keygen -t rsa</code>; a chave pública é armazenada em <code
                class="filename">~/.ssh/id_rsa.pub</code>,enquanto o chave privada correspondente é armazenada em <code
                class="filename">~/.ssh/id_rsa</code>.O usuário em seguida usa <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> para adicionar a sua chave pública no servidor <code
                class="filename">~/.ssh/authorized_keys</code>.Se a chave privada não estava protegida por uma "senha" no momento de sua criação, todos os logins subsequentes sobre o servidor vão funcionar sem uma senha.Caso contrário, a chave privada deve ser decifrada a cada momento digitando a senha.Felizmente, <code
                class="command">ssh-agent</code> nos permite manter as chaves privadas na memória para não ter que re-digitar com frequencia a senha.Para isso, basta usar <code
                class="command">ssh-add</code> (uma vez por sessão de trabalho),desde que a sessão já está associado a uma instância funcional do <code
                class="command">ssh-agent</code>.O Debian ativa por padrão nas sessões gráficas, mas isso pode ser desativado alterando <code
                class="filename">/etc/X11/Xsession.options</code>.Para uma sessão de console, você pode iniciá-lo manualmente com <code
                class="command">eval $(ssh-agent)</code>.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SEGURANÇA</em></span> Proteção da chave privada</strong></p></div></div></div><div
                class="para">
					Quem tem a chave privada pode fazer login na conta, assim, configurada. É por isso que o acesso para a chave privada é protegida por uma "frase". Alguém que adquire uma cópia de um arquivo de chave privada (por exemplo,<code
                  class="filename">~/.ssh/id_rsa</code>) ainda tem de saber esta frasea fim de ser capaz de usá-la. Esta proteção adicional não é, no entanto, impenetrável, e se você acha que esse arquivo foi comprometido, é melhor desativar essa chave nos computadores em que foi instalado (para removê-lo  <code
                  class="filename">authorized_keys</code> files) e substituia com uma chave recentemente gerada.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Falha do OpenSSL no Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					A biblioteca OpenSSL, como era inicialmente fornecida no Debian <span
                  class="distribution distribution">Etch</span>, tinha um grave problema no seu gerador de número aleatório (Random Number Generator - RNG). De fato, o mantenedor Debian tinha feito uma mudança para que aplicações usando ela não gerassem avisos quando analisadas por ferramentas de teste de memória como <code
                  class="command">valgrind</code>.Infelizmente, esta mudança também significou que o RNG estava empregando apenas uma fonte de entropia que corresponde ao número do processo (PID), cujos 32.000 possíveis valores não oferecem aleatoriedade suficiente. <div
                  class="url">→ <a
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Especificamente, sempre que OpenSSL era utilizado para gerar uma chave, sempre produzia uma chave dentro de um conjunto conhecido de centenas de milhares de chaves (32.000 multiplicada para um pequeno número de comprimentos de chave). Isso afetou as chaves SSH, chaves SSL e certificados X.509 usados por inúmeras aplicações, tais como o OpenVPN. Um cracker só tinha que tentar todas as chaves para ganhar acesso não autorizado. Para reduzir o impacto do problema, o daemon SSH foi modificado para recusar chaves problemáticas que estão listadas nos pacotes <span
                  class="pkg pkg">openssh-blacklist</span> e <span
                  class="pkg pkg">openssh-blacklist-extra</span>. Além disso, o comando <code
                  class="command">ssh-vulnkey</code> permite a identificação de chaves possivelmente comprometidas no sistema.
				</div><div
                class="para">
					A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <code
                  class="command">valgrind</code>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package.
				</div><div
                class="para">
					É difícil nessas condições de encontrar as medidas corretivas para evitar que tais incidentes não se repitam. A lição a ser aprendida aqui é que cada divergência que o Debian introduz ao upstream deve ser justificada, documentada, submetida ao upstream quando possível, e amplamente divulgada. É nesta perspectiva que o novo formato de pacote de origem ("3.0 (quilt)") e o patch rastreador Debian foram desenvolvidos. <div
                  class="url">→ <a
                    href="http://patch-tracker.debian.org">http://patch-tracker.debian.org</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-x11"></a>9.2.1.2. Usando Aplicações X11 Remotamente</h4></div></div></div><div
              class="para">
					O protocolo SSH permite o encaminhamento de dados gráficos (sessão “X11”, a partir do nome do sistema gráfico mais difundido no Unix); o servidor então mantém um canal dedicado para esses dados. Especificamente, um programa gráfico executado remotamente pode ser exibido no servidor X.org da tela local, e toda a sessão (entrada e exibição) será segura. Como essa funcionalidade permite que aplicações remotas interfiram com o sistema local, ela é desabilitada por padrão. Você pode habilitá-la especificando <code
                class="literal">X11Forwarding yes</code> no arquivo de configuração do servidor (<code
                class="filename">/etc/ssh/sshd_config</code>). Finalmente, o usuário tem que também requisitá-la adicionando a opção <code
                class="literal">-X</code> na linha de comando do <code
                class="command">ssh</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Criando Túneis Criptografados com Encaminhamento de Porta</h4></div></div></div><a
              id="idm140194929836880"
              class="indexterm"></a><div
              class="para">
					Suas opções <code
                class="literal">-R</code> e <code
                class="literal">-L</code> permitem ao <code
                class="command">ssh</code> criar “túneis criptografados” entre duas máquinas, encaminhando com segurança uma porta TCP local (veja barra lateral <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> TCP/UDP</a>) para uma máquina remota ou vice versa.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULÁRIO</em></span> Túnel</strong></p></div></div></div><a
                id="idm140194929832288"
                class="indexterm"></a><a
                id="idm140194929830848"
                class="indexterm"></a><div
                class="para">
					A Internet, e a maioria das LANs que estão conectadas a ela, operam em modo pacote (packet) e não em modo conectado (connected), o que significa que um pacote emitido de um computador para outro fará paradas em vários roteadores intermediários para encontrar seu destino. Você pode ainda simular uma operação de conectação (connected) aonde o fluxo (stream) é encapsulada em pacotes IP normais. Esses pacotes seguem sua rota usual, mas o fluxo (stream) é rescontruído sem mudanças até o destino. Nós chamamos isso de “túnel”, em analogia a uma estrada com túnel aonde veículos vão diretamente da entrada (input) para a saída (output) sem encontrarem nenhum cruzamento, em oposição a um caminho na superfície que envolveria interseções e mudanças de direção.
				</div><div
                class="para">
					Você pode usar essa oportunidade para adicionar criptografia ao túnel: o fluxo (stream) que flui através dele seria então irreconhecível por quem está de fora, mas retornaria ao forma sem criptografia na saída do túnel.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 intermediary</code> estabeleceuma sessão SSH com a máquina <em
                class="replaceable">intermediary</em> e escuta pela porta local 8000 (veja <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">Figura 9.3, “Encaminhando uma porta local com SSH”</a>). Para qualquer conexão estabelecida por esta porta, <code
                class="command">ssh</code> irá iniciar uma conexão a partir do computador <em
                class="replaceable">intermediary</em> na porta 25 no <em
                class="replaceable">server</em>, e irá ligar as duas conexões.
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:server:25 intermediary</code> também estabelece uma sessão SSH com o computador <em
                class="replaceable">intermediary</em>, mas nessa máquina que o <code
                class="command">ssh</code> ouve na porta 8000 (veja <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">Figura 9.4, “Encaminhando uma porta remota com SSH”</a>). Qualquer conexão estabelecida nesta porta fará com que o <code
                class="command">ssh</code> abrir uma conexão a partir da máquina local na porta 25 do <em
                class="replaceable">server</em>, e fazer a ligação das duas conexões.
				</div><div
              class="para">
					Nos dois casos, as conexões são feitas pela porta 25 na máquina (host) <em
                class="replaceable">server</em>, que passa pelo túnel SSH estabelecido entre a máquina local e a máquina <em
                class="replaceable">intermediary</em>. No primeiro caso, a entrada do túnel é a porta local 8000, e os dados se movem em direção a máquina <em
                class="replaceable">intermediary</em> antes de ser direcionada ao <em
                class="replaceable">server</em> na rede “pública”. No segundo caso, a entrada e a saída do túnel são invertidas; a entrada é a porta 8000 na máquina <em
                class="replaceable">intermediary</em>, a saída é na máquina (host) local, e os dados são então direcionados para o <em
                class="replaceable">server</em>. Na prática, o servidor é usualmente a máquina local ou a intermediária. Dessa forma o SSH mantém segura a conexão de uma ponta a outra.
				</div><div
              class="figure"><a
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Encaminhando uma porta local com SSH" /></div></div><p
                class="title"><strong>Figura 9.3. Encaminhando uma porta local com SSH</strong></p></div><div
              class="figure"><a
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Encaminhando uma porta remota com SSH" /></div></div><p
                class="title"><strong>Figura 9.4. Encaminhando uma porta remota com SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    id="sect.remote-desktops"></a>9.2.2. Usando Ambientes Gráficos Remotamente</h3></div></div></div><div
            class="para">
				O VNC (Virtual Network Computing) permite o acesso remoto ao ambiente de trabalho (desktops) gráfico.
			</div><a
            id="idm140194929808288"
            class="indexterm"></a><a
            id="idm140194929807328"
            class="indexterm"></a><a
            id="idm140194929806400"
            class="indexterm"></a><a
            id="idm140194929804960"
            class="indexterm"></a><a
            id="idm140194929804032"
            class="indexterm"></a><div
            class="para">
				Essa ferramenta é, na maioria das vezes, usada para assistência técnica; o administrador pode ver os erros com os quais o usuário está enfrentando, e mostrar a eles um curso de ação correto, sem estar fisicamente presente.
			</div><a
            id="idm140194929802400"
            class="indexterm"></a><a
            id="idm140194929800976"
            class="indexterm"></a><a
            id="idm140194929799552"
            class="indexterm"></a><div
            class="para">
				First, the user must authorize sharing their session. The GNOME graphical desktop environment in <span
              class="distribution distribution">Jessie</span> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <code
              class="command">vino</code>). KDE still requires using <code
              class="command">krfb</code> to allow sharing an existing session over VNC. For other graphical desktop environments, the <code
              class="command">x11vnc</code> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon.
			</div><a
            id="idm140194929795056"
            class="indexterm"></a><a
            id="idm140194929793632"
            class="indexterm"></a><a
            id="idm140194929792208"
            class="indexterm"></a><a
            id="idm140194929790784"
            class="indexterm"></a><div
            class="para">
				Quando a sessão gráfica se torna disponível através do VNC, o administrador tem que fazer a conexão com ele com o cliente VNC. O GNOME tem o <code
              class="command">vinagre</code> e o <code
              class="command">remmina</code> para isso, enquanto o KDE inclui o <code
              class="command">krdc</code> (no menu em <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Remote Desktop Client</strong></span>). Existem outros clientes VNC que usam a linha de comando, como o <code
              class="command">xvnc4viewer</code> no pacote Debian de mesmo nome. Uma vez conectado, o administrador pode ver o que está acontecendo, trabalhar na máquina remotamente, e orientar o usuário como proceder.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SEGURANÇA</em></span> VNC sobre SSH</strong></p></div></div></div><a
              id="idm140194929783776"
              class="indexterm"></a><div
              class="para">
				Se você quer fazer a conexão pelo VNC, e você não quer que seus dados sejam enviados em texto puro pela rede, é possível encapsular os dados através de um túnel SSH (veja <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Seção 9.2.1.3, “Criando Túneis Criptografados com Encaminhamento de Porta”</a>). Você simplesmente tem que saber que o VNC usa a porta 5900 por padrão para a primeira tela (called “localhost:0”), 5901 para a segunda (called “localhost:1”), etc.
			</div><div
              class="para">
				O comando <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">máquina</em></code> cria um túnel entre a porta local 5901 na interface localhost e a porta 5900 da <em
                class="replaceable">máquina</em> "host". O primeiro “localhost” restringe o SSH a ouvir apenas nesta interface na máquina local. O segundo “localhost” indica a interface na máquina remota a qual irá receber o tráfego de rede entrando em “localhost:5901”. Assim <code
                class="command">vncviewer localhost:1</code> irá conectar o cliente VNC a tela remota, mesmo que você indique o nome da máquina local.
			</div><div
              class="para">
				Quando uma sessão VNC é fechada, lembre-se de fechar o túnel por também saindo da sessão SSH correspondente.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>DE VOLTA AO BÁSICO</em></span>Gerenciador de tela</strong></p></div></div></div><a
              id="idm140194929776576"
              class="indexterm"></a><a
              id="idm140194929775456"
              class="indexterm"></a><a
              id="idm140194929774336"
              class="indexterm"></a><a
              id="idm140194929773216"
              class="indexterm"></a><a
              id="idm140194929772096"
              class="indexterm"></a><a
              id="idm140194929770656"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code>, and <code
                class="command">xdm</code> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session.
			</div></div><div
            class="para">
				VNC também funciona para usuários móveis, ou executivos da empresa, os quais ocasionalmente precisam fazer o login a partir de suas casas para acessar um ambiente de trabalho remoto similar ao que eles usam no trabalho. A configuração desse tipo de serviço é mais complicada: você primeiro instala o pacote <span
              class="pkg pkg">vnc4server</span>, altera a configuração do gerenciador de tela para aceitar requisições do <code
              class="literal">XDMCP Query</code> (no <code
              class="command">gdm3</code>, isso pode ser feito adicionando <code
              class="literal">Enable=true</code> na sessão “xdmcp” do <code
              class="filename">/etc/gdm3/daemon.conf</code>), e finalmente, iniciar o servidor VNC com <code
              class="command">inetd</code> para que a sessão seja iniciada automaticamente quando o usuário tentar fazer o login. Por exemplo, você pode adicionar essa linha ao <code
              class="filename">/etc/inetd.conf</code>:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</pre><div
            class="para">
				Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <code
              class="command">gdm3</code> login screen (or equivalent <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code>, because the port used is 5950.
			</div><a
            id="idm140194929758608"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Anterior</strong>Capítulo 9. Serviços Unix</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Próxima</strong>9.3. Gerenciando Direitos</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/sect.remote-login.html">ar-MA</a></li><li><a
              href="../da-DK/sect.remote-login.html">da-DK</a></li><li><a
              href="../de-DE/sect.remote-login.html">de-DE</a></li><li><a
              href="../el-GR/sect.remote-login.html">el-GR</a></li><li><a
              href="../en-US/sect.remote-login.html">en-US</a></li><li><a
              href="../es-ES/sect.remote-login.html">es-ES</a></li><li><a
              href="../fa-IR/sect.remote-login.html">fa-IR</a></li><li><a
              href="../fr-FR/sect.remote-login.html">fr-FR</a></li><li><a
              href="../hr-HR/sect.remote-login.html">hr-HR</a></li><li><a
              href="../id-ID/sect.remote-login.html">id-ID</a></li><li><a
              href="../it-IT/sect.remote-login.html">it-IT</a></li><li><a
              href="../ja-JP/sect.remote-login.html">ja-JP</a></li><li><a
              href="../pl-PL/sect.remote-login.html">pl-PL</a></li><li><a
              href="../pt-BR/sect.remote-login.html">pt-BR</a></li><li><a
              href="../ro-RO/sect.remote-login.html">ro-RO</a></li><li><a
              href="../ru-RU/sect.remote-login.html">ru-RU</a></li><li><a
              href="../tr-TR/sect.remote-login.html">tr-TR</a></li><li><a
              href="../zh-CN/sect.remote-login.html">zh-CN</a></li></ul></div></body></html>
