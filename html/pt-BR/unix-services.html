<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Capítulo 9. Serviços Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="Inicialização do Sistema, Initscripts, SSH, Telnet, Direitos, Permissões, Supervisão, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Instalando o Núcleo" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Login remoto" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/pt-BR/unix-services.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Próxima</strong></a></li></ul><div
        xml:lang="pt-BR"
        class="chapter"
        lang="pt-BR"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>Capítulo 9. Serviços Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Inicialização do Sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. O sistema init systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. O sistema init System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Login remoto</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Login remoto seguro: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Usando Ambientes Gráficos Remotamente</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Gerenciando Direitos</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Interfaces Administrativas</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrando por uma Interface Web: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configurando Pacotes: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Eventos de Sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Princípio e Mecanismo</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. O Arquivo de Configuração</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. O super servidor <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Agendando Tarefas com <code
                    class="command">cron</code> e <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Formato do Arquivo <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Usando o Comando <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Agendando Tarefas Assíncronas: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Cotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Backup</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Cópias de segurança com <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Restaurando Máquinas sem Cópias de Segurança</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Hot Plugging: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introdução</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. O Problema da nomeação</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Como o <span
                        class="emphasis"><em>udev</em></span> Funciona</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Um exemplo concreto</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Gerenciamento de Energia: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Este capítulo abrange uma série de serviços básicos que são comuns a muitos sistemas Unix. Todos os administradores devem estar familiarizados com eles.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. Inicialização do Sistema</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Quando você inicializar o computador, algumas mensagens rolarão pelo console automaticamente inicializando e as configurações são automaticamente executadas. Algumas vezes você pode desejar alterar como este estágio funciona, de forma que possa entender isto muito bem. Este é o propósito desta seção.
		</div><div
            class="para">
			Primeiro, a BIOS pega o controle sobre o computador, detectando discos, carregando a <span
              class="emphasis"><em>Master Boot Record</em></span>, e executa o carregador de inicialização. O carregador de inicialização assume, localiza o kernel no disco, carrega e o executa. O kernel é então inicializado e começa a pesquisa pela partição e monta a partição contendo o sistema raiz e finalmente o primeiro programa — <code
              class="command">init</code>. Frequentemente, esta "partição raiz" e este <code
              class="command">init</code> são, de fato, localizado em um sistema de arquivos virtual que só existe na RAM (daí o seu nome, "initramfs", anteriormente chamado de "initrd" para "initialization RAM disk"). Este sistema de arquivos é carregado na memoria pelo carregador de inicialização, muitas vezes a partir de um arquivo em um disco rígido ou da rede. Ele contém o mínimo exigido pelo kernel para carregar o sistema de arquivos raiz "verdadeiro". Este pode ser módulos de driver para o disco rígido ou outros dispositivos sem o qual o sistema pode não inicializar, ou, mais freqüentemente, scripts de inicialização e módulos para a montagem de arrays RAID, abrindo partições criptografadas, ativando volumes LVM, etc. Uma vez que a partição raiz é montada, o initramfs libera o controle para o init real, e a máquina voltará para o processo de inicialização padrão.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Seqüência de inicialização de um computador rodando Linux com systemd" /></div></div><p
              class="title"><strong>Figura 9.1. Seqüência de inicialização de um computador rodando Linux com systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. O sistema init systemd</h3></div></div></div><div
              class="para">
				O “init real” é atualmente fornecido pelo <span
                class="pkg pkg">systemd</span> e essa seção documenta esse sistema init.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Antes do <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				O <code
                  class="command">systemd</code> é um "sistema init" relativamente recente, e embora ele já estivesse disponível, até certo ponto, no <span
                  class="distribution distribution">Wheezy</span>, ele só se tornou o padrão no Debian <span
                  class="distribution distribution">Jessie</span>. Lançamentos anteriores faziam uso, por padrão, do “System V init” (no pacote <span
                  class="pkg pkg">sysv-rc</span>), um sistema muito mais tradicional. Nós descreveremos o "System V init" mais tarde.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> Outros sistemas de inicializações</strong></p></div></div></div><div
                class="para">
				Este livro descreve o sistema de inicialização usado por padrão no Debian <span
                  class="distribution distribution">Jessie</span> (como implementado pelo pacote <span
                  class="pkg pkg">systemd</span>), assim como o previamente padrão <span
                  class="pkg pkg">sysvinit</span>, que é derivado e herdado dos sistemas Unix <span
                  class="emphasis"><em>System V</em></span>, mas existem outros.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> é um sistema de inicialização com um processo muito simples. Ele mantém a ideia de runlevels (níveis de execução), mas substitui os diretórios e links simbólicos com um arquivo de configuração, que diz ao <code
                  class="command">init</code> os processos que devem ser iniciados e sua ordem de inicialização.
			</div><div
                class="para">
				O recém-chegado sistema <code
                  class="command">upstart</code> ainda não está perfeitamente testado no Debian. Ele é baseado em eventos: scripts de inicialização não são mais executados em uma ordem sequencial, mas em resposta a eventos como a conclusão de um outro script do qual eles são dependentes. Este sistema, iniciado pelo Ubuntu, está presente no Debian <span
                  class="distribution distribution">Jessie</span>, mas não é o padrão; ele vem, de fato, como um substituto para o <span
                  class="pkg pkg">sysvinit</span>, e uma das funções iniciadas pelo <code
                  class="command">upstart</code> é iniciar os scripts escritos para sistemas tradicionais, especialmente aqueles do pacote <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				Existem também outros sistemas e outros modos operacionais, tais como <code
                  class="command">runit</code> ou <code
                  class="command">minit</code>, mas eles são relativamente especializados e não generalizados.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPECIFIC CASE</em></span> Inicializando pela rede</strong></p></div></div></div><div
                class="para">
				Em algumas configurações, o BIOS pode ser configurado para não executar o MBR, mas buscar o seu equivalente na rede, tornando possível a construção de computadores sem disco rígido, ou que são completamente reinstalado a cada boot. Esta opção não está disponível em todos os hardwares e geralmente requer uma combinação adequada de BIOS e placa de rede.
			</div><div
                class="para">
				A inicialização através da rede pode ser usada para iniciar o <code
                  class="command">debian-installer </code> ou FAI (ver <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Seção 4.1, “Métodos de Instalação”</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> Um processo, uma instância do programa</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Um processo é a representação em memória de um programa em execução. Isto inclui todas as informações necessárias para a execução adequada do software (o código própriamente dito, mas também os dados que tem na memória, a lista de arquivos que ele abriu, as conexões de rede que estabeleceu, etc.). Um único programa pode ser instanciado em muitos processos, não necessáriamente rodando sob diferentes IDs de usuários.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SECURITY</em></span> Usando Shell como <code
                          class="command">init</code> para ganhar privilégios de root</strong></p></div></div></div><div
                class="para">
				Por convenção, o primeiro processo que é carregado é o programa <code
                  class="command">init</code> ( que é uma ligação simbólica para <code
                  class="filename">/lib/systemd/systemd</code>, por padrão). Contudo, é possível passar uma opção <code
                  class="literal"> init </code> para o kernel indicando um programa diferente.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Qualquer pessoa que é capaz de acessar o computador e poder pressionar o botão <span
                  class="keycap"><strong>Reset</strong></span>, e, portanto reinicia-lo . Então, no prompt do inicializador do sistema, é possível passar opção <code
                  class="literal">init=/bin/sh</code> para o kernel e ganhar acesso root sem no saber a senha de administrador.
			</div><div
                class="para">
				Para evitar isso, você pode proteger o bootloader com uma senha. Você também pode pensar em proteger o acesso ao BIOS (um mecanismo de proteção por senha geralmente é disponível), sem que um intruso mal-intencionado ainda possa iniciar a máquina por uma mídia removível que contém o seu próprio sistema Linux, que pode então usar para acessar dados sobre discos rígidos do computador.
			</div><div
                class="para">
				Finalmente, esteja ciente que a maioria das BIOS tem uma senha genérica disponível. Inicialmente destinado a solução de problemas para aqueles que esqueceram sua senha, essas senhas são agora público e disponível na Internet (veja por si mesmo procurando por "senhas genéricas" do BIOS em um motor de busca). Todas estas proteções deverá impedir o acesso não autorizado para a máquina sem ser capaz de impedir completamente. Não há nenhuma maneira confiável para proteger um computador se o atacante pode acessar fisicamente ela, pois eles podem desmontar os discos rígidos para conectá-los a um computador sob seu próprio controle de qualquer maneira, ou até mesmo roubar a máquina inteira, ou apagar a memória do BIOS para redefinir a senha…
			</div></div><div
              class="para">
				O systemd executa vários processos, se encarregando de configurar o sistema: teclados, drivers, sistemas de arquivos, rede, serviços. Ele faz isso enquanto mantem uma visão global do sistema como um todo, e os requerimentos dos componentes. Cada componente é descrito por um "arquivo unit” (às vezes mais); a sintaxe geral é derivada do amplamente usado "arquivos *.ini“, com os pares <code
                class="literal"><em
                  class="replaceable">chave</em> = <em
                  class="replaceable">valor</em></code> agrupados entre cabeçalhos <code
                class="literal">[<em
                  class="replaceable">seção ("section")</em>]</code>. Arquivos unit são armazenados em <code
                class="filename">/lib/systemd/system/</code> e <code
                class="filename">/etc/systemd/system/</code>; eles vem em vários sabores, mas nós iremos focar nos “services” e “targets” aqui.
			</div><div
              class="para">
				Um "arquivo service" do systemd descreve um processo gerenciado pelo systemd. Ele contém, grosseiramente, a mesma informação dos antigos scripts init, mas com expressão de maneira declaratória (e muito mais concisa). O systemd maneja a massa de tarefas repetitivas (iniciar e para processo, checar seu status, "logging", descarte de privilégios e muito mais), e o arquivo service apenas precisa preencher as especificações do processo. Por exemplo, aqui está um arquivo service para o SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Como você pode ver, existe muito pouco código nele, apenas declarações. O systemd cuida da exibição dos relatórios de progresso, mantendo os rastros dos processos, e até mesmo reiniciando-os quando necessário.
			</div><div
              class="para">
				O “arquivo target” do systemd descreve o estado do sistema, aonde um conjunto de serviços são conhecidos como estando operacionais. Ele pode ser pensado como um equivalente ao runlevel no estilo antigo. Um dos alvos ("targets") é <code
                class="literal">local-fs.target</code>; quando ele é alcançado, o resto do sistema pode assumir que todos os sistemas de arquivos locais estão montados e acessíveis. Outros alvos ("targets") incluem <code
                class="literal">network-online.target</code> e <code
                class="literal">sound.target</code>. As dependências de um alvo ("target") podem ser listadas tanto dentro de um arquivo target (na linha <code
                class="literal">Requires=</code>), quanto usando uma ligação simbólica para um arquivo service do diretório <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>. Por exemplo, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contém uma ligação para <code
                class="filename">/lib/systemd/system/cups.service</code>; o systemd irá então garantir que o CUPS está rodando a fim de alcançar o <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Como arquivos unit são declarativos ao invéz de scripts ou programas, eles não podem ser rodados diretamente, e eles só são interpretados pelo systemd; vários utilitários, entretanto, permitem que o administrador interaja com o systemd e controle o estado do sistema e de cada componente.
			</div><div
              class="para">
				O primeiro de tais utilitários é o <code
                class="command">systemctl</code>. Quando rodado sem argumentos, ele lista todos os arquivos unit conhecidos pelo systemd (exceto aqueles que tenham sido desabilitados), assim como seus status. O <code
                class="command">systemctl status</code> retorna uma visão melhor dos serviços, assim como os processos relacionados. Se o nome do serviço for informado (como em <code
                class="command">systemctl status ntp.service</code>), ele retorna ainda mais detalhes, assim como as últimas linhas de registro ("log") relacionadas ao serviço (mais sobre isso mais tarde).
			</div><div
              class="para">
				Iniciar um serviço a mão é uma simples questão de rodar <code
                class="command">systemctl start <em
                  class="replaceable">nomedoserviço</em>.service</code>. Como se pode imaginar, para o serviço é feito com <code
                class="command">systemctl stop <em
                  class="replaceable">nomedoserviço</em>.service</code>; outros subcomandos incluem <code
                class="command">reload</code> e <code
                class="command">restart</code>.
			</div><div
              class="para">
				Para controlar se um serviço está ativo (ou seja, se ele será iniciado automaticamente na inicialização), use <code
                class="command">systemctl enable <em
                  class="replaceable">nomedoserviço</em>.service</code> (ou <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> permite checar o status do serviço.
			</div><div
              class="para">
				Um recurso interessante do systemd é que ele inclui um componente de "logging" de nome <code
                class="command">journald</code>. Ele vem como um complemento para sistemas de "logging" mais tradicionais, tal como o <code
                class="command">syslogd</code>, mas ele adiciona recursos interessantes tal como uma ligação formal entre um serviço e as mensagens que ele gera, e a habilidade de capturar mensagens de erro geradas pela sua sequência de inicialização. As mensagens podem ser exibidas mais tarde, com um pequena ajuda do comando <code
                class="command">journalctl</code>. Sem qualquer argumento, ele simplismente derrama todas as mensagens de "log" que ocorreram desde a inicialização do sistema; ele raramente será usado de tal maneira. Na maior parte do tempo, ele será usado com um identificador de serviço:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Outra opção de linha de comando útil é a <code
                class="command">-f</code>, que instrui o <code
                class="command">journalctl</code> a manter a exibição de novas mensagens assim que elas são emitidas (similar ao <code
                class="command">tail -f <em
                  class="replaceable">arquivo</em></code>).
			</div><div
              class="para">
				Se um serviço não parece estar trabalhando como o esperado, o primeiro passo para resolver o problema é checar se o serviço está realmente rodando com <code
                class="command">systemctl status</code>; se ele não está, e as mensagens obtidas pelo primeiro comando não são suficientes para diagnosticar o problema, confira os registros ("logs") coletados pelo journald sobre esse serviço. Por exemplo, suponha que o servidor SSH não esteja funcionando:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Após checar o status do serviço (failed), nós fomos checar os registros ("logs"); eles indicam um erro no arquivo de configuração. Após editar o arquivo de configuração e consertar o erro, nós reiniciamos o serviço, e então verificamos se ele está realmente rodando.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>INDO ALÉM</em></span> Outros tipos de arquivos unit</strong></p></div></div></div><div
                class="para">
				Nesta seção, nós apenas descrevemos as mais básicas capacidades do systemd. Ele oferece muitos outros recursos interessantes; nós iremos listar apenas alguns aqui:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						ativação de "socket": um arquivo unit “socket” pode ser usado para descrever um "socket" de rede ou Unix gerenciado pelo systemd; isso significa que o "socket" será criado pelo systemd, e o real serviço pode ser iniciado por requisição ("on demand") quando uma real tentativa de conexão vier. Isso, grosseiramente, replica o recurso configurado pelo <code
                        class="command">inetd</code>. Veja <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: um arquivo unit “timer” descreve eventos que ocorrem com uma frequência fixa ou em horários específicos; quando um serviço é ligado a tal timer, a tarefa correspondente será executada sempre que o timer for acionado. Isso permite replicar parte dos recursos do <code
                        class="command">cron</code>. Veja <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: um arquivo unit "network" descreve uma interface de rede, que permite a configuração de tais interfaces assim como expressar que um serviço dependa de uma interface em particular levantada.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. O sistema init System V</h3></div></div></div><div
              class="para">
				O sistema init System V (que nós iremos chamar init para abreviar) executa vários processos, seguindo instruções a partir do arquivo <code
                class="filename">/etc/inittab</code>. O primeiro programa que é executado (o que corresponde ao passo <span
                class="emphasis"><em>sysinit</em></span>) é <code
                class="command">/etc/init.d/rcS </code>, um script que executa todos os programas que eestão dentro do diretório <code
                class="filename">/etc/rcS.d /</code>. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Entre estes,você encontrará sucessivamente programas responsáveis pela:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						configurar o teclado do console;
					</div></li><li
                  class="listitem"><div
                    class="para">
						carregando drivers: a maioria dos módulos do kernel serão carregados por si assim que o hardware seja detectado; drivers extra então são carregado automaticamente quando o modulo correspondente seja listado em <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						checar a integridade do sistema de arquivos;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montar partições locais;
					</div></li><li
                  class="listitem"><div
                    class="para">
						configuração da rede;
					</div></li><li
                  class="listitem"><div
                    class="para">
						mountando sistemas de arquivos em rede (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> Kernel modules and options</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Os módulos do kernel também tem opções que podem ser configuradas colocando alguns arquivos em <code
                  class="filename">/etc/modprobe.d/ </code>. Essas opções são definidas com as diretivas como esta: <code
                  class="literal">opções<em
                    class="replaceable">nome do módulo</em><em
                    class="replaceable">nome da opção</em>=<em
                    class="replaceable">valor da opção</em> </code>. Várias opções podem ser especificadas com uma única diretiva, se necessário.
			</div><div
                class="para">
				Estes arquivos de configuração são destinados para o <code
                  class="command"> modprobe </code> - o programa que carrega um módulo do kernel com suas dependências (módulos podem realmente chamar outros módulos). Este programa é fornecido pelo pacote <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Após este estágio, o <code
                class="command">init</code> assume o controle e inicializa os programas habilitados no nível de execução padrão (que geralmente é no nível de execução 2). Ele executa o <code
                class="command">/etc/init.d/rc 2</code>, um script que inicia todos os serviços que estão listados em <code
                class="filename">/etc/rc2.d/</code> e que os nomes começam com a letra "S". O número de duas casas que se segue tinha sido historicamente utilizado para definir a ordem em que os serviços devem de ser iniciados. Atualmente, o sistema de inicialização padrão usa <code
                class="command">insserv</code>, o qual agenda automaticamente tudo, baseado nas dependências dos scripts. Desta forma, cada script de inicialização declara as condições que devem ser cumpridas para iniciar ou parar um serviço (por exemplo, se ele deve começar antes ou depois de outro serviço); o <code
                class="command">init</code> em seguida, lança-os na ordem que satisfaça estas condições. A numeração estática dos scripts, portanto, não é mais levada em consideração (mas eles sempre devem ter um nome começando por "S" seguido por dois digitos e o nome atual do script usado por suas dependências). Geralmente, serviços base (tal como registros com o <code
                class="command">rsyslog</code>, ou numeração de portas com <code
                class="command">portmap</code>) são inicializados primeiro, seguidos por serviços padrões e a interface gráfica (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Este sistema de inicialização baseado em dependência torna possível automatizar a numeração, que poderia ser um pouco entediante se tivesse que ser feito manualmente, e limita os riscos de erro humano, já que o agendamento é realizado de acordo com os parâmetros indicados. Outro benefício é que os serviços podem ser iniciados em paralelo quando são independentes um do outro, que pode acelerar o processo de inicialização.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distingue vários runlevels, então para que ele possa alternar de um para outro com o comando <code
                class="command">telinit<em
                  class="replaceable">new-level</em></code>. Imediatamente,<code
                class="command">init</code> executa <code
                class="command">/etc/init.d/rc</code> novamente com novo runlevel. Este script irá, em seguida, iniciar os serviços ausentes e interromper aqueles que não são mais desejado. Para fazer isso, ele se dirige ao conteúdo do <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>(onde <em
                class="replaceable">X</em> representa o novo runlevel).Scripts começando com "S" (como em "Start") são serviços iniciados; aqueles que iniciam com "K" (como em "Kill") são os serviços interrompidos. O script não inicia qualquer serviço que já estava ativo em runlevel anterior.
			</div><div
              class="para">
				Por padrão, o init System V no Debian usa quatro runlevels diferentes:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Nível 0 é usada apenas temporariamente, enquanto o computador está desligando. Como tal, ele só contém muitos scripts de "K".
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nível 1, também conhecido como modo de usuário único, corresponde ao sistema em modo degradado; inclui apenas os serviços básicos e destina-se para operações de manutenção onde interações com usuários comuns não são desejadas.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nível 2 é o funcionamento normal, o que inclui serviços de rede, uma interface gráfica, logons de usuário, etc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nível 6 é semelhante ao nível 0, exceto que é utilizada durante a fase de desligamento que precede uma reinicialização.
					</div></li></ul></div><div
              class="para">
				Existem outros níveis, especialmente de 3 a 5. Por padrão, eles são configurados para operar da mesma maneira como nível 2, mas o administrador pode modificá-los (adicionando ou excluindo os scripts nos diretórios correspondentes <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>) para adaptá-los às necessidades específicas.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Seqüência de inicialização de um computador rodando Linux com o init System V" /></div></div><p
                class="title"><strong>Figura 9.2. Seqüência de inicialização de um computador rodando Linux com o init System V</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Todos os scripts contidos nos vários diretórios <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> são na verdade apenas links simbólicos — criados durante a instalação de pacotes pelo programa <code
                class="command">update-rc.d</code> — apontando para os scripts atuais que são armazenados no <code
                class="filename">/etc/init.d/</code>. O administrador pode ajustar os serviços disponíveis em cada nível de execução reexecutando o <code
                class="command">update-rc.d</code> com parâmetros de ajuste. A página de manual do <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> descreve a sintaxe em detalhes. Note que remover todos os links simbólicos (com o parâmetro <code
                class="literal">remove</code>) não é um bom método para desabilitar um serviço. Ao invés disto você deve apenas configurar ele para não iniciar no nível de execução desejado (enquanto preserva as chamadas correspondentes para parar ele no caso do serviço iniciar num nível de execução anterior). Uma vez que o <code
                class="command">update-rc.d</code> tem uma interface de certa forma "convoluted", você pode preferir usar <code
                class="command">rcconf</code> (do pacote <span
                class="pkg pkg">rcconf</span>) que fornece uma interface de usuários mais amigável.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>POLÍTICA DEBIAN</em></span> Reiniciando serviços</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Os scripts de manutenção para os pacotes Debian algumas vezes irão reiniciar alguns serviços para garantir a sua disponibilidade ou levá-los a tomar certas opções em conta. O comando que controla um serviço -- <code
                  class="command">service <em
                    class="replaceable">serviço</em> <em
                    class="replaceable">operação</em></code> - não leva em consideração o nível de execução ("runlevel"), assume (erroneamente) que o serviço está sendo usado, e pode, assim, iniciar operações incorretas (começando um serviço que estava deliberadamente interrompido ou interromper um serviço que já esta parado, etc.) Portanto o Debian introduziu o programa <code
                  class="command">invoke-rc.d</code>: este programa deve ser usado por scripts de manutenção para executar serviços de scripts de inicialização e isso só irão executar os comandos necessários. Observe que, ao contrário do uso comum, o sufixo <code
                  class="filename">.d</code> é usado aqui em um nome de programa, e não em um diretório.
			</div></div><div
              class="para">
				Finalmente, <code
                class="command">init</code> começa a controla programas para vários consoles virtuais (<code
                class="command">getty</code>). Ele exibe um prompt, esperando por um nome de usuário, em seguida, executa o usuário <code
                class="command">login <em
                  class="replaceable">user</em></code> para iniciar uma sessão.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULÁRIO</em></span> Console e terminal</strong></p></div></div></div><div
                class="para">
				Os primeiros computadores eram geralmente separados em diversas, peças muito grandes: o compartimento de armazenamento e unidade central de processamento foram separados dos dispositivos periféricos usados pelos operadores para controlá-los. Estes eram parte de uma mobília separada, o "console". Este termo foi mantido, mas seu significado foi alterado. Tornou-se mais ou menos sinônimo de "terminal", sendo um teclado e uma tela.
			</div><div
                class="para">
				Com o desenvolvimento de computadores, sistemas operacionais tem oferecido vários consoles virtuais para permitir várias sessões independentes ao mesmo tempo, mesmo se houver apenas um teclado e tela. A maioria dos sistemas GNU/Linux oferecem seis consoles virtuais (modo texto), acessíveis, digitando as combinações de teclas <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> through <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Por extensão, os termos "console" e "terminal" também pode se referir a um emulador de terminal em uma sessão X11 gráfica (como <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> ou <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Anterior</strong>8.11. Instalando o Núcleo</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Próxima</strong>9.2. Login remoto</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../ko-KR/unix-services.html">ko-KR</a></li><li><a
              href="../nb-NO/unix-services.html">nb-NO</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li><li><a
              href="../zh-TW/unix-services.html">zh-TW</a></li></ul></div></body></html>
