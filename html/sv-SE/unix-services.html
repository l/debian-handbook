<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Kapitel 9. Unixtjänster</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-sv-SE-1.0-1" /><meta
        name="keywords"
        content="System boot, Initskript, SSH, Telnet, Rättigheter, Behörigheter, Övervakning, Inetd, Cron, Säkerhetskopia, Inpluggninsbara, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Handbok för Debianadministratören" /><link
        rel="up"
        href="index.html"
        title="Handbok för Debianadministratören" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installing a Kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Fjärrinloggning" /><meta
        name="viewport"
        content="width=device-width, initial-scale=1" /><meta
        name="flattr:id"
        content="4pz9jq" /><link
        rel="canonical"
        href="http://l.github.io/debian-handbook/html/sv-SE/unix-services.html" /></head><body><noscript><iframe
          src="//www.googletagmanager.com/ns.html?id=GTM-5H35QX"
          height="0"
          width="0"
          style="display:none;visibility:hidden"></iframe></noscript><script
        type="text/javascript">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5H35QX');</script><div
        id="banner"><a
          href="../../"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Föregående</strong></a></li><li
          class="home">Handbok för Debianadministratören</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Nästa</strong></a></li></ul><div
        xml:lang="sv-SE"
        class="chapter"
        lang="sv-SE"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  id="unix-services"></a>Kapitel 9. Unixtjänster</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. System Boot</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Systemds init-system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. System Vs init-system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Fjärrinloggning</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Säker fjärrinloggning: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Använda grafiska fjärrskrivbord</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Hantera behörigheter</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Adminstrationsgränssnitt</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrera över ett webbgränsnitt: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Konfigurera paket: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Systemhändelser</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Princip och mekanism</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Konfigurationsfilen</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Superservern <code
                    class="command">inetd</code> Super-Server</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Scheduling Tasks with <code
                    class="command">cron</code> and <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Format för <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Using the <code
                        class="command">at</code> Command</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Scheduling Asynchronous Tasks: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Quotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Säkerhetskopia</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Backing Up with <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Restoring Machines without Backups</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Hot Plugging: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introduction</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. The Naming Problem</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. How <span
                        class="emphasis"><em>udev</em></span> Works</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Ett konkret exempel</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Power Management: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Kapitlet täcker en rad grundläggande tjänster vanliga för många Unixsystem. Alla administratörer bör vara bekanta med dem.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    id="sect.system-boot"></a>9.1. System Boot</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			När du startar upp datorn visas många meddelanden för automatiska konfigurationer och initieringar på konsolen. Ibland kanske du vill ändra lite på hur denna fas fungerar, vilket innebär att du måste förstå dem. Det är själva syftet med detta avsnitt.
		</div><div
            class="para">
			Först tar datorns BIOS kontroll över datorn, identifierar diskarna, läser in <span
              class="emphasis"><em>Master Boot Record</em></span> och kör starthanteraren. Starthanteraren tar över, hittar kärnan på disken, läser och exekvererar den. Sedan initieras kärnan och börjar att leta efter samt montera partitionen som innehåller root-filsystemet, och sedan körs det första programmet — <code
              class="command">init</code>. Ofta finns denna ”root-partition” och <code
              class="command">init</code> på ett virtuellt filsystem som endast finns i RAM (därav dess namn ”initrams”, förr kallad ”initd” för ”initialization ram disk”). Filsystem läses in i minnet av starthanteraren, ofta från en fil på hårddisken eller från nätverket. Det innehåller det minsta som krävs av kärnan för att läsa in det riktiga root-filsystemet: det kan vara drivrutinsmoduler för hårddisken eller andra enheter för vilka systemet inte kan starta, eller oftare, initieringsskript och moduler för att sätta ihop raid-vektorer, öppna krypterade partitioner, aktivera LVM-volymer med mera. När väl root-partitionen är monterad ger initramfs kontrollen till den riktiga init, och maskinen återgår till standarduppstarten.
		</div><div
            class="figure"><a
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Startsekvens för en dator som kör Linux med systemd" /></div></div><p
              class="title"><strong>Figur 9.1. Startsekvens för en dator som kör Linux med systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.systemd"></a>9.1.1. Systemds init-system</h3></div></div></div><div
              class="para">
				Den ”riktiga init-processen” tillhandahålls av <span
                class="pkg pkg">systemd</span> och en beskrivning följer i detta avsnitt.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KULTUR</em></span> Innan <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> är ett ganska nytt “init system”, och även om det var tillgänligt redan i <span
                  class="distribution distribution">Wheezy</span>, blev det standard först i Debian <span
                  class="distribution distribution">Jessie</span>. Tidigare utgåvor förlitade sig på “System V init” (i paketet <span
                  class="pkg pkg">sysv-rc</span>), ett traditionellare system. Vi kommer att beskriva System V init senare.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIV</em></span> Andra uppstartssystem</strong></p></div></div></div><div
                class="para">
				Denna bok beskriver uppstartsystemen som används som standard i Debian <span
                  class="distribution distribution">Jessie</span> (som implementerat av paketet <span
                  class="pkg pkg">systemd</span>), så väl som det tidigare startsystemet, <span
                  class="pkg pkg">sysvinit</span>,vilket härleddes från Unixsystemet <span
                  class="emphasis"><em>System V</em></span>; det finns dock flera.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> är ett uppstartsystem med en mycket enkel process. Det följer principen om körnivåer, men ersätter kataloger och symboliska länkar med en konfigurationsfil som beskriver för <code
                  class="command">init</code> vilka processer som måste startas, och i vilken körordning.
			</div><div
                class="para">
				Systemet <code
                  class="command">upstart</code> är ännu inte testat i Debian. Det är händelsebaserat; initskript exekveras inte längre i en sekventiell ordning, men som svar på händelser, såsom att skript som hade ett beroende blev klart. Systemet startades av Ubuntu och finns i Debian <span
                  class="distribution distribution">Jessie</span>, men inte som standard; det är med som en ersättning för <span
                  class="pkg pkg">sysvinit</span>, och en av jobben startade av <code
                  class="command">upstart</code> är att starta skript skrivna för traditionella system, speciellt de från paketet <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				Det finns också andra mer specialiserade och mindre spridda system och körlägen, som <code
                  class="command">runit</code> eller <code
                  class="command">minit</code>.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPECIALFALL</em></span> Att starta från nätverket</strong></p></div></div></div><div
                class="para">
				För den del konfigurationer kan BIOS konfigureras till att inte exekvera MBR, utan att istället leta efter motsvarigheten på nätverket, vilket då gör det möjligt att bygga datorer utan en hårddisk, eller som installeras om helt för varje start. Detta alternativ är inte tillgängligt på all hårdvara och kräver oftast en passande kombination av BIOS och nätverkskort.
			</div><div
                class="para">
				Att starta från nätverket kan användas för att starta från <code
                  class="command">debian-installer</code> eller FAI (se <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Avsnitt 4.1, ”Installation Methods”</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GRUNDERNA</em></span> Processen, en programinstans</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				En process är minnesrepresentationen av ett körande program. Det omfattar all information nödvändig för korrekt exekvering av programvara (själva koden, men också datan i minnet, öppnad fillista, nätverksanslutningar och så vidare). Ett enskilt program kan ha initierats till flera olika processer, inte nödvändigtvis körande under olika användar-ID.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SÄKERHET</em></span> Använda ett skal för att <code
                          class="command">init</code> komma åt root-rättigheter</strong></p></div></div></div><div
                class="para">
				Genom konvention är den första process som startas programmet <code
                  class="command">init</code> (vilket som standard är en symbolisk länk till <code
                  class="filename">/lib/systemd/systemd</code>). Det är möjligt att skicka en flagga <code
                  class="literal">init</code> till kärnan som pekar på ett annat program.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Alla som har tillgång til datorn kan trycka ned knappen <span
                  class="keycap"><strong>Reset</strong></span> och starta om den. Det är sedan möjligt att i starthanterarens kommandotolk ge flaggan <code
                  class="literal">init=/bin/sh</code> till kärnan för att få root-behörighet utan att veta administratörens lösenord.
			</div><div
                class="para">
				För att förhindra det kan du skydda själva starthanteraren med ett lösenord. Du kan också begränsa tillgången till BIOS (det finns nästan alltid lösenordsskydd tillgängligt), vilket utan en en illasinnad anfallare ändå kan starta upp maskinen från flyttbar media innehållande deras egna Linux-system, som de sedan kan använda för att komma åt data på datorns hårddiskar.
			</div><div
                class="para">
				Till sist, var medveten om att de flesta BIOS har ett generiskt lösenord tillgängligt. Från början avsett att förenkla för de som har glömt sina lösenord finns dessa att tillgå på internet (finn dem genom att söka på ”generic bios passwords” i en sökmotor). Alla dessa skydd kommer att sakta ner obehörig tillgång till datorn utan att helt förhindra det. Det finns inge pålitligt sätt att skydda en dator på om någon har fysisk tillgång till den; de kan koppla lös hårddiskarna och ansluta dem till en annan dator de har kontroll över, eller till och med ta hela maskinen, eller radera bios-minnet för att återställa lösenordet…
			</div></div><div
              class="para">
				Systemd exekverar flera processer som har ansvar för att hantera systemet: tangentbord, drivrutiner, filsystem, nätverk, tjänster. Det sker samtidigt som systemd också har en översikt över helheten och komponenters behov. Varje komponent beskrivs som en ”enhetsfil” (ibland mer); den generella syntaxen härleds från de allmänt använda syntaxen för ”*,ini”-filer med <code
                class="literal"><em
                  class="replaceable">nyckel</em> = <em
                  class="replaceable">värde</em></code>par grupperade mellan <code
                class="literal">[<em
                  class="replaceable">avsnitt</em>]</code>. Enhetsfiler lagras under <code
                class="filename">/lib/systemd/system/</code> och <code
                class="filename">/etc/systemd/system/</code>; de kommer i flera varianter, men vi fokuserar på ”services” och ”targets” här.
			</div><div
              class="para">
				En ”service”-fil i systemd beskriver en process hanterad av systemd. Den innehåller ungefär samma information som ett gammeldags init-skript, men uttrycks i ett deklarativt (och mer enhetligt) sätt. Systemd hanterar merparten av de repetetiva uppgifterna (starta och stanna processen, kontrollera dess status, loggning, minska rättigheter och så vidare) och service-filen behöver endast fylla i det som är speciellt för processen. Här är till exempel service-filen för SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Det är, som du kan se, väldigt lite kod och bara deklarationer. Systemd ansvarar för att visa förloppsrapporter, hålla reda på processer och även om att starta om dem vid behöv.
			</div><div
              class="para">
				En ”target”-fil i systemd beskriver ett systemtillstånd där en mängd tjänster ingår. Det kan jämföras med forna tiders körnivå (runlevel). En av målen är <code
                class="literal">local-fs.target</code> som gör att systemet, när målet uppfylts, kan anta att alla lokal filsystem är monterade och tillgängliga. Andra mål omfattar <code
                class="literal">network-online.target</code> och <code
                class="literal">sound.target</code>. Beroenden för ett mål kan listas i antingen target-filen ( raden <code
                class="literal">Requires=</code>) eller med en symbolisk länk till en systemtjänstfil i katalogen <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>. Till exempel innehåller <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> en länk till <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd kommer därför att försäkra sig om att CUPS körs för att kunna uppfylla <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Eftersom unit-filer är deklarativa och inte skript eller program kan de inte köras direkt, och de tolkas bara av system; det finns därför flera verktyg som låter administratören interagera och kontrollera systemtillståndet för varje komponent.
			</div><div
              class="para">
				Det första verktyget av det slaget är <code
                class="command">systemctl</code>. Nä det körs utan argument listar det alla enhetsfiler kända för systemd (förutom de som har blivit inaktiverade) såväl som deras tillstånds. <code
                class="command">systemctl status</code> ger en bättre överblick över tjänsterna, såväl som relaterade processer. Om givet namnet för en tjänst (som i <code
                class="command">systemctl status ntp.service</code>), returnerar den ännu mer detaljer, såväl som de sista få loggraderna relaterade till tjänsten (mer om det senare).
			</div><div
              class="para">
				Att starta en tjänst manuellt är så enkelt som att köra <code
                class="command">systemctl start <em
                  class="replaceable">tjänstenamn</em>.service</code>. Och, som du kanske gissat redan, stoppas tjänsten med <code
                class="command">systemctl stop <em
                  class="replaceable">tjänstenamn</em>.service</code>; andra kommandon omfattar <code
                class="command">reload</code> och <code
                class="command">restart</code>.
			</div><div
              class="para">
				För att kontrollera huruvida en tjänst är aktiv (det vill säga huruvuda den startas automatiskt vid uppstart), använd <code
                class="command">systemctl enable <em
                  class="replaceable">tjänstenman</em>.service</code> (eller <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> gör en statuskontroll av tjänsten.
			</div><div
              class="para">
				En intressant egenskap i systemd är att den kommer med en loggningskomponent vid namn <code
                class="command">journald</code>. Den är en komplettering till mer traditionella loggningssystem som <code
                class="command">syslogd</code>, men lägger till intressanta egenskaper som en formell länk mellan en tjänst och meddelanden den skapar, och förmågan att fånga felmeddelanden skapade av dess initieringssekvens. Meddelandet kan visas senare, med lite hjälp från kommandot <code
                class="command">journalctl</code>. Utan några argument kastar den ur sig alla loggmeddelanden som uppstått sedan systemstart.; men så används den sällan. För det mesta används det med en tjänstidentifierare:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				En annan användbar kommandoradsflagga är <code
                class="command">-f</code>, som intstruerar <code
                class="command">journalctl</code>att visar nya meddelanden allt eftersom de skapas (i still med <code
                class="command">tail -f <em
                  class="replaceable">fil</em></code>).
			</div><div
              class="para">
				Om en tjänst inte fungerar som väntat så är det första steget att kontrollera att tjänsten verkligen körs med <code
                class="command">systemctl status</code>; om den inte gör det, och meddelanden från kommandot inte är nog för att finna problemet, kontrollera loggarna som samlats av journald. Som exempel, anta att SSH-servern inte fungerar:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Efter att ha kontrollerat tjänstens tillstånd (misslyckad) gick vi vidare med att kontrollera loggarna; de visar på ett fel i konfigurationsfilen. Efter att ha redigerat konfigurationsfilen och rättat felet startar vi om tjänsten, och verifierar sedan att den körs.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GÅ DJUPARE</em></span> Andra typer av unit-filer</strong></p></div></div></div><div
                class="para">
				Vi har bara beskrivit de mest grundläggande av systemd's egenskaper i detta avsnitt. De erbjuder en mängd intressanta egenskaper och vi lista några av dem här:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket-aktivering: en ”enhetsfil för socket” kan användas till att beskriva ett nätverk eller Unix-socket hanterad av systemd; det betyder att uttaget kommer att skapas av systemd och att den aktuella tjänsten kan startas vid behov när en faktisk anslutning sker. Det motsvarar i princip egenskaperna från <code
                        class="command">inetd</code>. Se <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: en enhetsfil för ”timers” som beskriver händelser vilka uppstår med regelbunden frekvens eller vid specifika tider; när en tjänst är länkad till en sådan timer kommer motsvarande uppgift att exekveras när timern utlöses. Det kan ses som att replikera en del av egenskaperna i <code
                        class="command">cron</code>. Se <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: en enhetsfil för ”network” beskriver en nätverksgränssnitt som gör det enkelt att konfigurera sådana gränssnitt såväl som att beskriva att en tjänst beror på ett speciellt gränssnitt är aktivt.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      id="sect.sysvinit"></a>9.1.2. System Vs init-system</h3></div></div></div><div
              class="para">
				<code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Bland dem hittar du program som för att:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						konfigurera konsolens tangentbord;
					</div></li><li
                  class="listitem"><div
                    class="para">
						läsa in drivrutiner: de flesta av kärnmoduler läses in av själva kärnan då hårdvara identifieras; extra drivrutiner läses sedan in automatisk när motsvarande moduler listas i <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						kontrollera integretitetn i filsystem;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montera lokala partitioner;
					</div></li><li
                  class="listitem"><div
                    class="para">
						konfigurera nätverket;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montera nätverksfilsystem (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GRUNDERNA</em></span> Kärnmoduler och flaggor</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Kärnmoduler har också flaggor som kan konfigurerars genom att lägga filer i <code
                  class="filename">/etc/modprobe.d/</code>. Dessa flaggor definieras med direktiv som: <code
                  class="literal">options <em
                    class="replaceable">modulnamn</em> <em
                    class="replaceable">flaggnamn</em>=<em
                    class="replaceable"></em>flaggvärde</code>. Flera flaggor kan specificeras med ett enda direktiv om så krävs.
			</div><div
                class="para">
				Dessa konfigurationsfiler är avsedda för <code
                  class="command">modprobe</code> —programmet som läser in en kärnmodul med dess beroenden (moduler kan anropa andra moduler). Detta program tillhandahålls genom paketet kmod <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				I detta steg tar <code
                class="command">init</code> över och startar programmen aktiverade i standardkörnivå (vanligen körnivå 2). Det exekverar <code
                class="command">/etc/init.d/rc 2</code>, ett skript som startar alla tjänster som listas i <code
                class="filename">/etc/rc2.d/</code> och vars namn börjar med bokstaven ”S”. Det tvåsiffriga tal som fööjer har historiskt använts för att definiera den ordning för vilka tjänsterna skulle startas i, men nuförtiden använder startsystemen s <code
                class="command">insserv</code>, som schemalägger allting automatiskt baserat på skriptens beroenden, Varje startskript deklarer därför villkoren som ska uppflyllas för att starta eller stoppa en tjänst (exempelvis om den måste starta innan eller efter en annan tjänst); <code
                class="command">init</code> startar sedan upp dem i den ordning som krävs för att uppfylla villkoren. Den statiska namngivningen är därför inte längre använd (men de måsta alltid ha ett namn som börjar på”S” följt av två siffror och namnet på skriptet använt av beroendena). Vanligen startas grundtjänster först (som loggning med <code
                class="command">rsyslog</code>, eller porttilldelning med <code
                class="command">portmap</code>), följt av standardtjänster och det grafiska gränsnittet (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Detta beroende baserad startsystem gör det möjligt att automatisera ordning, vilket skulle vara ansträngande om det var tvunget att ske manuellt, och det begränsar riskerna för mänskliga fel, eftersom schemaläggningen sker efter de parametrar som anges. En annan fördel är att tjänster kan startas parallellt när de är oberoende av varandra, vilket kan snabba upp startprocessen.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> skiljer på flera körnivåer så att det kan växla från den ena till den andra med kommandot <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code>. <code
                class="command">init</code> exekverar omedelbart <code
                class="command">/etc/init.d/rc</code> med den nya körnivån. Skripet kommer sedan att starta de saknade tjänsterna och stoppa de som inte längre önskas. För att göra detta, hänvisar den till innehållet i <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (där <em
                class="replaceable">X</em> representerar den nya körnivån). Skript som börjar på ”S” (som i ”Start”) är tjänster som ska startas; De som börjar på ”K” (som i ”Kill”) är tjänster som ska stoppas. Skriptet startar ingen tjänst som redan var aktiv i tidigare körnivå.
			</div><div
              class="para">
				System V använder i Debian fyra olika körnivåer:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Nivå 0 används endast tillfälligt medan datorn stänger av. Som sådan innehåller den många ”K”-skript.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivå 2, också känd som enanvändarläge, motsvarar system i degraderat läge; det innehåller bara grundläggande tjänster, och är avsett för underhållsåtgärder där interaktioner med vanliga användare inte är önskvärt.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivå 2 är nivån normal användning, vilket omfattar nätverkstjänster, ett grafiskt gränssnitt, användarinloggning med mera.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivå 6 liknar nivå 0, förutom att den används under nedstängningsfasen före en omstart.
					</div></li></ul></div><div
              class="para">
				Andra nivåer finns, speciellt då 3 till 5. Deras standardkonfiguration är att verka på samma sätt som för nivå 2, men administratören kan ändra dem (genom att lägga till eller ta bort skript i motsvarande kataloger för <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>) för att anpassa dem till speciella behov.
			</div><div
              class="figure"><a
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Startsekvensen för en dator som kär Linux med System V init" /></div></div><p
                class="title"><strong>Figur 9.2. Startsekvensen för en dator som kär Linux med System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Alla skript i de olika katalogerna <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> är egentligen bara symboliska länkar — skapade vid paketinstallation med programmet <code
                class="command">update-rc.d</code> —och pekar på aktuella skript som lagras i <code
                class="filename">/etc/init.d/</code>. Adminstratören kan finjustera de tillgängliga tjänsterna i varje körnivå genom att köra om <code
                class="command">update-rc.d</code> med justerade parametrar. Manualsidan <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> beskriver syntaxen i detalj. Observera att ta bort alla symboiiska länkar (med parametern <code
                class="literal">remove</code>) inte är ett bra sätt att inaktivera en tjänst på. Istället bör du konfiguera den till att inte starta i önskade körniv (medan motsvarande anrop att stoppa den bevaras i den händelse att tjänsten köra i föregående körnivå). Eftersom <code
                class="command">update-rc.d</code> har ett något rörigt gränssnitt kanske du föredrar att använda <code
                class="command">rcconf</code> (från paketet <span
                class="pkg pkg">rcconf</span>) vilket ger ett mer lättanvänt gränssnitt.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN RIKTLNJE</em></span> Starta om tjänster</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Underhållningsskripten för Debianpaket kommer ibland att starta om vissa tjänster för att försäkra sig om deras tillgänglighet eller få dem att omfatta vissa alternativ. Kommandot som kontrollerar en tjänst— <code
                  class="command">service <em
                    class="replaceable">tjänst</em> <em
                    class="replaceable">åtgärd</em></code> — tar inte hänsyn till körnivå, antar felaktigt att tjänsten redan är stoppad och så vidare.). Debian introducerade därför programmet <code
                  class="command">invoke-rc.d</code>: programmet måste användas av underhållningsskript för att köra initieringsskript och kommer endast att exekvera nödvändiga kommandon. Observera att i motsats till vanlig användning används filnamnssufix här endast i programnamn och ej för en katalog.
			</div></div><div
              class="para">
				Slutligen startar <code
                class="command">init</code> kontrollprogram för flera olika virtuella konsoler (<code
                class="command">getty</code>). Det visar en prompt, väntar på ett användarnamn och exekverar sedan <code
                class="command">login <em
                  class="replaceable">användare</em></code> för att starta en session.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ORDFÖRRÅD</em></span> Konsol och terminal</strong></p></div></div></div><div
                class="para">
				De första datorerna var separerade i flera olika delar: lagring och processorenhet var avskilda från operatörernas andra kontrollenheter. De var delar i separat möbel, ”konsolen”. Term har stannat kvar, men dess betydelse har ändrats. Den har blivit mer eller mindre synonym med ”terminal”, som är både tangentbord och skärm.
			</div><div
                class="para">
				I och med utvecklingen av datorer har operativsystem erbjudit flera virtuella konsoler för att tillåta samtidiga sessioner, oberoende av varandra, även om det endast finns ett tangentbord och en skärm. De flesta GNU/Linux-system har sex stycken virtuella konsoler (i textläge), tillgängliga genom att ange tangentkombinationerna <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> till <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Termerna ”konsol” och ”terminal” kan också hänvisa till en terminalemulator i en grafisk X11-session (som <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> eller <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Föregående</strong>8.11. Installing a Kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Upp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Nästa</strong>9.2. Fjärrinloggning</a></li></ul><div
        id="translated_pages"><ul><li><a
              href="../ar-MA/unix-services.html">ar-MA</a></li><li><a
              href="../da-DK/unix-services.html">da-DK</a></li><li><a
              href="../de-DE/unix-services.html">de-DE</a></li><li><a
              href="../el-GR/unix-services.html">el-GR</a></li><li><a
              href="../en-US/unix-services.html">en-US</a></li><li><a
              href="../es-ES/unix-services.html">es-ES</a></li><li><a
              href="../fa-IR/unix-services.html">fa-IR</a></li><li><a
              href="../fr-FR/unix-services.html">fr-FR</a></li><li><a
              href="../hr-HR/unix-services.html">hr-HR</a></li><li><a
              href="../id-ID/unix-services.html">id-ID</a></li><li><a
              href="../it-IT/unix-services.html">it-IT</a></li><li><a
              href="../ja-JP/unix-services.html">ja-JP</a></li><li><a
              href="../ko-KR/unix-services.html">ko-KR</a></li><li><a
              href="../nb-NO/unix-services.html">nb-NO</a></li><li><a
              href="../pl-PL/unix-services.html">pl-PL</a></li><li><a
              href="../pt-BR/unix-services.html">pt-BR</a></li><li><a
              href="../ro-RO/unix-services.html">ro-RO</a></li><li><a
              href="../ru-RU/unix-services.html">ru-RU</a></li><li><a
              href="../tr-TR/unix-services.html">tr-TR</a></li><li><a
              href="../vi-VN/unix-services.html">vi-VN</a></li><li><a
              href="../zh-CN/unix-services.html">zh-CN</a></li><li><a
              href="../zh-TW/unix-services.html">zh-TW</a></li></ul></div></body></html>
